/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.notifySelection = exports.handleSingleSelection = exports.handleSelection = exports.handleMultiSelectionRowToggle = exports.handleMultiSelection = exports.findInitialSelectionIndex = void 0;

var _isControlledProperty = _interopRequireDefault(require("../../utils/isControlledProperty"));

var _batchUpdate = _interopRequireDefault(require("../../utils/batchUpdate"));

var _getGlobal = require("../../getGlobal");

var globalObject = (0, _getGlobal.getGlobal)();
var ua = globalObject.navigator ? globalObject.navigator.userAgent : '';
var isSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;

var delay35 = function delay35(fn) {
  return function () {
    return setTimeout(fn, 35);
  };
};

var now = function now(fn) {
  return function () {
    return fn();
  };
};

var findInitialSelectionIndex = function findInitialSelectionIndex(computedProps) {
  var selected = computedProps.getSelectedMap();
  var index = null;

  if (!selected || !Object.keys(selected).length) {
    return index;
  }

  var i = 0;
  var data = computedProps.data;
  var len = data.length;
  var id;

  for (; i < len; i++) {
    id = computedProps.getItemId(data[i]);

    if (selected[id]) {
      index = i;
    }
  }

  return index;
};

exports.findInitialSelectionIndex = findInitialSelectionIndex;

var notifySelection = function notifySelection(computedProps, selected, data, unselected, queue) {
  var queueDefined = !!queue;
  queue = queue || (0, _batchUpdate.default)();
  var onSelectionChange = (isSafari ? delay35 : now)(function () {
    if (typeof computedProps.onSelectionChange == 'function') {
      computedProps.onSelectionChange({
        selected: selected,
        data: data,
        unselected: unselected
      });
    }
  });

  if (!(0, _isControlledProperty.default)(computedProps.initialProps, 'unselected')) {
    var unselectedCount = computedProps.getUnselectedCount(unselected);
    queue(function () {
      computedProps.setUnselected(unselected);
    });
  }

  if (!(0, _isControlledProperty.default)(computedProps.initialProps, 'selected')) {
    queue(function () {
      computedProps.setSelected(selected, {
        silent: true
      });
    });
  }

  onSelectionChange();

  if (!queueDefined) {
    queue.commit();
  }
};

exports.notifySelection = notifySelection;

var handleSingleSelection = function handleSingleSelection(rowProps, computedProps, event, queue) {
  var data = rowProps.data;
  var rowSelected = computedProps.isRowSelected(data);
  var newSelected = !rowSelected;
  var ctrlKey = event.metaKey || event.ctrlKey;

  if (!computedProps.toggleRowSelectOnClick && rowSelected && event && !ctrlKey) {
    newSelected = true;
  }

  var selectedId = newSelected ? computedProps.getItemId(data) : null;
  notifySelection(computedProps, selectedId, data, null, queue);
};

exports.handleSingleSelection = handleSingleSelection;

var handleMultiSelection = function handleMultiSelection(computedProps, data, config, queue) {
  var selIndex = config.selIndex;
  var prevShiftKeyIndex = config.prevShiftKeyIndex;
  var map = selIndex == null ? {} : Object.assign({}, computedProps.computedSelected);

  if (prevShiftKeyIndex != null && selIndex != null) {
    var min = Math.min(prevShiftKeyIndex, selIndex);
    var max = Math.max(prevShiftKeyIndex, selIndex);
    var removeArray = computedProps.data.slice(min, max + 1) || [];
    removeArray.forEach(function (item) {
      if (item) {
        var id = computedProps.getItemId(item);
        delete map[id];
      }
    });
  }

  data.forEach(function (item) {
    if (item) {
      var id = computedProps.getItemId(item);
      map[id] = item;
    }
  });
  notifySelection(computedProps, map, data, null, queue);
};

exports.handleMultiSelection = handleMultiSelection;

var handleMultiSelectionRowToggle = function handleMultiSelectionRowToggle(computedProps, data, queue) {
  var selected = computedProps.computedSelected;
  var isSelected = computedProps.isRowSelected(data);

  if (selected !== true) {
    var clone = Object.assign({}, selected);
    var id = computedProps.getItemId(data);

    if (isSelected) {
      delete clone[id];
    } else {
      clone[id] = data;
    }

    notifySelection(computedProps, clone, data, null, queue);
  } else {
    var _id = computedProps.getItemId(data);

    var unselected = Object.assign({}, computedProps.computedUnselected);

    if (isSelected) {
      unselected[_id] = data;
    } else {
      delete unselected[_id];
    }

    notifySelection(computedProps, true, data, unselected, queue);
  }

  return isSelected;
};

exports.handleMultiSelectionRowToggle = handleMultiSelectionRowToggle;

var handleSelection = function handleSelection(rowProps, computedProps, event, queue) {
  var queueDefined = !!queue;

  if (!queue) {
    queue = (0, _batchUpdate.default)();
  }

  if (!computedProps.computedRowSelectionEnabled) {
    return;
  }

  if (!computedProps.computedRowMultiSelectionEnabled) {
    handleSingleSelection(rowProps, computedProps, event, queue);

    if (!queueDefined) {
      queue.commit();
    }

    return;
  }

  var selIndex = computedProps.selectionIndexRef.current;

  if (selIndex === null) {
    selIndex = findInitialSelectionIndex(computedProps);
  }

  var index = rowProps.rowIndex;
  var prevShiftKeyIndex = computedProps.shiftKeyIndexRef.current;
  var start;
  var end;
  var data;

  if (event.metaKey || event.ctrlKey || computedProps.toggleRowSelectOnClick && computedProps.getSelectedCount() === 1 && computedProps.isRowSelected(computedProps.data[index])) {
    computedProps.selectionIndexRef.current = index;
    computedProps.shiftKeyIndexRef.current = null;
    var unselect = handleMultiSelectionRowToggle(computedProps, computedProps.data[index], queue);

    if (!queueDefined) {
      queue.commit();
    }

    if (unselect) {
      computedProps.selectionIndexRef.current++;
      computedProps.shiftKeyIndexRef.current = prevShiftKeyIndex;
      return false;
    }

    return;
  }

  if (!event.shiftKey) {
    computedProps.selectionIndexRef.current = index;
    computedProps.shiftKeyIndexRef.current = null;
    selIndex = null;
  } else {
    computedProps.shiftKeyIndexRef.current = index;
  }

  if (selIndex == null) {
    data = [computedProps.data[index]];
  } else {
    start = Math.min(index, selIndex);
    end = Math.max(index, selIndex) + 1;
    data = computedProps.data.slice(start, end);
  }

  handleMultiSelection(computedProps, data, {
    selIndex: selIndex,
    prevShiftKeyIndex: prevShiftKeyIndex
  }, queue);

  if (!queueDefined) {
    queue.commit();
  }
};

exports.handleSelection = handleSelection;
/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = require("react");

var diff = function diff(a1, a2) {
  if (a1.length != a2.length) {
    return true;
  }

  for (var i = 0; i < a1.length; i++) {
    if (!Object.is(a1[i], a2[i])) {
      return true;
    }
  }

  return false;
};

var resolved = Promise.resolve(true);

var useLoadDataEffect = function useLoadDataEffect(_ref, fn, _ref2) {
  var getDataSource = _ref.getDataSource;
  var reloadDeps = _ref2.reloadDeps,
      noReloadDeps = _ref2.noReloadDeps;
  var prevComputedDepsRef = (0, _react.useRef)([]);
  var reloadRef = (0, _react.useRef)();
  var noReloadRef = (0, _react.useRef)();
  var reloadDepsDifferent = !reloadRef.current || diff(reloadRef.current, reloadDeps);
  var noReloadDepsDifferent = !noReloadRef.current || diff(noReloadRef.current, noReloadDeps);
  var depsDifferent = reloadDepsDifferent || noReloadDepsDifferent;
  var shouldReload = reloadDepsDifferent;
  var shouldReloadRef = (0, _react.useRef)(false);
  var computedDeps = depsDifferent ? [{}] : prevComputedDepsRef.current;
  var resolveRef = (0, _react.useRef)(null);
  var promiseRef = (0, _react.useRef)(resolved);

  if (depsDifferent) {
    shouldReloadRef.current = shouldReload;
    promiseRef.current = new Promise(function (resolve) {
      resolveRef.current = resolve;
    });
  }

  var _useState = (0, _react.useState)(function () {
    return new Set();
  }),
      _useState2 = (0, _slicedToArray2.default)(_useState, 1),
      pendingSet = _useState2[0];

  var intercept = (0, _react.useCallback)(function (promise, dataSource) {
    var isRemote = typeof dataSource === 'function' || (dataSource === null || dataSource === void 0 ? void 0 : dataSource.then);

    if (!isRemote) {}

    pendingSet.clear();
    pendingSet.add(promise);
    return promise.then(function (r) {
      if (pendingSet.has(promise)) {
        pendingSet.delete(promise);
        return r;
      }

      return Promise.reject({
        message: "This request is discarded as it was still pending when a new request came in.",
        result: r
      });
    });
  }, []);
  (0, _react.useLayoutEffect)(function () {
    var reload = shouldReloadRef.current;
    var dataSource = getDataSource({
      shouldReload: reload
    });
    fn(dataSource, {
      shouldReload: reload,
      intercept: intercept
    }).then(function () {
      if (resolveRef.current) {
        resolveRef.current();
      }
    });
    shouldReloadRef.current = shouldReload;
  }, computedDeps);
  reloadRef.current = reloadDeps;
  noReloadRef.current = noReloadDeps;
  prevComputedDepsRef.current = computedDeps;
  return promiseRef.current;
};

var _default = useLoadDataEffect;
exports.default = _default;
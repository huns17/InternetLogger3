/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _mapGroups = _interopRequireDefault(require("./mapGroups"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var getGroupsDepth = function getGroupsDepth(groupsMap) {
  if (!groupsMap) {
    return 0;
  }

  return Math.max.apply(Math, (0, _toConsumableArray2.default)(Object.keys(groupsMap).map(function (groupName) {
    return groupsMap[groupName].computedDepth || 0;
  })));
};

var getPivotGroups = function getPivotGroups(uniqueValuesRoot, parentGroup, pivotSummaryGroups) {
  var groups = [];
  var field = uniqueValuesRoot.field,
      values = uniqueValuesRoot.values;

  if (field && values) {
    Object.keys(values).forEach(function (value) {
      var groupId = "".concat(parentGroup ? parentGroup + '_' : '').concat(field, ":").concat(value);
      var defaultGroup = pivotSummaryGroups[field];
      var group = {
        name: groupId,
        header: value
      };

      if (defaultGroup) {
        if (typeof defaultGroup === 'function') {
          group = _objectSpread(_objectSpread({}, defaultGroup(_objectSpread(_objectSpread({}, group), {}, {
            field: field,
            values: values
          }))), group);
        } else {
          group = _objectSpread(_objectSpread({}, defaultGroup), group);
        }
      }

      if (parentGroup) {
        group.group = parentGroup;
      }

      groups.push(group);
      var nextRoot = values[value];
      groups.push.apply(groups, (0, _toConsumableArray2.default)(getPivotGroups(nextRoot, groupId, pivotSummaryGroups)));
    });
  }

  return groups;
};

var useGroups = function useGroups(props, computedProps) {
  var computedPivotUniqueValuesPerColumn = computedProps.computedPivotUniqueValuesPerColumn;
  var groups = props.groups;

  if (computedPivotUniqueValuesPerColumn && computedPivotUniqueValuesPerColumn.values) {
    var pivotSummaryGroups = computedProps.pivot ? computedProps.pivot.reduce(function (acc, pivot) {
      if (pivot && pivot.summaryGroup) {
        acc[pivot.name] = pivot.summaryGroup;
      }

      return acc;
    }, {}) : {};
    groups = getPivotGroups(computedPivotUniqueValuesPerColumn, undefined, pivotSummaryGroups);
  }

  var groupsMap = groups ? (0, _mapGroups.default)(groups, props) : null;
  var computedGroupsDepth = getGroupsDepth(groupsMap);
  return {
    computedGroups: groups,
    computedGroupsMap: groupsMap,
    computedGroupsDepth: computedGroupsDepth
  };
};

var _default = useGroups;
exports.default = _default;
/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = require("react");

var useEditable = function useEditable(props, computedProps, computedPropsRef) {
  var editInfoRef = (0, _react.useRef)(null);
  var isInEdit = (0, _react.useRef)(false);
  var currentEditCompletePromise = (0, _react.useRef)(Promise.resolve(true));
  var onEditStop = (0, _react.useCallback)(function (editProps) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    if (computedProps.initialProps.onEditStop) {
      computedProps.initialProps.onEditStop(editProps);
    }

    setTimeout(function () {
      editInfoRef.current = null;
    }, 0);
  }, []);
  var onEditCancel = (0, _react.useCallback)(function (editProps) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    if (computedProps.initialProps.onEditCancel) {
      computedProps.initialProps.onEditCancel(editProps);
    }

    setTimeout(function () {
      computedProps.isInEdit.current = false;
    }, 50);
  }, []);
  var onEditComplete = (0, _react.useCallback)(function (editProps) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    if (computedProps.autoFocusOnEditComplete) {
      computedProps.focus();
    }

    if (computedProps.initialProps.onEditComplete) {
      currentEditCompletePromise.current = Promise.resolve(computedProps.initialProps.onEditComplete(editProps));
    }

    computedProps.isInEdit.current = false;
  }, []);
  var onEditValueChange = (0, _react.useCallback)(function (editProps) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    if (computedProps.initialProps.onEditValueChange) {
      computedProps.initialProps.onEditValueChange(editProps);
    }
  }, []);
  var onEditStart = (0, _react.useCallback)(function (editProps) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    var columnId = editProps.columnId;
    editInfoRef.current = {
      columnId: columnId,
      columnIndex: editProps.columnIndex,
      rowId: editProps.rowId,
      rowIndex: editProps.rowIndex
    };

    if (computedProps.initialProps.onEditStart) {
      computedProps.initialProps.onEditStart(editProps);
    }

    requestAnimationFrame(function () {
      var computedProps = computedPropsRef.current;

      if (!computedProps) {
        return;
      }

      var col = computedProps.getColumnBy(columnId);

      if (!col) {
        return;
      }

      computedProps.scrollToColumn(col.computedVisibleIndex, {
        duration: 50
      });
    });
    computedProps.isInEdit.current = true;
  }, []);
  var tryStartEdit = (0, _react.useCallback)(function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      rowIndex: undefined,
      rowId: undefined,
      columnId: '',
      dir: 1
    },
        rowIndex = _ref.rowIndex,
        rowId = _ref.rowId,
        columnId = _ref.columnId,
        dir = _ref.dir;

    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return Promise.reject(new Error("Grid was probably unmounted"));
    }

    var col = computedProps.getColumnBy(columnId);

    if (!col) {
      return Promise.reject(new Error("No column found for columnId: ".concat(columnId)));
    }

    if (rowIndex === undefined) {
      rowIndex = computedProps.getRowIndexById(rowId);
    }

    return new Promise(function (resolve, reject) {
      computedProps.scrollToIndex(rowIndex, undefined, function () {
        setTimeout(function () {
          computedProps.getColumnLayout().tryStartEdit({
            rowIndex: rowIndex,
            rowId: rowId,
            columnIndex: col.computedVisibleIndex,
            columnId: columnId,
            dir: dir
          }).then(resolve, reject);
        }, 50);
      });
    });
  }, []);
  var startEdit = (0, _react.useCallback)(function () {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      rowIndex: undefined,
      rowId: undefined,
      columnId: '',
      dir: 1,
      value: ''
    },
        rowIndex = _ref2.rowIndex,
        rowId = _ref2.rowId,
        columnId = _ref2.columnId,
        dir = _ref2.dir,
        value = _ref2.value;

    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return Promise.reject(new Error("Grid was probably unmounted"));
    }

    var col = computedProps.getColumnBy(columnId);

    if (!col) {
      return Promise.reject(new Error("No column found for columnId: ".concat(columnId)));
    }

    if (rowIndex === undefined) {
      rowIndex = computedProps.getRowIndexById(rowId);
    }

    return new Promise(function (resolve, reject) {
      computedProps.scrollToIndex(rowIndex, undefined, function () {
        setTimeout(function () {
          computedProps.getColumnLayout().startEdit({
            rowIndex: rowIndex,
            rowId: rowId,
            columnIndex: col.computedVisibleIndex,
            columnId: columnId,
            value: value
          }).then(resolve, reject);
        }, 50);
      });
    });
  }, []);
  var completeEdit = (0, _react.useCallback)(function () {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      rowIndex: undefined,
      rowId: undefined,
      columnId: '',
      dir: 1,
      value: ''
    },
        rowId = _ref3.rowId,
        rowIndex = _ref3.rowIndex,
        columnId = _ref3.columnId,
        value = _ref3.value;

    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return Promise.reject(new Error("Grid was probably unmounted"));
    }

    var col = computedProps.getColumnBy(columnId);
    var editInfo = getCurrentEditInfo();

    if (!editInfo) {
      return;
    }

    if (!col && editInfo) {
      col = computedProps.getColumnBy(editInfo.columnId);
      rowIndex = editInfo.rowIndex;
    }

    if (!col) {
      return;
    }

    if (rowIndex === undefined) {
      rowIndex = computedProps.getRowIndexById(rowId);
    }

    computedProps.scrollToIndex(rowIndex, undefined, function () {
      setTimeout(function () {
        computedProps.getColumnLayout().completeEdit({
          rowIndex: rowIndex,
          columnIndex: col.computedVisibleIndex,
          value: value
        });
      }, 50);
    });
  }, []);
  var cancelEdit = (0, _react.useCallback)(function () {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      rowIndex: undefined,
      columnId: undefined
    },
        rowIndex = _ref4.rowIndex,
        columnId = _ref4.columnId;

    var editInfo = editInfoRef.current;

    if (!editInfo) {
      return;
    }

    var col = columnId ? computedProps.getColumnBy(columnId) : null;

    if (!col && editInfo) {
      col = computedProps.getColumnBy(editInfo.columnId);
      rowIndex = editInfo.rowIndex;
    }

    if (!col) {
      return;
    }

    computedProps.getColumnLayout().cancelEdit({
      rowIndex: rowIndex,
      columnIndex: col.computedVisibleIndex
    });
  }, []);
  var getCurrentEditInfo = (0, _react.useCallback)(function () {
    return editInfoRef.current;
  }, []);
  return {
    getCurrentEditInfo: getCurrentEditInfo,
    startEdit: startEdit,
    onEditStart: onEditStart,
    onEditStop: onEditStop,
    onEditCancel: onEditCancel,
    onEditComplete: onEditComplete,
    onEditValueChange: onEditValueChange,
    completeEdit: completeEdit,
    cancelEdit: cancelEdit,
    tryStartEdit: tryStartEdit,
    isInEdit: isInEdit,
    currentEditCompletePromise: currentEditCompletePromise
  };
};

var _default = useEditable;
exports.default = _default;
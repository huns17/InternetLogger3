/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var sum = function sum(a, b) {
  return (a || 0) + (b || 0);
};

var EMPTY_ARRAY = [];

var _default = function _default(_ref) {
  var flexes = _ref.flexes,
      availableSize = _ref.availableSize,
      _ref$maxWidths = _ref.maxWidths,
      maxWidths = _ref$maxWidths === void 0 ? EMPTY_ARRAY : _ref$maxWidths,
      _ref$minWidths = _ref.minWidths,
      minWidths = _ref$minWidths === void 0 ? EMPTY_ARRAY : _ref$minWidths;
  flexes = (0, _toConsumableArray2.default)(flexes);
  var sumOfAllFlexes = flexes.reduce(sum, 0);

  if (minWidths.length && minWidths.length != flexes.length) {
    throw 'minWidths.length needs to be === flexes.length';
  }

  if (maxWidths.length && maxWidths.length != flexes.length) {
    throw 'maxWidths.length needs to be === flexes.length';
  }

  var oneFlex = sumOfAllFlexes ? availableSize / sumOfAllFlexes : 0;
  var result = flexes.map(function (_) {
    return null;
  });
  flexes.forEach(function (flex, index) {
    var minWidth = minWidths[index];
    flex = flex || 0;

    if (flex === 0) {
      return;
    }

    var size;
    var flexSize = Math.round(flex * oneFlex);
    var maxWidth = maxWidths[index];

    if (minWidth != null && flexSize < minWidth) {
      availableSize -= minWidth;
      flexes[index] = 0;
      size = minWidth;
      sumOfAllFlexes -= flex;
      oneFlex = sumOfAllFlexes ? availableSize / sumOfAllFlexes : 0;
    } else if (maxWidth != null && flexSize > maxWidth) {
      availableSize -= maxWidth;
      flexes[index] = 0;
      size = maxWidth;
      sumOfAllFlexes -= flex;
      oneFlex = sumOfAllFlexes ? availableSize / sumOfAllFlexes : 0;
    }

    if (size) {
      result[index] = size;
    }
  });
  var lastValidFlexIndex = flexes.reduce(function (acc, flex, index) {
    return flex ? index : acc;
  }, -1);
  flexes.forEach(function (flex, index) {
    if (!flex) {
      return;
    }

    var flexSize = Math.round(flex * oneFlex);

    if (index === lastValidFlexIndex) {
      flexSize = availableSize;
    }

    if (minWidths[index] != null) {
      flexSize = Math.max(flexSize, minWidths[index] || 0);
    }

    if (maxWidths[index] != null) {
      flexSize = Math.min(flexSize, maxWidths[index] || Infinity);
    }

    availableSize -= Math.max(flexSize, 0);
    result[index] = flexSize;
  });
  return result;
};

exports.default = _default;
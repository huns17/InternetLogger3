/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _clamp = _interopRequireDefault(require("../clamp"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var normalize = function normalize(result) {
  var newColumnFlexes = result.newColumnFlexes,
      newColumnSizes = result.newColumnSizes,
      maxAvailableWidthForColumns = result.maxAvailableWidthForColumns;

  if (newColumnFlexes && !Object.keys(newColumnFlexes).length) {
    newColumnFlexes = undefined;
  }

  if (newColumnSizes && !Object.keys(newColumnSizes).length) {
    newColumnSizes = undefined;
  }

  return _objectSpread(_objectSpread({}, result), {}, {
    newColumnFlexes: newColumnFlexes,
    newColumnSizes: newColumnSizes,
    maxAvailableWidthForColumns: maxAvailableWidthForColumns
  });
};

var assignFlexes = function assignFlexes(columns) {
  return columns.reduce(function (flexes, col) {
    if (col.computedFlex) {
      flexes[col.id] = col.computedWidth;
    }

    return flexes;
  }, {});
};

var clampColSize = function clampColSize(size, col) {
  return (0, _clamp.default)(size, col.computedMinWidth, col.computedMaxWidth);
};

var resizeGroupColumns = function resizeGroupColumns(arg, config) {
  var totalDiff = arg.diff,
      maxAvailableWidthForColumns = arg.maxAvailableWidthForColumns,
      shareSpaceOnResize = arg.shareSpaceOnResize,
      index = arg.index,
      groupColumns = arg.groupColumns,
      columns = arg.columns;
  columns = columns.map(function (c) {
    return _objectSpread({}, c);
  });
  var newColumnSizes = config.newColumnSizes || {};
  var columnsMap = columns.reduce(function (map, col) {
    map[col.id] = col;
    return map;
  }, {});

  var newColumnFlexes = _objectSpread(_objectSpread({}, assignFlexes(groupColumns.map(function (colId) {
    return columnsMap[colId];
  }))), config.newColumnFlexes);

  while (Math.abs(totalDiff) > 0) {
    groupColumns.forEach(function (colId, idx) {
      var col = columnsMap[colId];

      if (col.computedResizable === false) {
        return;
      }

      var totalGroupResizableWidth = groupColumns.slice(idx).reduce(function (total, colId) {
        var col = columnsMap[colId];

        if (col.computedResizable === false) {
          return total;
        }

        if (totalDiff > 0 && col.computedMaxWidth && col.computedWidth >= col.computedMaxWidth) {
          return total;
        }

        if (totalDiff < 0 && col.computedMinWidth && col.computedWidth <= col.computedMinWidth) {
          return total;
        }

        return total + col.computedWidth;
      }, 0);
      var diff = totalGroupResizableWidth ? Math.round(col.computedWidth / totalGroupResizableWidth * totalDiff) : 0;
      var adjustment = 0;

      if (!col.computedFlex) {
        newColumnSizes[col.id] = col.computedWidth = col.computedWidth + diff;
      } else {
        delete newColumnSizes[col.id];
        newColumnFlexes[col.id] = col.computedWidth = col.computedWidth + diff;
      }

      if (newColumnSizes[col.id] !== undefined) {
        var size = newColumnSizes[col.id];
        var clampedSize = (0, _clamp.default)(size, col.computedMinWidth, col.computedMaxWidth);

        if (clampedSize !== size) {
          adjustment = size - clampedSize;
          newColumnSizes[col.id] = clampedSize;
        }
      } else if (newColumnFlexes[col.id] !== undefined) {
        var _size = newColumnFlexes[col.id];

        var _clampedSize = (0, _clamp.default)(_size, col.computedMinWidth, col.computedMaxWidth);

        if (_clampedSize !== _size) {
          adjustment = _size - _clampedSize;
          newColumnFlexes[col.id] = col.computedWidth = _clampedSize;
        }
      }

      if (diff === 0) {
        totalDiff = 0;
      } else {
        totalDiff = totalDiff - diff + adjustment;
      }
    });
  }

  return normalize(_objectSpread(_objectSpread({}, config), {}, {
    newColumnSizes: newColumnSizes,
    newColumnFlexes: newColumnFlexes
  }));
};

var _default = function _default(arg) {
  var shareSpaceOnResize = arg.shareSpaceOnResize,
      groupColumns = arg.groupColumns;
  var result = shareSpaceOnResize ? resizeShareSpace(arg) : resizeNoShareSpace(arg);

  if (groupColumns) {
    return resizeGroupColumns(arg, result);
  }

  return result;
};

exports.default = _default;

var resizeShareSpace = function resizeShareSpace(arg) {
  var columns = arg.columns,
      index = arg.index,
      diff = arg.diff;
  var maxAvailableWidthForColumns = arg.maxAvailableWidthForColumns;
  var colLeft = columns[index];
  var colsToRight = columns.slice(index + 1);
  var colRight = colsToRight[0];

  if (!colRight || colRight.computedResizable === false) {
    return resizeNoShareSpace(arg);
  }

  if (!colLeft.computedFlex && !colRight.computedFlex) {
    var _newColumnSizes;

    var newColLeftSize = colLeft.computedWidth + diff;
    var newColRightSize = clampColSize(colRight.computedWidth - diff, colRight);
    var remainingDiff = newColRightSize - (colRight.computedWidth - diff);
    var newColumnSizes = (_newColumnSizes = {}, (0, _defineProperty2.default)(_newColumnSizes, colLeft.id, newColLeftSize + remainingDiff), (0, _defineProperty2.default)(_newColumnSizes, colRight.id, newColRightSize), _newColumnSizes);
    return normalize({
      newColumnSizes: newColumnSizes,
      maxAvailableWidthForColumns: maxAvailableWidthForColumns
    });
  }

  if (colLeft.computedFlex && colRight.computedFlex) {
    var newColumnFlexes = assignFlexes(columns);
    newColumnFlexes[colLeft.id] = colLeft.computedWidth + diff;
    newColumnFlexes[colRight.id] = colRight.computedWidth - diff;
    return normalize({
      newColumnFlexes: newColumnFlexes,
      maxAvailableWidthForColumns: maxAvailableWidthForColumns
    });
  }

  if (!colLeft.computedFlex) {
    var _newColumnFlexes = assignFlexes(columns);

    var _newColumnSizes2 = (0, _defineProperty2.default)({}, colLeft.id, colLeft.computedWidth + diff);

    _newColumnFlexes[colRight.id] = colRight.computedWidth - diff;
    return normalize({
      newColumnFlexes: _newColumnFlexes,
      newColumnSizes: _newColumnSizes2,
      maxAvailableWidthForColumns: maxAvailableWidthForColumns
    });
  }

  if (!colRight.computedFlex) {
    var flexCount = columns.reduce(function (count, col) {
      return count + (col.computedFlex ? 1 : 0);
    }, 0);

    var _newColumnFlexes2 = assignFlexes(columns);

    var _newColumnSizes4 = (0, _defineProperty2.default)({}, colRight.id, colRight.computedWidth - diff);

    _newColumnFlexes2[colLeft.id] = colLeft.computedWidth + diff;

    if (flexCount === 1 && colLeft.computedFlex) {
      _newColumnFlexes2 = {};
    }

    return normalize({
      newColumnFlexes: _newColumnFlexes2,
      newColumnSizes: _newColumnSizes4,
      maxAvailableWidthForColumns: maxAvailableWidthForColumns
    });
  }
};

var resizeNoShareSpace = function resizeNoShareSpace(arg) {
  var columns = arg.columns,
      index = arg.index,
      diff = arg.diff,
      totalComputedWidth = arg.totalComputedWidth;
  var maxAvailableWidthForColumns = arg.maxAvailableWidthForColumns;
  var colLeft = columns[index];
  var colsToRight = columns.slice(index + 1);
  var colRight = colsToRight[0];
  var newColumnSizes;
  var newColumnFlexes;
  var flexCount = columns.reduce(function (count, col) {
    return count + (col.computedFlex ? 1 : 0);
  }, 0);

  if (!colLeft.computedFlex) {
    if (!flexCount) {
      newColumnSizes = {};

      if (colLeft.computedResizable !== false) {
        newColumnSizes[colLeft.id] = clampColSize(colLeft.computedWidth + diff, colLeft);
      }

      return normalize({
        newColumnSizes: newColumnSizes,
        newColumnFlexes: undefined,
        maxAvailableWidthForColumns: maxAvailableWidthForColumns
      });
    }

    newColumnSizes = {};
    newColumnSizes[colLeft.id] = clampColSize(colLeft.computedWidth + diff, colLeft);
    return normalize({
      newColumnSizes: newColumnSizes,
      newColumnFlexes: assignFlexes(columns),
      maxAvailableWidthForColumns: totalComputedWidth + diff
    });
  }

  newColumnFlexes = assignFlexes(columns);
  newColumnFlexes[colLeft.id] = colLeft.computedWidth + diff;

  if (flexCount === 1) {
    if (!colLeft.keepFlex) {
      delete newColumnFlexes[colLeft.id];
      newColumnSizes = {};
      newColumnSizes[colLeft.id] = clampColSize(colLeft.computedWidth + diff, colLeft);
    } else {
      newColumnFlexes = {};
      maxAvailableWidthForColumns = totalComputedWidth + diff;
    }
  } else {
    if (!colLeft.keepFlex) {
      delete newColumnFlexes[colLeft.id];
      newColumnSizes = {};
      newColumnSizes[colLeft.id] = clampColSize(colLeft.computedWidth + diff, colLeft);
      maxAvailableWidthForColumns = totalComputedWidth + diff;
    } else {
      newColumnFlexes[colLeft.id] = colLeft.computedWidth + diff;
      maxAvailableWidthForColumns = totalComputedWidth + diff;
    }
  }

  return normalize({
    newColumnFlexes: newColumnFlexes,
    newColumnSizes: newColumnSizes,
    maxAvailableWidthForColumns: maxAvailableWidthForColumns
  });
};
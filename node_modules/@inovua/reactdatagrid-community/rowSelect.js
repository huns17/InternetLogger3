/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getGlobal = require("./getGlobal");

var globalObject = (0, _getGlobal.getGlobal)();
var ua = globalObject.navigator ? globalObject.navigator.userAgent : '';
var isSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;

var delay35 = function delay35(fn) {
  return function () {
    return setTimeout(fn, 35);
  };
};

var now = function now(fn) {
  return function () {
    return fn();
  };
};

var _default = {
  findInitialSelectionIndex: function findInitialSelectionIndex() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
    var selected = this.getSelectedMap(props);
    var index = undefined;

    if (!selected || !Object.keys(selected).length) {
      return index;
    }

    var i = 0;
    var data = this.p.data;
    var len = data.length;
    var id;

    for (; i < len; i++) {
      id = this.getItemId(data[i]);

      if (selected[id]) {
        index = i;
      }
    }

    return index;
  },
  notifySelection: function notifySelection(selected, data, unselected) {
    var _this = this;

    var handled = false;
    var onSelectionChange = (isSafari ? delay35 : now)(function () {
      if (typeof _this.props.onSelectionChange == 'function') {
        _this.props.onSelectionChange({
          selected: selected,
          data: data,
          unselected: unselected
        });
      }
    });

    if (!this.isUnselectedControlled()) {
      var unselectedCount = this.getUnselectedCount(undefined, undefined, unselected);
      handled = true;
      this.update({
        unselected: unselected,
        unselectedCount: unselectedCount
      }, onSelectionChange);
    }

    if (!this.isSelectionControlled()) {
      handled = true;
      this.update({
        selected: selected,
        selectedCount: this.getSelectedCount(undefined, undefined, selected, unselected)
      }, onSelectionChange);
    }

    if (!handled) {
      onSelectionChange();
    }
  },
  handleSingleSelection: function handleSingleSelection(data, event) {
    var rowSelected = this.isRowSelected(data);
    var newSelected = !rowSelected;
    var ctrlKey = event.metaKey || event.ctrlKey;

    if (!this.props.toggleRowSelectOnClick && rowSelected && event && !ctrlKey) {
      newSelected = true;
    }

    var selectedId = newSelected ? this.getItemId(data) : null;
    this.notifySelection(selectedId, data);
  },
  handleMultiSelection: function handleMultiSelection(data, event, config) {
    var _this2 = this;

    var selIndex = config.selIndex;
    var prevShiftKeyIndex = config.prevShiftKeyIndex;
    var props = this.p;
    var map = selIndex == null ? {} : Object.assign({}, this.getSelected(props, this.state));

    if (prevShiftKeyIndex != null && selIndex != null) {
      var min = Math.min(prevShiftKeyIndex, selIndex);
      var max = Math.max(prevShiftKeyIndex, selIndex);
      var removeArray = props.data.slice(min, max + 1) || [];
      removeArray.forEach(function (item) {
        if (item) {
          var id = _this2.getItemId(item);

          delete map[id];
        }
      });
    }

    data.forEach(function (item) {
      if (item) {
        var id = _this2.getItemId(item);

        map[id] = item;
      }
    });
    this.notifySelection(map, data);
  },
  handleMultiSelectionRowToggle: function handleMultiSelectionRowToggle(data) {
    var selected = this.p.selected;
    var isSelected = this.isRowSelected(data);

    if (selected !== true) {
      var clone = Object.assign({}, selected);
      var id = this.getItemId(data);

      if (isSelected) {
        delete clone[id];
      } else {
        clone[id] = data;
      }

      this.notifySelection(clone, data);
    } else {
      var _id = this.getItemId(data);

      var unselected = Object.assign({}, this.getUnselected());

      if (isSelected) {
        unselected[_id] = data;
      } else {
        delete unselected[_id];
      }

      this.notifySelection(true, data, unselected);
    }

    return isSelected;
  },
  handleSelection: function handleSelection(rowProps, event) {
    var props = this.p;

    if (!this.isSelectionEnabled()) {
      return;
    }

    var multiSelect = this.isMultiSelect();

    if (!multiSelect) {
      this.handleSingleSelection(rowProps.data, event);
      return;
    }

    if (this.selIndex === undefined) {
      this.selIndex = this.findInitialSelectionIndex();
    }

    var selIndex = this.selIndex;
    var index = rowProps.rowIndex;
    var prevShiftKeyIndex = this.shiftKeyIndex;
    var start;
    var end;
    var data;

    if (event.metaKey || event.ctrlKey || this.props.toggleRowSelectOnClick && this.getSelectedCount() === 1 && this.isRowSelected(props.data[index])) {
      this.selIndex = index;
      this.shiftKeyIndex = null;
      var unselect = this.handleMultiSelectionRowToggle(props.data[index], event);

      if (unselect) {
        this.selIndex++;
        this.shiftKeyIndex = prevShiftKeyIndex;
        return false;
      }

      return;
    }

    if (!event.shiftKey) {
      this.selIndex = index;
      this.shiftKeyIndex = null;
      selIndex = null;
    } else {
      this.shiftKeyIndex = index;
    }

    if (selIndex == null) {
      data = [props.data[index]];
    } else {
      start = Math.min(index, selIndex);
      end = Math.max(index, selIndex) + 1;
      data = props.data.slice(start, end);
    }

    this.handleMultiSelection(data, event, {
      selIndex: selIndex,
      prevShiftKeyIndex: prevShiftKeyIndex
    });
  }
};
exports.default = _default;
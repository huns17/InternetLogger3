/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _useProperty3 = _interopRequireDefault(require("@inovua/reactdatagrid-community/hooks/useProperty"));

var _react = require("react");

var _clamp = _interopRequireDefault(require("@inovua/reactdatagrid-community/utils/clamp"));

var _usePrevious = _interopRequireDefault(require("@inovua/reactdatagrid-community/hooks/usePrevious"));

var _batchUpdate = _interopRequireDefault(require("@inovua/reactdatagrid-community/utils/batchUpdate"));

var useActiveCell = function useActiveCell(props, computedPropsRef) {
  var _useProperty = (0, _useProperty3.default)(props, 'activeCell'),
      _useProperty2 = (0, _slicedToArray2.default)(_useProperty, 2),
      computedActiveCell = _useProperty2[0],
      doSetActiveCell = _useProperty2[1];

  if (!props.enableKeyboardNavigation) {
    computedActiveCell = undefined;
  }

  var setActiveCell = (0, _react.useCallback)(function (activeCell, queue) {
    var computedProps = computedPropsRef.current;

    if (!computedProps || !computedProps.computedCellNavigationEnabled) {
      return;
    }

    var computedActiveCell = computedProps.computedActiveCell,
        data = computedProps.data,
        visibleColumns = computedProps.visibleColumns;
    var shouldCommit = !queue;
    queue = queue || (0, _batchUpdate.default)();

    if (activeCell) {
      var _activeCell = activeCell,
          _activeCell2 = (0, _slicedToArray2.default)(_activeCell, 2),
          activeCellRowIndex = _activeCell2[0],
          activeCellColumnIndex = _activeCell2[1];

      activeCellRowIndex = (0, _clamp.default)(activeCellRowIndex, 0, data.length - 1);
      activeCellColumnIndex = (0, _clamp.default)(activeCellColumnIndex, 0, visibleColumns.length - 1);
      var col = computedProps.getColumnBy(activeCellColumnIndex);

      if (col && col.cellSelectable === false) {
        return;
      }

      if (!data || data.__group || activeCellRowIndex == null || activeCellColumnIndex == null) {
        queue(function () {
          doSetActiveCell(null);
          computedProps.setLastCellInRange('');
        });

        if (shouldCommit) {
          queue.commit();
        }

        return;
      }

      activeCell = [activeCellRowIndex, activeCellColumnIndex];

      if (activeCell === computedActiveCell || computedActiveCell && activeCell && computedActiveCell[0] === activeCell[0] && computedActiveCell[1] === activeCell[1]) {
        return;
      }
    }

    queue(function () {
      doSetActiveCell(activeCell);
      computedProps.setLastCellInRange('');
    });

    if (shouldCommit) {
      queue.commit();
    }
  }, []);
  var oldActiveCell = (0, _usePrevious.default)(computedActiveCell, null);
  (0, _react.useLayoutEffect)(function () {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    if (oldActiveCell !== computedActiveCell && computedActiveCell) {
      var _computedActiveCell = computedActiveCell,
          _computedActiveCell2 = (0, _slicedToArray2.default)(_computedActiveCell, 2),
          rowIndex = _computedActiveCell2[0],
          columnIndex = _computedActiveCell2[1];

      if (rowIndex == null || columnIndex == null) {
        return;
      }

      var top = !oldActiveCell || rowIndex < oldActiveCell[0];
      var right = !oldActiveCell || columnIndex > oldActiveCell[1];
      var scrollToColumnIndex = (0, _clamp.default)(columnIndex + (right ? 0 : -0), 0, computedProps.visibleColumns.length - 1);
      computedProps.scrollToCell({
        rowIndex: rowIndex,
        columnIndex: scrollToColumnIndex
      }, {
        top: top,
        right: right
      });
    }
  }, [computedActiveCell, oldActiveCell]);
  var getCellSelectionBetween = (0, _react.useCallback)(function (start, end) {
    var computedProps = computedPropsRef.current;

    if (!start || !end || !computedProps) {
      return {};
    }

    var startRow = Math.min(start[0], end[0]);
    var startCol = Math.min(start[1], end[1]);
    var endRow = Math.max(start[0], end[0]);
    var endCol = Math.max(start[1], end[1]);
    var range = {};
    var groupBy = computedProps.computedGroupBy;
    var dataSource = groupBy ? computedProps.data : [];
    var current;

    for (var row = startRow; row <= endRow; row++) {
      if (groupBy) {
        current = dataSource[row];

        if (!current) {
          break;
        }

        if (current.__group) {
          continue;
        }
      }

      for (var col = startCol; col <= endCol; col++) {
        range[getCellSelectionKey(row, col)] = true;
      }
    }

    return range;
  }, []);
  var getCellSelectionKey = (0, _react.useCallback)(function (cellProps, col) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return -1;
    }

    var rowKey;
    var colKey;

    if (typeof cellProps === 'string') {
      return cellProps;
    }

    if (typeof cellProps === 'number' && typeof col === 'number') {
      rowKey = cellProps;
      colKey = col;
    } else {
      if (cellProps) {
        rowKey = cellProps.rowIndex;
        colKey = cellProps.columnIndex;
      }
    }

    if (!computedProps.cellSelectionByIndex) {
      return computedProps.getCellSelectionIdKey(rowKey, colKey);
    }

    return "".concat([rowKey, colKey]);
  }, [computedPropsRef, props.columns]);
  var getCellSelectionIdKey = (0, _react.useCallback)(function (rowIndex, columnIndex) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return -1;
    }

    var col = computedProps.getColumnBy(columnIndex);

    if (!col) {
      return -1;
    }

    var colId = col.id || col.name;
    var item = computedProps.getItemAt(rowIndex);

    if (!item) {
      return '';
    }

    var rowId = computedProps.getItemId(item);
    return "".concat([rowId, colId]);
  }, []);
  var incrementActiveCell = (0, _react.useCallback)(function (direction) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    var computedActiveCell = computedProps.computedActiveCell;

    if (!computedActiveCell) {
      computedActiveCell = [0, 0];
    }

    var _direction = (0, _slicedToArray2.default)(direction, 2),
        row = _direction[0],
        col = _direction[1];

    var data = computedProps.data,
        visibleColumns = computedProps.visibleColumns,
        computedGroupBy = computedProps.computedGroupBy,
        groupColumn = computedProps.groupColumn;
    var maxRow = data.length - 1;
    var columns = visibleColumns;
    var maxCol = columns.length - 1;
    var groupBy = computedGroupBy;
    var minCol = groupBy && !groupColumn ? groupBy.length : 0;
    var rowIndex = computedActiveCell[0];
    var colIndex = computedActiveCell[1];

    if (row) {
      var rowSign = row < 0 ? -1 : 1;
      var rowAdd = row;

      while (data[rowIndex + rowAdd] && data[rowIndex + rowAdd].__group) {
        rowIndex += rowAdd;
        rowAdd = rowSign;
      }

      rowIndex += rowAdd;
    }

    if (col) {
      var colSign = col < 0 ? -1 : 1;
      var colAdd = col;

      while (columns[colIndex + colAdd] && columns[colIndex + colAdd].cellSelectable === false) {
        colIndex += colSign;
        colAdd = colSign;
      }

      colIndex += colAdd;
    }

    rowIndex = (0, _clamp.default)(rowIndex, 0, maxRow);
    colIndex = (0, _clamp.default)(colIndex, minCol, maxCol);
    computedProps.setActiveCell([rowIndex, colIndex]);
  }, []);
  return {
    getCellSelectionBetween: getCellSelectionBetween,
    getCellSelectionIdKey: getCellSelectionIdKey,
    computedActiveCell: computedActiveCell,
    setActiveCell: setActiveCell,
    getCellSelectionKey: getCellSelectionKey,
    incrementActiveCell: incrementActiveCell
  };
};

var _default = useActiveCell;
exports.default = _default;
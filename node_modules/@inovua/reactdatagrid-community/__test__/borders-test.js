/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = require("react-dom");

var _reactAddonsTestUtils = _interopRequireDefault(require("react-addons-test-utils"));

var _2 = _interopRequireDefault(require(".."));

var _testUtils = require("../testUtils");

require("../../style/index.scss");

var _Cell = _interopRequireDefault(require("../Layout/ColumnLayout/Cell"));

var _Row = _interopRequireDefault(require("../Layout/ColumnLayout/Content/Row"));

var LOCK_MARGIN_WIDTH = 4;

var findCellsInRow = function findCellsInRow(row) {
  return _reactAddonsTestUtils.default.findAllInRenderedTree(row, function (cmp) {
    return cmp.constructor === _Cell.default;
  });
};

var findRowAt = function findRowAt(tree, index) {
  var rows = _reactAddonsTestUtils.default.findAllInRenderedTree(tree, function (cmp) {
    return cmp.constructor === _Row.default && cmp.props.rowIndex == index;
  });

  return rows[0];
};

describe('showCellBorders: true', function () {
  it('should correctly set borders to all cells, when we have groupBy & expandGroupTitle', function (done) {
    var columns = [{
      name: 'country',
      defaultWidth: 100,
      locked: true
    }, {
      name: 'firstName',
      defaultWidth: 100
    }, {
      name: 'lastName',
      defaultWidth: 100,
      locked: true
    }, {
      name: 'lastName1',
      defaultWidth: 100
    }, {
      name: 'email',
      defaultWidth: 100,
      locked: 'end'
    }, {
      name: 'x',
      defaultWidth: 100,
      locked: 'end'
    }];
    var gridInstance = (0, _testUtils.render)(_react.default.createElement(_2.default, {
      columns: columns,
      hideGroupByColumns: false,
      virtualizeColumns: false,
      idProperty: "id",
      groupBy: ['country', 'email', 'firstName'],
      expandGroupTitle: true,
      showCellBorders: true,
      dataSource: [{
        lastName: 'a last name',
        firstName: 'john is a very long name so it better be ellipsed in a ',
        email: 'john@gmail.com',
        id: 1,
        country: 'uk'
      }, {
        firstName: 'john2',
        email: 'john@gmail.com',
        id: 11,
        country: 'uk'
      }, {
        firstName: 'john is a very long name so it better be ellipsed in a ',
        email: 'john@gmail.com',
        id: 12,
        country: 'uk'
      }, {
        firstName: 'marry',
        email: 'marry@gmail.com',
        id: 2,
        country: 'uk'
      }, {
        firstName: 'marry',
        email: 'marry@gmail.com',
        id: 122,
        country: 'uk'
      }]
    }));
    setTimeout(function () {
      var rows = (0, _toConsumableArray2.default)((0, _reactDom.findDOMNode)(gridInstance).querySelectorAll('.InovuaReactDataGrid__row'));
      expect(rows.length).to.equal(11);
      var rowIndexes = (0, _toConsumableArray2.default)(Array(11)).map(function (_, i) {
        return i;
      });
      rows = rowIndexes.map(function (i) {
        return findRowAt(gridInstance, i);
      });
      var cellBorders = rows.map(function (row) {
        var cells = findCellsInRow(row);
        return cells.map(function (cell) {
          var style = getComputedStyle((0, _reactDom.findDOMNode)(cell));
          var top = parseInt(style['border-top-width']);
          var right = parseInt(style['border-right-width']);
          var bottom = parseInt(style['border-bottom-width']);
          var left = parseInt(style['border-left-width']);
          return "".concat(top, ";").concat(right, ";").concat(bottom, ";").concat(left);
        });
      });
      var totalColumns = columns.length + 3;
      expect(cellBorders.length).to.equal(11);
      expect(cellBorders[0].length).to.equal(totalColumns);
      var hiddenCell = '0;0;0;0';
      var hiddenFirstCell = '1;0;0;0';
      expect(cellBorders[0]).to.deep.equal(["1;0;0;0", "1;1;0;0", hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell]);
      expect(cellBorders[1]).to.deep.equal([hiddenCell, "1;0;0;1", "1;1;0;0", hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell]);
      expect(cellBorders[2]).to.deep.equal([hiddenCell, "0;0;0;1", "1;0;0;1", "1;1;0;0", hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell]);
      expect(cellBorders[3]).to.deep.equal([hiddenCell, "0;0;0;1", "0;0;0;1", "1;0;1;1", "1;".concat(LOCK_MARGIN_WIDTH, ";1;1"), "1;0;1;0", "1;0;1;1", "1;0;1;".concat(LOCK_MARGIN_WIDTH), "1;1;1;1"]);
      expect(cellBorders[4]).to.deep.equal([hiddenCell, '0;0;0;1', '0;0;0;1', '0;0;0;1', "0;".concat(LOCK_MARGIN_WIDTH, ";0;1"), hiddenCell, '0;0;0;1', "0;0;0;".concat(LOCK_MARGIN_WIDTH), "0;1;0;1"]);
      expect(cellBorders[5]).to.deep.equal(cellBorders[2]);
      expect(cellBorders[6]).to.deep.equal([hiddenCell, "0;0;0;1", "0;0;0;1", "1;0;0;1", "1;".concat(LOCK_MARGIN_WIDTH, ";0;1"), "1;0;0;0", "1;0;0;1", "1;0;0;".concat(LOCK_MARGIN_WIDTH), "1;1;0;1"]);
      expect(cellBorders[7]).to.deep.equal(cellBorders[1]);
      expect(cellBorders[8]).to.deep.equal(cellBorders[2]);
      expect(cellBorders[9]).to.deep.equal(cellBorders[3]);
      expect(cellBorders[10]).to.deep.equal(["0;0;1;0", "0;0;1;1", "0;0;1;1", "0;0;1;1", "0;".concat(LOCK_MARGIN_WIDTH, ";1;1"), "0;0;1;0", "0;0;1;1", "0;0;1;".concat(LOCK_MARGIN_WIDTH), "0;1;1;1"]);
      gridInstance.unmount();
      done();
    }, 100);
  });
});
describe('showCellBorders: true and grid.width > availableWidth', function () {
  it('should correctly set borders to all cells, when we have groupBy & expandGroupTitle', function (done) {
    var columns = [{
      name: 'country',
      defaultWidth: 500,
      locked: true
    }, {
      name: 'firstName',
      defaultWidth: 500
    }, {
      name: 'lastName',
      defaultWidth: 500,
      locked: true
    }, {
      name: 'lastName1',
      defaultWidth: 500
    }, {
      name: 'email',
      defaultWidth: 500,
      locked: 'end'
    }, {
      name: 'x',
      defaultWidth: 500,
      locked: 'end'
    }];
    var gridInstance = (0, _testUtils.render)(_react.default.createElement(_2.default, {
      columns: columns,
      hideGroupByColumns: false,
      virtualizeColumns: false,
      idProperty: "id",
      groupBy: ['country', 'email', 'firstName'],
      expandGroupTitle: true,
      showCellBorders: true,
      dataSource: [{
        lastName: 'a last name',
        firstName: 'john is a very long name so it better be ellipsed in a ',
        email: 'john@gmail.com',
        id: 1,
        country: 'uk'
      }, {
        firstName: 'john2',
        email: 'john@gmail.com',
        id: 11,
        country: 'uk'
      }, {
        firstName: 'john is a very long name so it better be ellipsed in a ',
        email: 'john@gmail.com',
        id: 12,
        country: 'uk'
      }, {
        firstName: 'marry',
        email: 'marry@gmail.com',
        id: 2,
        country: 'uk'
      }, {
        firstName: 'marry',
        email: 'marry@gmail.com',
        id: 122,
        country: 'uk'
      }]
    }));
    setTimeout(function () {
      var rows = (0, _toConsumableArray2.default)((0, _reactDom.findDOMNode)(gridInstance).querySelectorAll('.InovuaReactDataGrid__row'));
      expect(rows.length).to.equal(11);
      var rowIndexes = (0, _toConsumableArray2.default)(Array(11)).map(function (_, i) {
        return i;
      });
      rows = rowIndexes.map(function (i) {
        return findRowAt(gridInstance, i);
      });
      var cellBorders = rows.map(function (row) {
        var cells = findCellsInRow(row);
        return cells.map(function (cell) {
          var style = getComputedStyle((0, _reactDom.findDOMNode)(cell));
          var top = parseInt(style['border-top-width']);
          var right = parseInt(style['border-right-width']);
          var bottom = parseInt(style['border-bottom-width']);
          var left = parseInt(style['border-left-width']);
          return "".concat(top, ";").concat(right, ";").concat(bottom, ";").concat(left);
        });
      });
      var totalColumns = columns.length + 3;
      expect(cellBorders.length).to.equal(11);
      expect(cellBorders[0].length).to.equal(totalColumns);
      var hiddenCell = '0;0;0;0';
      var hiddenFirstCell = '1;0;0;0';
      expect(cellBorders[0]).to.deep.equal(["1;0;0;0", "1;0;0;0", hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell]);
      expect(cellBorders[1]).to.deep.equal([hiddenCell, "1;0;0;1", "1;0;0;0", hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell]);
      expect(cellBorders[2]).to.deep.equal([hiddenCell, "0;0;0;1", "1;0;0;1", "1;0;0;0", hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell]);
      expect(cellBorders[3]).to.deep.equal([hiddenCell, "0;0;0;1", "0;0;0;1", "1;0;1;1", "1;".concat(LOCK_MARGIN_WIDTH, ";1;1"), "1;0;1;0", "1;0;1;1", "1;0;1;".concat(LOCK_MARGIN_WIDTH), "1;0;1;1"]);
      expect(cellBorders[4]).to.deep.equal([hiddenCell, '0;0;0;1', '0;0;0;1', '0;0;0;1', "0;".concat(LOCK_MARGIN_WIDTH, ";0;1"), hiddenCell, '0;0;0;1', "0;0;0;".concat(LOCK_MARGIN_WIDTH), "0;0;0;1"]);
      expect(cellBorders[5]).to.deep.equal(cellBorders[2]);
      expect(cellBorders[6]).to.deep.equal([hiddenCell, "0;0;0;1", "0;0;0;1", "1;0;0;1", "1;".concat(LOCK_MARGIN_WIDTH, ";0;1"), "1;0;0;0", "1;0;0;1", "1;0;0;".concat(LOCK_MARGIN_WIDTH), "1;0;0;1"]);
      expect(cellBorders[7]).to.deep.equal(cellBorders[1]);
      expect(cellBorders[8]).to.deep.equal(cellBorders[2]);
      expect(cellBorders[9]).to.deep.equal(cellBorders[3]);
      expect(cellBorders[10]).to.deep.equal(["0;0;1;0", "0;0;1;1", "0;0;1;1", "0;0;1;1", "0;".concat(LOCK_MARGIN_WIDTH, ";1;1"), "0;0;1;0", "0;0;1;1", "0;0;1;".concat(LOCK_MARGIN_WIDTH), "0;0;1;1"]);
      gridInstance.unmount();
      done();
    }, 100);
  });
});
describe('showCellBorders: false', function () {
  it('should correctly set borders to all cells, when we have groupBy & expandGroupTitle', function (done) {
    var columns = [{
      name: 'country',
      defaultWidth: 100,
      locked: true
    }, {
      name: 'firstName',
      defaultWidth: 100
    }, {
      name: 'lastName',
      defaultWidth: 100,
      locked: true
    }, {
      name: 'lastName1',
      defaultWidth: 100
    }, {
      name: 'email',
      defaultWidth: 100,
      locked: 'end'
    }, {
      name: 'x',
      defaultWidth: 100,
      locked: 'end'
    }];
    var gridInstance = (0, _testUtils.render)(_react.default.createElement(_2.default, {
      columns: columns,
      hideGroupByColumns: false,
      virtualizeColumns: false,
      idProperty: "id",
      groupBy: ['country', 'email', 'firstName'],
      expandGroupTitle: true,
      showCellBorders: false,
      dataSource: [{
        lastName: 'a last name',
        firstName: 'john is a very long name so it better be ellipsed in a ',
        email: 'john@gmail.com',
        id: 1,
        country: 'uk'
      }, {
        firstName: 'john2',
        email: 'john@gmail.com',
        id: 11,
        country: 'uk'
      }, {
        firstName: 'john is a very long name so it better be ellipsed in a ',
        email: 'john@gmail.com',
        id: 12,
        country: 'uk'
      }, {
        firstName: 'marry',
        email: 'marry@gmail.com',
        id: 2,
        country: 'uk'
      }, {
        firstName: 'marry',
        email: 'marry@gmail.com',
        id: 122,
        country: 'uk'
      }]
    }));
    setTimeout(function () {
      var rows = (0, _toConsumableArray2.default)((0, _reactDom.findDOMNode)(gridInstance).querySelectorAll('.InovuaReactDataGrid__row'));
      expect(rows.length).to.equal(11);
      var rowIndexes = (0, _toConsumableArray2.default)(Array(11)).map(function (_, i) {
        return i;
      });
      rows = rowIndexes.map(function (i) {
        return findRowAt(gridInstance, i);
      });
      var cellBorders = rows.map(function (row) {
        var cells = findCellsInRow(row);
        return cells.map(function (cell) {
          var style = getComputedStyle((0, _reactDom.findDOMNode)(cell));
          var top = parseInt(style['border-top-width']);
          var right = parseInt(style['border-right-width']);
          var bottom = parseInt(style['border-bottom-width']);
          var left = parseInt(style['border-left-width']);
          return "".concat(top, ";").concat(right, ";").concat(bottom, ";").concat(left);
        });
      });
      var totalColumns = columns.length + 3;
      expect(cellBorders.length).to.equal(11);
      expect(cellBorders[0].length).to.equal(totalColumns);
      var hiddenCell = '0;0;0;0';
      var hiddenFirstCell = '1;0;0;0';
      expect(cellBorders[0]).to.deep.equal(["1;0;0;0", "1;1;0;0", hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell]);
      expect(cellBorders[1]).to.deep.equal([hiddenCell, "1;0;0;1", "1;1;0;0", hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell]);
      expect(cellBorders[2]).to.deep.equal([hiddenCell, "0;0;0;1", "1;0;0;1", "1;1;0;0", hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell]);
      expect(cellBorders[3]).to.deep.equal([hiddenCell, "0;0;0;1", "0;0;0;1", "1;0;0;1", "1;".concat(LOCK_MARGIN_WIDTH, ";0;0"), "1;0;0;0", "1;0;0;0", "1;0;0;".concat(LOCK_MARGIN_WIDTH), "1;1;0;0"]);
      expect(cellBorders[4]).to.deep.equal([hiddenCell, '0;0;0;1', '0;0;0;1', '0;0;0;1', "0;".concat(LOCK_MARGIN_WIDTH, ";0;0"), hiddenCell, '0;0;0;0', "0;0;0;".concat(LOCK_MARGIN_WIDTH), "0;1;0;0"]);
      expect(cellBorders[5]).to.deep.equal(cellBorders[2]);
      expect(cellBorders[6]).to.deep.equal([hiddenCell, "0;0;0;1", "0;0;0;1", "1;0;0;1", "1;".concat(LOCK_MARGIN_WIDTH, ";0;0"), "1;0;0;0", "1;0;0;0", "1;0;0;".concat(LOCK_MARGIN_WIDTH), "1;1;0;0"]);
      expect(cellBorders[7]).to.deep.equal(cellBorders[1]);
      expect(cellBorders[8]).to.deep.equal(cellBorders[2]);
      expect(cellBorders[9]).to.deep.equal(cellBorders[3]);
      expect(cellBorders[10]).to.deep.equal(["0;0;1;0", "0;0;1;1", "0;0;1;1", "0;0;1;1", "0;".concat(LOCK_MARGIN_WIDTH, ";1;0"), "0;0;1;0", "0;0;1;0", "0;0;1;".concat(LOCK_MARGIN_WIDTH), "0;1;1;0"]);
      gridInstance.unmount();
      done();
    }, 100);
  });
});
describe('showCellBorders: horizontal', function () {
  it('should correctly set borders to all cells, when we have groupBy & expandGroupTitle', function (done) {
    var columns = [{
      name: 'country',
      defaultWidth: 100,
      locked: true
    }, {
      name: 'firstName',
      defaultWidth: 100
    }, {
      name: 'lastName',
      defaultWidth: 100,
      locked: true
    }, {
      name: 'lastName1',
      defaultWidth: 100
    }, {
      name: 'email',
      defaultWidth: 100,
      locked: 'end'
    }, {
      name: 'x',
      defaultWidth: 100,
      locked: 'end'
    }];
    var gridInstance = (0, _testUtils.render)(_react.default.createElement(_2.default, {
      columns: columns,
      hideGroupByColumns: false,
      virtualizeColumns: false,
      idProperty: "id",
      groupBy: ['country', 'email', 'firstName'],
      expandGroupTitle: true,
      showCellBorders: 'horizontal',
      dataSource: [{
        lastName: 'a last name',
        firstName: 'john is a very long name so it better be ellipsed in a ',
        email: 'john@gmail.com',
        id: 1,
        country: 'uk'
      }, {
        firstName: 'john2',
        email: 'john@gmail.com',
        id: 11,
        country: 'uk'
      }, {
        firstName: 'john is a very long name so it better be ellipsed in a ',
        email: 'john@gmail.com',
        id: 12,
        country: 'uk'
      }, {
        firstName: 'marry',
        email: 'marry@gmail.com',
        id: 2,
        country: 'uk'
      }, {
        firstName: 'marry',
        email: 'marry@gmail.com',
        id: 122,
        country: 'uk'
      }]
    }));
    setTimeout(function () {
      var rows = (0, _toConsumableArray2.default)((0, _reactDom.findDOMNode)(gridInstance).querySelectorAll('.InovuaReactDataGrid__row'));
      expect(rows.length).to.equal(11);
      var rowIndexes = (0, _toConsumableArray2.default)(Array(11)).map(function (_, i) {
        return i;
      });
      rows = rowIndexes.map(function (i) {
        return findRowAt(gridInstance, i);
      });
      var cellBorders = rows.map(function (row) {
        var cells = findCellsInRow(row);
        return cells.map(function (cell) {
          var style = getComputedStyle((0, _reactDom.findDOMNode)(cell));
          var top = parseInt(style['border-top-width']);
          var right = parseInt(style['border-right-width']);
          var bottom = parseInt(style['border-bottom-width']);
          var left = parseInt(style['border-left-width']);
          return "".concat(top, ";").concat(right, ";").concat(bottom, ";").concat(left);
        });
      });
      var totalColumns = columns.length + 3;
      expect(cellBorders.length).to.equal(11);
      expect(cellBorders[0].length).to.equal(totalColumns);
      var hiddenCell = '0;0;0;0';
      var hiddenFirstCell = '1;0;0;0';
      expect(cellBorders[0]).to.deep.equal(["1;0;0;0", "1;1;0;0", hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell]);
      expect(cellBorders[1]).to.deep.equal([hiddenCell, "1;0;0;1", "1;1;0;0", hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell]);
      expect(cellBorders[2]).to.deep.equal([hiddenCell, "0;0;0;1", "1;0;0;1", "1;1;0;0", hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell]);
      expect(cellBorders[3]).to.deep.equal([hiddenCell, "0;0;0;1", "0;0;0;1", "1;0;1;1", "1;".concat(LOCK_MARGIN_WIDTH, ";1;0"), "1;0;1;0", "1;0;1;0", "1;0;1;".concat(LOCK_MARGIN_WIDTH), "1;1;1;0"]);
      expect(cellBorders[4]).to.deep.equal([hiddenCell, '0;0;0;1', '0;0;0;1', '0;0;0;1', "0;".concat(LOCK_MARGIN_WIDTH, ";0;0"), hiddenCell, '0;0;0;0', "0;0;0;".concat(LOCK_MARGIN_WIDTH), "0;1;0;0"]);
      expect(cellBorders[5]).to.deep.equal(cellBorders[2]);
      expect(cellBorders[6]).to.deep.equal([hiddenCell, "0;0;0;1", "0;0;0;1", "1;0;0;1", "1;".concat(LOCK_MARGIN_WIDTH, ";0;0"), "1;0;0;0", "1;0;0;0", "1;0;0;".concat(LOCK_MARGIN_WIDTH), "1;1;0;0"]);
      expect(cellBorders[7]).to.deep.equal(cellBorders[1]);
      expect(cellBorders[8]).to.deep.equal(cellBorders[2]);
      expect(cellBorders[9]).to.deep.equal(cellBorders[3]);
      expect(cellBorders[10]).to.deep.equal(["0;0;1;0", "0;0;1;1", "0;0;1;1", "0;0;1;1", "0;".concat(LOCK_MARGIN_WIDTH, ";1;0"), "0;0;1;0", "0;0;1;0", "0;0;1;".concat(LOCK_MARGIN_WIDTH), "0;1;1;0"]);
      gridInstance.unmount();
      done();
    }, 100);
  });
});
describe('showCellBorders: vertical', function () {
  it('should correctly set borders to all cells, when we have groupBy & expandGroupTitle', function (done) {
    var columns = [{
      name: 'country',
      defaultWidth: 100,
      locked: true
    }, {
      name: 'firstName',
      defaultWidth: 100
    }, {
      name: 'lastName',
      defaultWidth: 100,
      locked: true
    }, {
      name: 'lastName1',
      defaultWidth: 100
    }, {
      name: 'email',
      defaultWidth: 100,
      locked: 'end'
    }, {
      name: 'x',
      defaultWidth: 100,
      locked: 'end'
    }];
    var gridInstance = (0, _testUtils.render)(_react.default.createElement(_2.default, {
      columns: columns,
      hideGroupByColumns: false,
      virtualizeColumns: false,
      idProperty: "id",
      groupBy: ['country', 'email', 'firstName'],
      expandGroupTitle: true,
      showCellBorders: 'vertical',
      dataSource: [{
        lastName: 'a last name',
        firstName: 'john is a very long name so it better be ellipsed in a ',
        email: 'john@gmail.com',
        id: 1,
        country: 'uk'
      }, {
        firstName: 'john2',
        email: 'john@gmail.com',
        id: 11,
        country: 'uk'
      }, {
        firstName: 'john is a very long name so it better be ellipsed in a ',
        email: 'john@gmail.com',
        id: 12,
        country: 'uk'
      }, {
        firstName: 'marry',
        email: 'marry@gmail.com',
        id: 2,
        country: 'uk'
      }, {
        firstName: 'marry',
        email: 'marry@gmail.com',
        id: 122,
        country: 'uk'
      }]
    }));
    setTimeout(function () {
      var rows = (0, _toConsumableArray2.default)((0, _reactDom.findDOMNode)(gridInstance).querySelectorAll('.InovuaReactDataGrid__row'));
      expect(rows.length).to.equal(11);
      var rowIndexes = (0, _toConsumableArray2.default)(Array(11)).map(function (_, i) {
        return i;
      });
      rows = rowIndexes.map(function (i) {
        return findRowAt(gridInstance, i);
      });
      var cellBorders = rows.map(function (row) {
        var cells = findCellsInRow(row);
        return cells.map(function (cell) {
          var style = getComputedStyle((0, _reactDom.findDOMNode)(cell));
          var top = parseInt(style['border-top-width']);
          var right = parseInt(style['border-right-width']);
          var bottom = parseInt(style['border-bottom-width']);
          var left = parseInt(style['border-left-width']);
          return "".concat(top, ";").concat(right, ";").concat(bottom, ";").concat(left);
        });
      });
      var totalColumns = columns.length + 3;
      expect(cellBorders.length).to.equal(11);
      expect(cellBorders[0].length).to.equal(totalColumns);
      var hiddenCell = '0;0;0;0';
      var hiddenFirstCell = '1;0;0;0';
      expect(cellBorders[0]).to.deep.equal(["1;0;0;0", "1;1;0;0", hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell, hiddenFirstCell]);
      expect(cellBorders[1]).to.deep.equal([hiddenCell, "1;0;0;1", "1;1;0;0", hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell]);
      expect(cellBorders[2]).to.deep.equal([hiddenCell, "0;0;0;1", "1;0;0;1", "1;1;0;0", hiddenCell, hiddenCell, hiddenCell, hiddenCell, hiddenCell]);
      expect(cellBorders[3]).to.deep.equal([hiddenCell, "0;0;0;1", "0;0;0;1", "1;0;0;1", "1;".concat(LOCK_MARGIN_WIDTH, ";0;1"), "1;0;0;0", "1;0;0;1", "1;0;0;".concat(LOCK_MARGIN_WIDTH), "1;1;0;1"]);
      expect(cellBorders[4]).to.deep.equal([hiddenCell, '0;0;0;1', '0;0;0;1', '0;0;0;1', "0;".concat(LOCK_MARGIN_WIDTH, ";0;1"), hiddenCell, '0;0;0;1', "0;0;0;".concat(LOCK_MARGIN_WIDTH), "0;1;0;1"]);
      expect(cellBorders[5]).to.deep.equal(cellBorders[2]);
      expect(cellBorders[6]).to.deep.equal([hiddenCell, "0;0;0;1", "0;0;0;1", "1;0;0;1", "1;".concat(LOCK_MARGIN_WIDTH, ";0;1"), "1;0;0;0", "1;0;0;1", "1;0;0;".concat(LOCK_MARGIN_WIDTH), "1;1;0;1"]);
      expect(cellBorders[7]).to.deep.equal(cellBorders[1]);
      expect(cellBorders[8]).to.deep.equal(cellBorders[2]);
      expect(cellBorders[9]).to.deep.equal(cellBorders[3]);
      expect(cellBorders[10]).to.deep.equal(["0;0;1;0", "0;0;1;1", "0;0;1;1", "0;0;1;1", "0;".concat(LOCK_MARGIN_WIDTH, ";1;1"), "0;0;1;0", "0;0;1;1", "0;0;1;".concat(LOCK_MARGIN_WIDTH), "0;1;1;1"]);
      gridInstance.unmount();
      done();
    }, 100);
  });
});
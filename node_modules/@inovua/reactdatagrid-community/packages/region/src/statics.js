/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _hasOwn = _interopRequireDefault(require("../../../packages/hasOwn"));

var _validate = _interopRequireDefault(require("./validate"));

function _default(REGION) {
  var MAX = Math.max;
  var MIN = Math.min;
  var statics = {
    init: function init() {
      var exportAsNonStatic = {
        getIntersection: true,
        getIntersectionArea: true,
        getIntersectionHeight: true,
        getIntersectionWidth: true,
        getUnion: true
      };
      var thisProto = REGION.prototype;
      var newName;
      var exportHasOwn = (0, _hasOwn.default)(exportAsNonStatic);
      var methodName;

      for (methodName in exportAsNonStatic) {
        if (exportHasOwn(methodName)) {
          newName = exportAsNonStatic[methodName];

          if (typeof newName != 'string') {
            newName = methodName;
          }

          (function (proto, methodName, protoMethodName) {
            proto[methodName] = function (region) {
              if (!REGION[protoMethodName]) {
                console.warn('cannot find method ', protoMethodName, ' on ', REGION);
              }

              return REGION[protoMethodName](this, region);
            };
          })(thisProto, newName, methodName);
        }
      }
    },
    validate: _validate.default,
    getDocRegion: function getDocRegion() {
      return REGION.fromDOM(document.documentElement);
    },
    from: function from(reg) {
      if (reg.__IS_REGION) {
        return reg;
      }

      if (typeof document != 'undefined') {
        if (reg && reg.getBoundingClientRect) {
          return REGION.fromDOM(reg);
        }

        if (reg.type && typeof reg.pageX !== 'undefined' && typeof reg.pageY !== 'undefined') {
          return REGION.fromEvent(reg);
        }
      }

      return REGION(reg);
    },
    fromEvent: function fromEvent(event) {
      return REGION.fromPoint({
        x: event.pageX,
        y: event.pageY
      });
    },
    fromDOM: function fromDOM(dom) {
      var rect = dom.getBoundingClientRect();
      return new REGION({
        top: rect.top,
        left: rect.left,
        bottom: rect.bottom,
        right: rect.right
      });
    },
    getIntersection: function getIntersection(first, second) {
      var area = this.getIntersectionArea(first, second);

      if (area) {
        return new REGION(area);
      }

      return false;
    },
    getIntersectionWidth: function getIntersectionWidth(first, second) {
      var minRight = MIN(first.right, second.right);
      var maxLeft = MAX(first.left, second.left);

      if (maxLeft < minRight) {
        return minRight - maxLeft;
      }

      return 0;
    },
    getIntersectionHeight: function getIntersectionHeight(first, second) {
      var maxTop = MAX(first.top, second.top);
      var minBottom = MIN(first.bottom, second.bottom);

      if (maxTop < minBottom) {
        return minBottom - maxTop;
      }

      return 0;
    },
    getIntersectionArea: function getIntersectionArea(first, second) {
      var maxTop = MAX(first.top, second.top);
      var minRight = MIN(first.right, second.right);
      var minBottom = MIN(first.bottom, second.bottom);
      var maxLeft = MAX(first.left, second.left);

      if (maxTop < minBottom && maxLeft < minRight) {
        return {
          top: maxTop,
          right: minRight,
          bottom: minBottom,
          left: maxLeft,
          width: minRight - maxLeft,
          height: minBottom - maxTop
        };
      }

      return false;
    },
    getUnion: function getUnion(first, second) {
      var top = MIN(first.top, second.top);
      var right = MAX(first.right, second.right);
      var bottom = MAX(first.bottom, second.bottom);
      var left = MIN(first.left, second.left);
      return new REGION(top, right, bottom, left);
    },
    getRegion: function getRegion(reg) {
      return REGION.from(reg);
    },
    fromPoint: function fromPoint(xy) {
      return new REGION({
        top: xy.y,
        bottom: xy.y,
        left: xy.x,
        right: xy.x
      });
    }
  };
  Object.keys(statics).forEach(function (key) {
    REGION[key] = statics[key];
  });
  REGION.init();
}
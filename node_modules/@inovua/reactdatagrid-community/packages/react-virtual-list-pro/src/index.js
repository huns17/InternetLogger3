/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "RowHeightManager", {
  enumerable: true,
  get: function get() {
    return _RowHeightManager.default;
  }
});
exports.default = void 0;
Object.defineProperty(exports, "getScrollbarWidth", {
  enumerable: true,
  get: function get() {
    return _src.getScrollbarWidth;
  }
});
exports.propTypes = void 0;
Object.defineProperty(exports, "shouldComponentUpdate", {
  enumerable: true,
  get: function get() {
    return _shouldComponentUpdate2.default;
  }
});

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _contains = _interopRequireDefault(require("../../../packages/contains"));

var _reactCleanProps = _interopRequireDefault(require("../../../packages/react-clean-props"));

var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));

var _src = _interopRequireWildcard(require("../../../packages/react-virtual-scroll-container-pro/src"));

var _uglified = _interopRequireDefault(require("../../../packages/uglified"));

var _join = _interopRequireDefault(require("../../../packages/join"));

var _binarySearch = _interopRequireDefault(require("../../../packages/binary-search"));

var _RowHeightManager = _interopRequireDefault(require("./RowHeightManager"));

var _getFocusableElements = _interopRequireDefault(require("../../getFocusableElements"));

var _renderRows2 = _interopRequireDefault(require("./renderRows"));

var _shouldComponentUpdate2 = _interopRequireDefault(require("../../../packages/shouldComponentUpdate"));

var _getVisibleRange = _interopRequireDefault(require("./getVisibleRange"));

var _StickyRowsContainer = _interopRequireDefault(require("./StickyRowsContainer"));

var _lodash = _interopRequireDefault(require("lodash.throttle"));

var _getGlobal = require("../../../getGlobal");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var globalObject = (0, _getGlobal.getGlobal)();

var sortAsc = function sortAsc(a, b) {
  return a - b;
};

var emptyFn = function emptyFn() {};

var emptyObject = Object.freeze ? Object.freeze({}) : {};
var ua = globalObject.navigator ? globalObject.navigator.userAgent : '';
var IS_EDGE = ua.indexOf('Edge/') !== -1;
var IS_FF = ua.toLowerCase().indexOf('firefox') > -1;
var BASE_CLASS_NAME = 'inovua-react-virtual-list';
var ResizeObserver = globalObject.ResizeObserver || _resizeObserverPolyfill.default;

var sum = function sum(a, b) {
  return a + b;
};

var unique = function unique(arr) {
  if (Set) {
    return (0, _toConsumableArray2.default)(new Set(arr));
  }

  return Object.keys(arr.reduce(function (acc, item) {
    acc[item] = true;
    return acc;
  }, {}));
};

var InovuaVirtualList = function (_Component) {
  (0, _inherits2.default)(InovuaVirtualList, _Component);

  var _super = _createSuper(InovuaVirtualList);

  function InovuaVirtualList(_props) {
    var _this;

    (0, _classCallCheck2.default)(this, InovuaVirtualList);
    _this = _super.call(this, _props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "size", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "rows", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "rowSpans", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "rowCoveredBy", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "scrollTopPos", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getContainerNode", function () {
      return _this.containerNode;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderScroller", function (props) {
      var offset = _this.getEmptyScrollOffset() || 0;

      if (_this.props.nativeScroll) {
        offset = 0;
      }

      var style = _objectSpread(_objectSpread({}, props.style), {}, {
        overscrollBehavior: _this.props.overscrollBehavior || 'none',
        backfaceVisibility: 'hidden',
        WebkitOverscrollBehavior: _this.props.overscrollBehavior || 'none',
        right: -offset,
        bottom: -offset
      });

      props.style = style;

      if (_this.props.showEmptyRows && _this.props.count < _this.strictVisibleCount && (0, _src.getScrollbarWidth)() && _this.props.nativeScroll) {
        style.overflowY = 'hidden';
      }

      var result;

      if (_this.props.renderScroller) {
        result = _this.props.renderScroller(props);
      }

      if (result === undefined) {
        result = _react.default.createElement("div", _objectSpread({}, props));
      }

      return result;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderScrollerSpacerOnNaturalRowHeight", function (spacerProps) {
      spacerProps.style.height = _this.getScrollHeight();

      if (_this.props.renderScrollerSpacer) {
        _this.props.renderScrollerSpacer(spacerProps);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderView", function (props) {
      var offset = _this.getEmptyScrollOffset() || 0;

      if (_this.props.nativeScroll) {
        offset = 0;
      }

      var minHeight = offset ? "calc(100% - ".concat(offset, "px)") : '100%';
      var maxWidth = offset ? "calc(100% - ".concat(offset, "px)") : '100%';

      if (_this.props.rtl && !_this.props.nativeScroll) {
        maxWidth = '100%';
      }

      var style = _objectSpread(_objectSpread({}, props.style), {}, {
        minHeight: minHeight,
        maxWidth: maxWidth
      });

      if (_this.props.rtl && !(0, _src.getScrollbarWidth)()) {
        style.transform = "translateX(".concat(-offset, "px)");
      }

      var viewProps = _objectSpread(_objectSpread({}, props), {}, {
        style: style,
        'data-name': 'view'
      });

      var result;

      if (_this.props.renderView) {
        result = _this.props.renderView(viewProps);
      }

      if (result === undefined) {
        result = _react.default.createElement("div", _objectSpread({}, viewProps));
      }

      return result;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getTotalRowHeight", function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;
      return props.rowHeightManager ? props.rowHeightManager.getTotalSize(props.count) : props.count * props.rowHeight;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getScrollHeight", function () {
      var SCROLLBAR_WIDTH = (0, _src.getScrollbarWidth)();
      var offset = SCROLLBAR_WIDTH ? 0 : _this.getEmptyScrollOffset() || 0;

      if (_this.props.nativeScroll) {
        offset = 0;
      }

      var height = _this.getTotalRowHeight();

      return height + offset;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getScrollSize", function (node) {
      var res = {
        width: node.scrollWidth,
        height: _this.getScrollHeight()
      };
      return res;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getClientSize", function (n) {
      var node = n.firstChild;
      var SCROLLBAR_WIDTH = (0, _src.getScrollbarWidth)();
      var offset = SCROLLBAR_WIDTH ? 0 : _this.getEmptyScrollOffset() || 0;

      if (_this.props.nativeScroll) {
        offset = 0;
      }

      return {
        width: node.clientWidth + offset,
        height: node.clientHeight + offset
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "initSizes", function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;
      var minRowHeight = props.minRowHeight,
          rowHeightManager = props.rowHeightManager;

      if (rowHeightManager) {
        return;
      }

      var count = _this.getMaxRenderCount(props);

      var rowOffsets = [];
      var totalHeight = 0;
      var rowHeights = (0, _toConsumableArray2.default)(Array(count)).map(function () {
        rowOffsets.push(totalHeight);
        totalHeight += minRowHeight;
        return minRowHeight;
      });
      rowOffsets[count] = totalHeight;
      _this.rowOffsets = rowOffsets;
      _this.rowHeights = rowHeights;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setHeightForRows", function (indexes, heights) {
      if (!indexes.length || !heights.length) {
        return 0;
      }

      if (_this.props.showWarnings) {
        if (indexes.length != heights.length) {
          console.warn('setHeightForRows signature mismatch!!!');
          return 0;
        }

        indexes.forEach(function (_, i) {
          if (i > 0) {
            var _diff = indexes[i] - indexes[i - 1];

            if (_diff !== 1) {
              console.warn('setHeightForRows should be called with successive indexes!', indexes);
            }
          }
        });
      }

      var _assertThisInitialize = (0, _assertThisInitialized2.default)(_this),
          rowHeights = _assertThisInitialize.rowHeights,
          rowOffsets = _assertThisInitialize.rowOffsets;

      var count = _this.props.count;
      var diff = 0;
      indexes.forEach(function (index, i) {
        var height = heights[i] || 0;
        var oldHeight = rowHeights[index] || 0;
        rowHeights[index] = height;
        rowOffsets[index] = diff + (rowOffsets[index] || 0);
        diff += height - oldHeight;
      });

      for (var i = indexes[indexes.length - 1] + 1; i <= count; i++) {
        rowOffsets[i] = diff + (rowOffsets[i] || 0);
      }

      return diff;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderSizer", function (scrollHeight) {
      var _this$props = _this.props,
          renderSizer = _this$props.renderSizer,
          minRowWidth = _this$props.minRowWidth,
          emptyScrollOffset = _this$props.emptyScrollOffset,
          rowHeightManager = _this$props.rowHeightManager,
          showEmptyRows = _this$props.showEmptyRows;
      var SCROLLBAR_WIDTH = (0, _src.getScrollbarWidth)();
      var offset = SCROLLBAR_WIDTH ? 0 : emptyScrollOffset || 0;
      var minHeight = scrollHeight + offset;

      if (showEmptyRows) {
        minHeight = Math.max(minHeight, _this.strictVisibleCount * rowHeightManager.getDefaultRowHeight());
      }

      var style = {
        minHeight: isNaN(minHeight) ? '' : minHeight,
        minWidth: minRowWidth ? minRowWidth + offset : 0
      };
      var result;

      if (renderSizer) {
        result = renderSizer({
          style: style
        }, scrollHeight);
      }

      if (result === undefined) {
        result = _react.default.createElement("div", {
          key: "sizer",
          "data-name": "sizer",
          style: style
        });
      }

      return result;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderRowContainer", function () {
      var props = {
        key: 'rowContainer',
        className: "".concat(BASE_CLASS_NAME, "__row-container"),
        ref: _this.refContainerNode,
        children: _this.renderRows()
      };
      var result;

      if (_this.props.renderRowContainer) {
        result = _this.props.renderRowContainer(props);
      }

      if (result === undefined) {
        result = _react.default.createElement("div", _objectSpread({}, props));
      }

      return result;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onViewResize", function () {
      requestAnimationFrame(function () {
        _this.rafSync();
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onScrollbarsChange", function (_ref) {
      var vertical = _ref.vertical,
          horizontal = _ref.horizontal;

      if (!vertical && _this.scrollTopPos || !horizontal && _this.scrollLeftPos) {
        _this.applyScrollStyle({
          scrollTop: !vertical ? 0 : _this.scrollTopPos,
          scrollLeft: !horizontal ? 0 : _this.scrollLeftPos
        });
      }

      if (_this.props.onScrollbarsChange) {
        _this.props.onScrollbarsChange({
          vertical: vertical,
          horizontal: horizontal
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onRowUnmount", function (row) {
      if (!_this.rows) {
        return;
      }

      var currentRowIndex = row.getIndex();
      var isFound = _this.mapping[currentRowIndex];

      if (!isFound) {
        return;
      }

      delete _this.mapping[currentRowIndex];

      var index = _this.rows.indexOf(row);

      if (index != -1) {
        _this.rows.splice(index, 1);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "rowRef", function (r) {
      if (!r) {
        return;
      }

      _this.mapping[r.props.index] = r;
      _this.rows[r.props.index] = r;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onScrollStart", function () {
      _this.scrolling = true;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (_this.props.scrollOneDirectionOnly) {
        var scrollPos = args[0],
            prevScrollPos = args[1];
        var absTop = Math.abs(scrollPos.scrollTop - prevScrollPos.scrollTop);
        var absLeft = Math.abs(scrollPos.scrollLeft - prevScrollPos.scrollLeft);

        var scrollerNode = _this.getScrollerNode();

        if (absTop != absLeft) {
          _this.disableScrollPropName = absTop > absLeft ? 'overflowX' : 'overflowY';
          _this.disableScrollOtherPropName = absTop > absLeft ? 'overflowY' : 'overflowX';
          _this.disableScrollPropValue = scrollerNode.style[_this.disableScrollPropName];
          scrollerNode.style[_this.disableScrollOtherPropName] = 'scroll';
          scrollerNode.style[_this.disableScrollPropName] = 'hidden';
        }
      }

      if (_this.props.onScrollStart) {
        var _this$props2;

        (_this$props2 = _this.props).onScrollStart.apply(_this$props2, args);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getScrollerNode", function () {
      return _this.scrollContainer.scrollerNode;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onScrollStop", function () {
      _this.scrolling = false;

      if (_this.props.scrollOneDirectionOnly) {
        var scrollerNode = _this.getScrollerNode();

        scrollerNode.style[_this.disableScrollPropName] = _this.disableScrollPropValue;
        scrollerNode.style.overflow = 'scroll';
      }

      if (_this.props.onScrollStop) {
        var _this$props3;

        (_this$props3 = _this.props).onScrollStop.apply(_this$props3, arguments);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getRows", function () {
      var rows = [];

      _this.forEachRow(function (row) {
        if (row) {
          rows.push(row);
        }
      });

      return rows;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "forEachRow", function (fn) {
      var onlyVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var rows = _this.rows;

      var visibleCount = _this.getVisibleCount();

      var i = -1;

      for (var initialIndex in rows) {
        if (rows.hasOwnProperty(initialIndex) && (!onlyVisible || onlyVisible && initialIndex < visibleCount)) {
          i++;
          fn(rows[initialIndex], i);
        }
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sortRows", function (rows) {
      return rows.slice().sort(function (row1, row2) {
        return row1.getIndex() - row2.getIndex();
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getRowAt", function (index) {
      var row = _this.mapping[index];

      if (row && row.getIndex() != index) {
        row = null;
      }

      return row;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getVisibleCount", function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;
      var virtualized = props.virtualized,
          enableRowSpan = props.enableRowSpan,
          extraRowsProps = props.extraRows;
      var extraRows = enableRowSpan ? 2 : extraRowsProps || 0;

      if (_this.visibleCount === undefined) {
        return 0;
      }

      if (!virtualized) {
        return (props.showEmptyRows ? Math.max(_this.visibleCount || 0, props.count || 0) : props.count) + extraRows;
      }

      return (props.showEmptyRows ? _this.visibleCount || props.count : Math.min(_this.visibleCount || props.count, props.count)) + extraRows;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setRowIndex", function (row, index, callback) {
      var existingRow = _this.mapping[index];

      if (existingRow) {
        existingRow.setIndex(index, callback);

        if (existingRow !== row) {
          row.setVisible(false);
        }

        return;
      }

      var oldIndex = row.getIndex();
      row.setIndex(index, callback);
      delete _this.mapping[oldIndex];
      _this.mapping[index] = row;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getSortedRows", function () {
      var rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.getRows();
      return _this.sortRows(rows);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onRowsUpdated", function (newIndexes, range, updateScroll) {
      newIndexes.sort(function (i1, i2) {
        return i1 - i2;
      });
      var start = newIndexes[0];
      var end = _this.props.showEmptyRows ? newIndexes[newIndexes.length - 1] : Math.min(newIndexes[newIndexes.length - 1], _this.props.count - 1);
      var minRowHeight = _this.props.minRowHeight;
      var rowIndexes = [];
      var rowHeights = [];
      var rows = [];

      for (var row, rowHeight, i = start; i <= end; i++) {
        row = _this.mapping[i];
        rowHeight = row ? row.getInfo().height : minRowHeight;

        if (row) {
          rows.push(row);
        }

        rowIndexes.push(i);
        rowHeights.push(rowHeight);
      }

      var newToTopHeight = 0;
      var oldTop;

      if (_this.oldRowIndexes) {
        oldTop = _this.oldRowIndexes[0];
        rowIndexes.forEach(function (rowIndex, i) {
          var diff;

          if (rowIndex < oldTop) {
            diff = rowHeights[i] - _this.rowHeights[rowIndex];
            newToTopHeight += diff;
          }
        });
      }

      if (rowIndexes.length) {
        _this.setHeightForRows(rowIndexes, rowHeights);
      }

      rows.forEach(function (row) {
        var index = row.getIndex();
        var offset = _this.rowOffsets[index];
        row.setOffset(offset);
      });
      _this.oldRowIndexes = rowIndexes;
      var newScrollTop;

      if (newToTopHeight) {
        newScrollTop = _this.scrollTopPos + newToTopHeight;
        updateScroll(newScrollTop);
        _this.forceScrollTop = newScrollTop;
        _this.scrollTop = newScrollTop;
      } else {
        updateScroll();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getVisibleRange", function (args) {
      return (0, _getVisibleRange.default)(args);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "applyScrollStyle", function (_ref2, domNode) {
      var scrollTop = _ref2.scrollTop,
          scrollLeft = _ref2.scrollLeft,
          force = _ref2.force,
          reorder = _ref2.reorder;

      if (scrollTop < 0) {
        scrollTop = 0;
      }

      if (!_this.props.rtl) {
        if (scrollLeft < 0) {
          scrollLeft = 0;
        }
      } else {
        if (scrollLeft > 0) {
          scrollLeft = 0;
        }
      }

      if (_this.forceScrollTop !== undefined) {
        scrollTop = _this.forceScrollTop;
        _this.forceScrollTop = undefined;
        return;
      }

      if (_this.props.applyScrollLeft && scrollLeft !== undefined) {
        scrollLeft = 0;

        _this.props.applyScrollLeft(scrollLeft, domNode);
      }

      if (scrollTop === undefined) {
        scrollTop = _this.prevScrollTopPos;
      }

      if (scrollLeft === undefined) {
        scrollLeft = _this.prevScrollLeftPos;
      }

      _this.scrollTopPos = scrollTop;
      _this.scrollLeftPos = scrollLeft;
      var _this$props4 = _this.props,
          count = _this$props4.count,
          useTransformPosition = _this$props4.useTransformPosition,
          rowHeightManager = _this$props4.rowHeightManager,
          naturalRowHeight = _this$props4.naturalRowHeight,
          virtualized = _this$props4.virtualized,
          showEmptyRows = _this$props4.showEmptyRows;

      var range = _this.getVisibleRange({
        scrollTop: scrollTop,
        size: _this.size,
        count: count,
        naturalRowHeight: naturalRowHeight,
        rowHeightManager: rowHeightManager,
        showEmptyRows: showEmptyRows
      });

      var startRowIndex = range.start;
      var prevStartRowIndex = _this.prevStartRowIndex;
      _this.prevScrollTopPos = scrollTop;
      _this.prevScrollLeftPos = scrollLeft;
      _this.prevStartRowIndex = startRowIndex;

      _this.updateStickyRows(scrollTop, undefined, {
        force: false
      });

      var updateScroll = function updateScroll() {
        var top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : scrollTop;
        var parentNodeStyle = _this.containerNode.parentNode.style;

        _this.containerNode.parentNode.classList.add("".concat(BASE_CLASS_NAME, "__view-container"));

        var scrollLeftTranslateValue = -scrollLeft;

        if (useTransformPosition) {
          parentNodeStyle.transform = "translate3d(".concat(scrollLeftTranslateValue, "px, ").concat(-top, "px, 0px)");
        } else {
          parentNodeStyle.left = "".concat(scrollLeftTranslateValue, "px");
          parentNodeStyle.top = "".concat(-top, "px");
        }
      };

      if (rowHeightManager == null) {
        force = true;
      }

      if (startRowIndex == prevStartRowIndex && !force || !virtualized) {
        updateScroll();
        return;
      }

      updateScroll();

      _this.updateRows(range, reorder, emptyFn);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getScrollingElement", function () {
      return _this.scrollContainer;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "smoothScrollTo", function () {
      var _this$scrollContainer;

      (_this$scrollContainer = _this.scrollContainer).smoothScrollTo.apply(_this$scrollContainer, arguments);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "componentDidMount", function () {
      _this.mounted = true;

      _this.setupRowHeightManager(_this.props.rowHeightManager);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "fixEdgeScrollPosition", function () {
      if (!(IS_EDGE || IS_FF)) {
        return;
      }

      var maxTop = _this.getTotalRowHeight() - (_this.scrollContainer.viewNode ? _this.scrollContainer.viewNode.offsetHeight : 0);

      if (_this.scrollTop > maxTop) {
        globalObject.requestAnimationFrame(function () {
          if (_this.unmounted) {
            return;
          }

          _this.scrollTop = maxTop;
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setupRowHeightManager", function (rowHeightManager) {
      if (rowHeightManager) {
        rowHeightManager.on('index', _this.onIndex);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onIndex", function () {
      _this.updateVisibleCount(_this.size.height);

      _this.forceUpdate(function () {
        if (_this.unmounted) {
          return;
        }

        _this.refreshLayout({
          reorder: false,
          force: true
        });

        _this.cleanupRows();

        _this.fixEdgeScrollPosition();

        _this.rows.forEach(function (row) {
          row.setIndex(row.getIndex(), undefined, undefined, true);
        });
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "refreshLayout", function (config) {
      var defaults = {
        force: true,
        reorder: true
      };

      _this.adjustHeights();

      var options = config ? _objectSpread(_objectSpread({}, defaults), config) : defaults;

      _this.applyScrollStyle(options);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getOverlappingHeight", function () {
      if (_this.scrollContainer && _this.scrollContainer.getBeforeAndAfterHeight) {
        return _this.scrollContainer.getBeforeAndAfterHeight();
      }

      return 0;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "updateVisibleCount", function (height, props) {
      props = props || _this.props;
      var _props2 = props,
          rowHeightManager = _props2.rowHeightManager,
          minRowHeight = _props2.minRowHeight,
          showEmptyRows = _props2.showEmptyRows;
      var strictVisibleCount = rowHeightManager ? Math.ceil(height / rowHeightManager.getMinHeight()) : Math.ceil(height / (minRowHeight || 1));
      _this.strictVisibleCount = strictVisibleCount;
      _this.visibleCount = rowHeightManager ? strictVisibleCount + 1 : strictVisibleCount + 2;
      var maxCount = props.count;

      if (_this.visibleCount > maxCount && !showEmptyRows) {
        _this.visibleCount = maxCount;
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getGapsFor", function (startRowIndex, endRowIndex, sortedRows) {
      var visibleRowPositions = {};
      var enableRowSpan = _this.props.enableRowSpan;

      var rows = sortedRows || _this.getSortedRows();

      rows.forEach(function (row) {
        if (row.isVisible()) {
          visibleRowPositions[row.getIndex()] = true;
        }
      });
      var gaps = [];

      if (enableRowSpan && _this.rowCoveredBy[startRowIndex] != null) {
        startRowIndex = _this.rowCoveredBy[startRowIndex];
      }

      var alreadyVisible;
      var coveredBy;

      for (; startRowIndex <= endRowIndex; startRowIndex++) {
        alreadyVisible = visibleRowPositions[startRowIndex];

        if (enableRowSpan && !alreadyVisible) {
          coveredBy = _this.rowCoveredBy[startRowIndex];

          if (coveredBy != null) {
            alreadyVisible = _this.props.recycleCoveredRows;
          }
        }

        if (!alreadyVisible) {
          gaps.push(startRowIndex);
        }
      }

      return gaps;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getCleanupRows", function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;
      var indexes = [];
      var length = _this.rows.length;

      var visibleCount = _this.getVisibleCount(props);

      for (var i = visibleCount; i < length; i++) {
        indexes.push(i);
      }

      return indexes;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "cleanupRows", function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;

      _this.getCleanupRows(props).forEach(function (i) {
        var row = _this.rows[i];

        if (row) {
          delete _this.mapping[row.getIndex()];
          delete _this.rows[i];
        }
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onResize", function () {
      var node = _this.getDOMNode();

      if (!node) {
        return;
      }

      var size = _this.props.measureSize ? _this.props.measureSize(node) : {
        width: node.clientWidth,
        height: node.clientHeight
      };
      size.height -= _this.getOverlappingHeight();
      _this.size = size;

      if (_this.props.scrollProps && typeof _this.props.scrollProps.onResize == 'function') {
        _this.props.scrollProps.onResize(size);
      }

      _this.updateVisibleCount(size.height);

      if (_this.props.virtualized) {
        if (_this.props.showEmptyRows) {
          _this.initSizes();
        }

        _this.forceUpdate(function () {
          if (_this.unmounted) {
            return;
          }

          _this.refreshLayout({
            reorder: false,
            force: true
          });

          _this.cleanupRows();
        });
      }

      if (_this.props.onResize) {
        _this.props.onResize(size);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setRowRowSpan", function (rowIndex, rowSpan) {
      if (rowSpan === 1) {
        return;
      }

      _this.rowSpans[rowIndex] = rowSpan;
      var current = rowIndex + 1;
      var last = rowIndex + rowSpan - 1;

      for (; current <= last; current++) {
        _this.rowCoveredBy[current] = rowIndex;
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onRowKeyDown", function (index, event) {
      if (event.key !== 'Tab') {
        return;
      }

      if (_this.props.handleRowKeyDown) {
        _this.props.handleRowKeyDown(index, event);

        return;
      }

      var activeElement = globalObject.document.activeElement;

      var theRow = _this.getRowAt(index);

      var rowNode = theRow.getDOMNode ? theRow.getDOMNode() : theRow.node;

      if (!activeElement || !(0, _contains.default)(rowNode, activeElement)) {
        return;
      }

      var dir = event.shiftKey ? -1 : 1;
      var nextIndex = index + dir;

      var maxCount = _this.getMaxRenderCount();

      if (nextIndex < 0 || nextIndex >= maxCount) {
        return;
      }

      var thisElements = _this.props.getRowFocusableElements ? _this.props.getRowFocusableElements(index, rowNode) : (0, _getFocusableElements.default)(rowNode);

      if (thisElements && thisElements.length) {
        var limit = dir === -1 ? 0 : thisElements.length - 1;

        if (thisElements[limit] !== activeElement) {
          return;
        }
      }

      if (typeof _this.props.shouldPreventDefaultTabKeyOnRow !== 'function' || _this.props.shouldPreventDefaultTabKeyOnRow(index, event) !== false) {
        event.preventDefault();
      }

      _this.focusRow(nextIndex, dir);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getMaxRenderCount", function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;

      var visibleCount = _this.getVisibleCount(props);

      var maxCount = props.showEmptyRows ? Math.max(visibleCount || 0, props.count) : Math.max(props.count || 0, 0);
      return maxCount;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "focusRow", function (index, dir, callback) {
      if (index >= _this.getMaxRenderCount() || index < 0) {
        return;
      }

      _this.scrollToIndex(index, {
        direction: dir == 1 ? 'bottom' : 'top'
      }, function () {
        var nextRow = _this.getRowAt(index);

        var nextRowNode = nextRow.getDOMNode ? nextRow.getDOMNode() : nextRow.node;
        var elements = _this.props.getRowFocusableElements ? _this.props.getRowFocusableElements(index, nextRowNode) : (0, _getFocusableElements.default)(nextRowNode);

        if (elements.length) {
          var focusIndex = dir === -1 ? elements.length - 1 : 0;
          elements[focusIndex].focus();
        }

        if (typeof callback == 'function') {
          callback();
        }
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "isRowRendered", function (index) {
      return !!_this.getRowAt(index);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getStickyRowsArray", function () {
      var stickyRows = _this.props.stickyRows;
      var scaleMap = {};
      var rows = Object.keys(stickyRows).map(function (key, i) {
        var scale = +(stickyRows[key] || 1);
        var row = {
          index: +key,
          scale: scale,
          indexInAllRows: i
        };
        scaleMap[scale] = scaleMap[scale] || [];
        scaleMap[scale].push(row);
        return row;
      }).sort(function (a, b) {
        return sortAsc(a.index, b.index);
      });
      var scales = unique(rows.map(function (r) {
        return r.scale;
      })).sort(sortAsc);
      var result = {
        rows: rows,
        scales: scales,
        rowsPerScales: scales.map(function (scale) {
          return scaleMap[scale];
        })
      };
      return result;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "currentStickyRows", []);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "updateStickyRows", function () {
      var scrollTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.scrollTop;
      var firstVisibleRowIndex = arguments.length > 1 ? arguments[1] : undefined;

      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        force: true
      },
          force = _ref3.force;

      if (!_this.props.stickyRows) {
        return;
      }

      var _this$getStickyRowsAr = _this.getStickyRowsArray(),
          rowsPerScales = _this$getStickyRowsAr.rowsPerScales,
          allRows = _this$getStickyRowsAr.rows;

      if (firstVisibleRowIndex === undefined) {
        firstVisibleRowIndex = _this.getFirstVisibleRowIndexForSticky(scrollTop);
      }

      firstVisibleRowIndex = firstVisibleRowIndex || 0;
      var enteringRows = [];

      var comparator = function comparator(_ref4, b) {
        var index = _ref4.index;
        return sortAsc(index, b);
      };

      var initialIndex = -1;
      var currentStickyRows = [];
      var currentStickyRowsMap = [];
      var maxStickyRowIndex = -1;
      var firstFreeVisibleRowIndex = firstVisibleRowIndex;
      rowsPerScales.forEach(function (rows) {
        if (!rows.length) {
          return;
        }

        var foundIndex = (0, _binarySearch.default)(rows, firstFreeVisibleRowIndex, comparator);
        var computedFoundIndex = foundIndex;
        var stickyRow;
        var stickyRowIndex;

        if (foundIndex < 0) {
          computedFoundIndex = ~foundIndex - 1;
        }

        stickyRow = rows[computedFoundIndex];

        if (stickyRow) {
          stickyRowIndex = stickyRow.index;

          if (stickyRowIndex > initialIndex) {
            firstFreeVisibleRowIndex++;
            currentStickyRows.push(stickyRow);
            currentStickyRowsMap[stickyRowIndex] = true;
            initialIndex = stickyRowIndex;
            maxStickyRowIndex = Math.max(maxStickyRowIndex, stickyRowIndex);
          }

          var nextRow = allRows[stickyRow.indexInAllRows + 1];

          if (nextRow && nextRow.index <= firstFreeVisibleRowIndex) {
            enteringRows.push(nextRow);
          }
        }
      });
      enteringRows = enteringRows.filter(function (row) {
        return !currentStickyRowsMap[row.index] && row.index > maxStickyRowIndex;
      });
      var enteringRow = enteringRows[0];

      if (JSON.stringify(_this.currentStickyRows) === JSON.stringify(currentStickyRows) && !force) {
        _this.stickyRowsContainer.setEnteringRow({
          enteringRow: enteringRow,
          scrollTop: scrollTop
        });

        return;
      }

      _this.setStickyRows(currentStickyRows, scrollTop, enteringRow);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setStickyRows", function () {
      var currentStickyRows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.currentStickyRows;
      var scrollTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.scrollTop;
      var enteringRow = arguments.length > 2 ? arguments[2] : undefined;
      _this.currentStickyRows = currentStickyRows;
      var rowElements = currentStickyRows.map(function (row) {
        return _this.renderStickyRow(row.index);
      });

      _this.stickyRowsContainer.setStickyRows(rowElements.length ? rowElements : null, currentStickyRows, {
        enteringRow: enteringRow,
        scrollTop: scrollTop
      });

      _this.currentStickyRows = currentStickyRows;

      if (_this.props.onStickyRowUpdate) {
        _this.props.onStickyRowUpdate();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderStickyRow", function (index) {
      var _this$props5 = _this.props,
          rowHeight = _this$props5.rowHeight,
          renderRow = _this$props5.renderRow,
          count = _this$props5.count,
          pureRows = _this$props5.pureRows,
          rowHeightManager = _this$props5.rowHeightManager,
          showEmptyRows = _this$props5.showEmptyRows,
          virtualized = _this$props5.virtualized,
          rowContain = _this$props5.rowContain,
          naturalRowHeight = _this$props5.naturalRowHeight,
          useTransformRowPosition = _this$props5.useTransformRowPosition;
      return (0, _renderRows2.default)({
        pure: pureRows,
        renderRow: renderRow,
        rowHeightManager: rowHeightManager,
        rowHeight: rowHeight,
        rowContain: rowContain,
        count: count,
        from: index,
        to: index + 1,
        naturalRowHeight: naturalRowHeight,
        sticky: true,
        useTransformPosition: useTransformRowPosition,
        virtualized: false
      })[0];
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "isRowVisible", function (index) {
      if (!_this.isRowRendered(index)) {
        return false;
      }

      var rowHeightManager = _this.props.rowHeightManager;
      var top = _this.scrollTop;
      var bottom = top + _this.size.height;
      var rowTop;
      var rowBottom;

      if (rowHeightManager) {
        rowTop = rowHeightManager.getRowOffset(index);
        rowBottom = rowTop + rowHeightManager.getRowHeight(index);
      } else {
        var row = _this.getRowAt(index);

        var info = row.getInfo();
        rowTop = info.offset;
        rowBottom = rowTop + info.height;
      }

      return top <= rowTop && rowBottom <= bottom;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getRowVisibilityInfo", function (index, offset) {
      var rendered = _this.isRowRendered(index);

      var _this$props6 = _this.props,
          rowHeightManager = _this$props6.rowHeightManager,
          rowHeight = _this$props6.rowHeight,
          minRowHeight = _this$props6.minRowHeight;
      var scrollTop = _this.scrollTop;
      var top = scrollTop + offset;
      var bottom = scrollTop + _this.size.height - offset;
      var rowTop;
      var rowBottom;

      if (rowHeightManager) {
        rowTop = rowHeightManager.getRowOffset(index);
        rowBottom = rowTop + rowHeightManager.getRowHeight(index);
      } else {
        var row = _this.getRowAt(index);

        if (row) {
          var info = row.getInfo();
          rowTop = info.offset;
          rowBottom = rowTop + info.height;
        } else {
          var indexes = _this.getRenderedIndexes();

          var firstRenderedIndex = indexes[0];
          var lastRenderedIndex = indexes[indexes.length - 1];

          if (index < firstRenderedIndex) {
            rowTop = _this.rowOffsets[firstRenderedIndex] - (firstRenderedIndex - index) * minRowHeight;
          } else if (index > lastRenderedIndex) {
            rowTop = _this.rowOffsets[lastRenderedIndex] + _this.rowHeights[lastRenderedIndex] + (index - lastRenderedIndex) * minRowHeight;
          } else {
            rowTop = _this.rowOffsets[index];
          }

          rowBottom = rowTop + _this.rowHeights[index];
        }
      }

      var visible = top <= rowTop && rowBottom <= bottom;
      return {
        rendered: rendered,
        visible: visible,
        top: rowTop,
        bottom: rowBottom,
        topDiff: rowTop - top,
        bottomDiff: bottom - rowBottom
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getRenderedIndexes", function () {
      return Object.keys(_this.mapping).map(function (k) {
        return k * 1;
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onRowFocus", function (index, event) {});
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "rafSync", function () {
      if (_this.scrollContainer) {
        _this.scrollContainer.rafSync();
      }

      _this.adjustHeights();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "adjustHeights", function () {
      if (Array.isArray(_this.rows)) {
        _this.rows.forEach(function (r) {
          return r.updateRowHeight();
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "checkHeights", function () {
      var rows = _this.getSortedRows();

      var result = true;
      rows.forEach(function (row) {
        if (result !== true) {
          return;
        }

        var index = row.getIndex();

        if (row.node.offsetHeight != _this.rowHeights[index]) {
          console.warn("row height mismatch at ".concat(index, "!"));
          result = index;
        }
      });

      if (result === true) {
        _this.rowHeights.reduce(function (acc, height, index) {
          if (_this.rowOffsets[index] !== acc && result === true && index < _this.props.count) {
            console.warn("row offset mismatch at ".concat(index, "!"));
            result = index;
          }

          return acc + height;
        }, 0);
      }

      return result;
    });

    _this.initSizes(_props);

    _this.visibleCount = undefined;
    _this.size = {
      height: 0,
      width: 0
    };
    _this.scrollTopPos = 0;
    _this.scrollLeftPos = 0;
    _this.prevScrollLeftPos = 0;
    _this.prevScrollTopPos = 0;
    _this.mapping = {};
    _this.rowSpans = {};
    _this.rowCoveredBy = {};
    _this.rows = [];

    _this.refScrollContainer = function (c) {
      _this.scrollContainer = c;
    };

    _this.refStickyContainer = function (c) {
      _this.stickyRowsContainer = c;
    };

    _this.refContainerNode = function (domNode) {
      _this.containerNode = domNode;
    };

    _this.updateRows = (0, _lodash.default)(_this.updateRows, 16);
    return _this;
  }

  (0, _createClass2.default)(InovuaVirtualList, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      return (0, _shouldComponentUpdate2.default)(this, nextProps, nextState);
    }
  }, {
    key: "renderStickyRowsContainer",
    value: function renderStickyRowsContainer() {
      return this.props.stickyRows ? _react.default.createElement(_StickyRowsContainer.default, {
        rtl: this.props.rtl,
        key: "stickyrowscontainer",
        stickyOffset: this.props.stickyOffset,
        handle: this.refStickyContainer,
        rowHeightManager: this.props.rowHeightManager
      }) : null;
    }
  }, {
    key: "render",
    value: function render() {
      var props = this.props;
      var naturalRowHeight = props.naturalRowHeight,
          scrollProps = props.scrollProps,
          theme = props.theme,
          minRowHeight = props.minRowHeight,
          rowHeightManager = props.rowHeightManager,
          count = props.count;

      var style = _objectSpread({
        position: 'relative'
      }, this.props.style);

      var className = (0, _join.default)(props.className, BASE_CLASS_NAME, theme && "".concat(BASE_CLASS_NAME, "--theme-").concat(theme), "".concat(BASE_CLASS_NAME, "--virtual-scroll"));
      var scrollHeight = rowHeightManager ? rowHeightManager.getTotalSize(count) : this.scrollHeight || minRowHeight * count;
      var rowContainer = this.renderRowContainer();
      var sizer = this.renderSizer(scrollHeight);
      var stickyRowsContainer = this.renderStickyRowsContainer();
      var children;

      if ((0, _src.hasSticky)()) {
        children = _react.default.Fragment ? _react.default.createElement(_react.default.Fragment, null, rowContainer, sizer) : [rowContainer, sizer];
      } else {
        children = _react.default.createElement("div", null, rowContainer, sizer);
      }

      var Factory = this.props.nativeScroll ? _src.NativeScrollContainer : _src.default;
      var renderScrollerSpacer = this.props.renderScrollerSpacer;

      if (naturalRowHeight) {
        renderScrollerSpacer = this.renderScrollerSpacerOnNaturalRowHeight;
      }

      return _react.default.createElement(Factory, _objectSpread(_objectSpread(_objectSpread({
        contain: this.props.contain,
        ResizeObserver: this.props.ResizeObserver !== undefined ? this.props.ResizeObserver : ResizeObserver,
        extraChildren: stickyRowsContainer,
        useTransformToScroll: this.props.useTransformPosition
      }, (0, _reactCleanProps.default)(props, InovuaVirtualList.propTypes)), scrollProps), {}, {
        rtl: this.props.rtl,
        nativeScroll: this.props.nativeScroll,
        ref: this.refScrollContainer,
        onScrollbarsChange: this.onScrollbarsChange,
        style: style,
        theme: theme,
        className: className,
        onScrollStart: this.onScrollStart,
        onScrollStop: this.onScrollStop,
        applyScrollStyle: this.applyScrollStyle,
        onResize: this.onResize,
        onViewResize: this.onViewResize,
        renderScroller: this.renderScroller,
        renderScrollerSpacer: renderScrollerSpacer,
        renderView: this.renderView,
        getClientSize: this.getClientSize,
        getScrollSize: this.getScrollSize,
        children: children
      }));
    }
  }, {
    key: "updateRows",
    value: function updateRows(range, reorder, updateScroll) {
      var _this2 = this;

      var rowHeightManager = this.props.rowHeightManager;
      var startRowIndex = range.start;
      var endRowIndex = range.end;

      if (this.props.onRenderRangeChange) {
        this.props.onRenderRangeChange(startRowIndex, endRowIndex);
      }

      var rows = this.getSortedRows();
      var gaps = this.getGapsFor(startRowIndex, endRowIndex, rows);
      var newIndexes = [];
      var _this$props7 = this.props,
          recycleCoveredRows = _this$props7.recycleCoveredRows,
          enableRowSpan = _this$props7.enableRowSpan;
      var visited = {};
      rows.forEach(function (row, i) {
        var rowIndex = row.getIndex();

        if (reorder) {
          var newRowIndex = startRowIndex + i;

          _this2.setRowIndex(row, newRowIndex);

          if (rowHeightManager == null) {
            newIndexes.push(newRowIndex);
          }

          return;
        }

        var extraRows = enableRowSpan ? row.getRowSpan() - 1 : 0;
        var outOfView = rowIndex + extraRows < startRowIndex || rowIndex > endRowIndex || visited[rowIndex] || enableRowSpan && recycleCoveredRows && _this2.rowCoveredBy[rowIndex] !== undefined;
        visited[rowIndex] = true;

        if (rowHeightManager == null) {
          if (outOfView) {
            if (gaps.length) {
              var newIndex = gaps.pop();
              newIndexes.push(newIndex);

              _this2.setRowIndex(row, newIndex);
            } else {
              row.setVisible(false);
            }
          } else {
            row.setVisible(true);
            newIndexes.push(row.getIndex());
          }

          return;
        }

        if (outOfView && gaps.length) {
          var _newIndex = gaps.pop();

          _this2.setRowIndex(row, _newIndex);
        }
      });

      if (newIndexes.length && rowHeightManager == null) {
        if (this.updateRafHandle) {
          globalObject.cancelAnimationFrame(this.updateRafHandle);
        }

        this.updateRafHandle = globalObject.requestAnimationFrame(function () {
          _this2.updateRafHandle = null;

          _this2.onRowsUpdated(newIndexes, {
            start: startRowIndex,
            end: endRowIndex
          }, function () {});
        });
      }
    }
  }, {
    key: "scrollTopMax",
    get: function get() {
      return this.mounted ? this.scrollContainer.scrollTopMax : 0;
    }
  }, {
    key: "scrollLeftMax",
    get: function get() {
      return this.mounted ? this.scrollContainer.scrollLeftMax : 0;
    }
  }, {
    key: "scrollTop",
    get: function get() {
      return this.mounted ? this.getScrollingElement().scrollTop : 0;
    },
    set: function set(value) {
      var element = this.getScrollingElement();

      if (element) {
        element.scrollTop = value;
      }
    }
  }, {
    key: "scrollLeft",
    get: function get() {
      return this.mounted ? this.getScrollingElement().scrollLeft : 0;
    },
    set: function set(value) {
      var element = this.getScrollingElement();

      if (element) {
        element.scrollLeft = value;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.props.rowHeightManager) {
        this.props.rowHeightManager.removeListener('index', this.onIndex);
      }

      this.mounted = false;
      this.unmounted = true;
      this.rows = null;
      this.rowHeights = null;
      this.rowOffsets = null;
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      var nextCount = Math.max(nextProps.count, 0);
      var rowHeightChange = this.props.rowHeight && nextProps.rowHeight != this.props.rowHeight;

      if (this.props.renderRow !== nextProps.renderRow) {
        this.rowCoveredBy = {};
        this.rowSpans = {};
      }

      if (nextCount != this.props.count || nextProps.showEmptyRows != this.props.showEmptyRows || rowHeightChange) {
        var oldVisibleCount = this.getVisibleCount();
        this.updateVisibleCount(this.size.height, nextProps);
        this.cleanupRows(nextProps);
        this.reorder = rowHeightChange || this.getVisibleCount(nextProps) < oldVisibleCount;
        this.initSizes(nextProps);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this3 = this;

      var prevScrollTopPos;
      var prevScrollLeftPos;

      if (this.props.nativeScroll !== prevProps.nativeScroll) {
        prevScrollTopPos = this.scrollTopPos;
        prevScrollLeftPos = this.scrollLeftPos;
        globalObject.requestAnimationFrame(function () {
          if (_this3.unmounted) {
            return;
          }

          _this3.scrollTop = prevScrollTopPos;
          _this3.scrollLeft = prevScrollLeftPos;
        });
      }

      if (this.props.rowHeightManager !== prevProps.rowHeightManager) {
        if (prevProps.rowHeightManager) {
          prevProps.rowHeightManager.removeListener('index', this.onIndex);
        }

        this.setupRowHeightManager(this.props.rowHeightManager);
      }

      if (this.props.count != prevProps.count || this.props.renderRow != prevProps.renderRow || this.props.rowHeightManager != prevProps.rowHeightManager || this.props.rowHeightManager == null || this.props.showEmptyRows != prevProps.showEmptyRows) {
        var refreshConfig = {
          reorder: this.reorder
        };

        if (prevScrollTopPos !== undefined) {
          refreshConfig.scrollTop = prevScrollTopPos;
          refreshConfig.scrollLeft = prevScrollLeftPos;
        }

        if (this.props.count <= this.visibleCount) {
          refreshConfig.scrollTop = 0;
        }

        if ((IS_EDGE || IS_FF) && this.props.count < prevProps.count) {
          this.fixEdgeScrollPosition();
        }

        this.reorder = false;
        this.refreshLayout(refreshConfig);
      }

      if (prevProps.stickyRows !== this.props.stickyRows) {
        this.updateStickyRows(undefined, undefined, {
          force: true
        });
      }
    }
  }, {
    key: "getDOMNode",
    value: function getDOMNode() {
      return this.scrollContainer ? this.scrollContainer.domNode || this.scrollContainer.getDOMNode() : null;
    }
  }, {
    key: "renderRows",
    value: function renderRows() {
      var props = this.props;
      var rowHeight = props.rowHeight,
          renderRow = props.renderRow,
          count = props.count,
          pureRows = props.pureRows,
          rowHeightManager = props.rowHeightManager,
          showEmptyRows = props.showEmptyRows,
          virtualized = props.virtualized,
          rowContain = props.rowContain,
          naturalRowHeight = props.naturalRowHeight,
          useTransformRowPosition = props.useTransformRowPosition;
      var to = this.getVisibleCount();
      return (0, _renderRows2.default)({
        ref: this.rowRef,
        onUnmount: this.onRowUnmount,
        notifyRowSpan: this.setRowRowSpan,
        pure: pureRows,
        renderRow: renderRow,
        rowHeightManager: rowHeightManager,
        rowHeight: rowHeight,
        rowContain: rowContain,
        count: count,
        from: 0,
        to: to,
        naturalRowHeight: naturalRowHeight,
        onKeyDown: this.onRowKeyDown,
        onFocus: this.onRowFocus,
        useTransformPosition: useTransformRowPosition,
        showEmptyRows: showEmptyRows,
        virtualized: virtualized
      });
    }
  }, {
    key: "getFirstVisibleRowIndexForSticky",
    value: function getFirstVisibleRowIndexForSticky() {
      var scrollTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scrollTopPos;
      var rowHeightManager = this.props.rowHeightManager;
      var stickyHeight = this.currentStickyRows ? this.currentStickyRows.reduce(function (_, row) {
        return rowHeightManager.getRowHeight(row.index);
      }, 0) : 0;
      var rowIndex = Math.max(0, rowHeightManager.getRowAt(scrollTop + stickyHeight) - 1);
      return rowIndex;
    }
  }, {
    key: "scrollToIndex",
    value: function scrollToIndex(index) {
      var _this4 = this;

      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyObject,
          direction = _ref5.direction,
          force = _ref5.force,
          _ref5$duration = _ref5.duration,
          duration = _ref5$duration === void 0 ? 0 : _ref5$duration,
          _ref5$offset = _ref5.offset,
          offset = _ref5$offset === void 0 ? 0 : _ref5$offset;

      var callback = arguments.length > 2 ? arguments[2] : undefined;

      if (direction) {
        if (direction != 'top' && direction != 'bottom') {
          direction = null;
        }
      }

      if (force && !direction) {
        force = false;
      }

      if (index < 0 || index >= this.getMaxRenderCount()) {
        return;
      }

      if (typeof callback != 'function') {
        callback = emptyFn;
      }

      var info = this.getRowVisibilityInfo(index, offset);

      if (!info.rendered) {
        var rowHeight = this.props.rowHeight;

        if (!direction) {
          var existingIndex = this.rows[0].getIndex();
          direction = index > existingIndex ? 'bottom' : 'top';
        }

        var newScrollTop = direction === 'top' ? info.top - offset : this.scrollTop - info.bottomDiff + offset;

        var afterScroll = function afterScroll() {
          if (!rowHeight) {
            setTimeout(function () {
              globalObject.requestAnimationFrame(function () {
                _this4.scrollToIndex(index, {
                  direction: direction,
                  force: force,
                  duration: duration ? 100 : 0
                }, callback);
              });
            });
          } else {
            callback();
          }
        };

        if (duration) {
          this.smoothScrollTo(newScrollTop, {
            duration: duration
          }, afterScroll);
        } else {
          this.scrollTop = newScrollTop;
          afterScroll();
        }

        return;
      }

      var visible = info.visible;

      if (!visible) {
        if (!direction) {
          direction = info.topDiff < 0 ? 'top' : 'bottom';
          force = true;
        }
      }

      if (!visible || direction && force) {
        var _newScrollTop;

        if (direction == 'top' || info.topDiff < 0) {
          _newScrollTop = this.scrollTop + info.topDiff - offset;
        } else if (direction == 'bottom' || info.bottomDiff < 0) {
          _newScrollTop = this.scrollTop - info.bottomDiff + offset;
        }

        if (_newScrollTop != null) {
          if (duration) {
            this.smoothScrollTo(_newScrollTop, {
              duration: duration
            }, callback);
            return;
          }

          this.scrollTop = _newScrollTop;
        }
      }

      callback();
    }
  }, {
    key: "getEmptyScrollOffset",
    value: function getEmptyScrollOffset() {
      if (this.props.emptyScrollOffset != null) {
        return this.props.emptyScrollOffset;
      }

      var SCROLLBAR_WIDTH = (0, _src.getScrollbarWidth)();
      return this.props.emptyScrollOffset || SCROLLBAR_WIDTH || 17;
    }
  }]);
  return InovuaVirtualList;
}(_react.Component);

exports.default = InovuaVirtualList;
InovuaVirtualList.defaultProps = {
  minRowHeight: 20,
  nativeScroll: false,
  shouldAllowScrollbars: function shouldAllowScrollbars() {
    return true;
  },
  rafOnResize: false,
  theme: 'default-light',
  showEmptyRows: false,
  showWarnings: !_uglified.default,
  virtualized: true,
  scrollOneDirectionOnly: false,
  useTransformPosition: !IS_EDGE && (0, _src.hasSticky)(),
  useTransformRowPosition: false,
  recycleCoveredRows: true,
  scrollProps: {}
};
var propTypes = {
  applyScrollLeft: _propTypes.default.func,
  naturalRowHeight: _propTypes.default.bool,
  count: function count(props) {
    var count = props.count;

    if (count == null) {
      throw new Error("\"count\" is required!");
    }

    if (typeof count != 'number') {
      throw new Error("\"count\" should be a number!");
    }

    if (count < 0) {
      throw new Error("\"count\" should be >= 0!");
    }
  },
  getRowFocusableElements: _propTypes.default.func,
  contain: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.string]),
  rowContain: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.string]),
  handleRowKeyDown: _propTypes.default.func,
  rafOnResize: _propTypes.default.bool,
  checkResizeDelay: _propTypes.default.number,
  extraRows: _propTypes.default.number,
  measureSize: _propTypes.default.func,
  minRowHeight: _propTypes.default.number,
  minRowWidth: _propTypes.default.number,
  nativeScroll: _propTypes.default.bool,
  onRenderRangeChange: _propTypes.default.func,
  shouldFocusNextRow: _propTypes.default.func,
  onResize: _propTypes.default.func,
  onScrollStart: _propTypes.default.func,
  onScrollbarsChange: _propTypes.default.func,
  onScrollStop: _propTypes.default.func,
  pureRows: _propTypes.default.bool,
  rowHeight: _propTypes.default.number,
  renderRow: _propTypes.default.func.isRequired,
  renderRowContainer: _propTypes.default.func,
  renderSizer: _propTypes.default.func,
  showEmptyRows: _propTypes.default.bool,
  useTransformPosition: _propTypes.default.bool,
  useTransformRowPosition: _propTypes.default.bool,
  scrollProps: _propTypes.default.object,
  showWarnings: _propTypes.default.bool,
  renderView: _propTypes.default.func,
  renderScroller: _propTypes.default.func,
  renderScrollerSpacer: _propTypes.default.func,
  shouldComponentUpdate: _propTypes.default.func,
  shouldPreventDefaultTabKeyOnRow: _propTypes.default.func,
  theme: _propTypes.default.string,
  overscrollBehavior: _propTypes.default.string,
  virtualized: _propTypes.default.bool,
  scrollOneDirectionOnly: _propTypes.default.bool,
  onStickyRowUpdate: _propTypes.default.func,
  stickyRows: _propTypes.default.object,
  recycleCoveredRows: _propTypes.default.bool,
  stickyOffset: _propTypes.default.number,
  enableRowSpan: _propTypes.default.bool,
  rowHeightManager: function rowHeightManager(props, propName) {
    var value = props[propName];

    if (!value) {
      return new Error("\nYou have to provide a \"rowHeightManager\" property, which should be an instance of RowHeightManager.\n");
    }

    if (!(value instanceof _RowHeightManager.default)) {
      return new Error('The "rowHeightManager" property should be an instance of RowHeightManager!');
    }
  }
};
exports.propTypes = propTypes;
InovuaVirtualList.propTypes = propTypes;
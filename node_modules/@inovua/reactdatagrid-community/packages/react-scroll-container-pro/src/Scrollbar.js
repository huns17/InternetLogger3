/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _autoBind = _interopRequireDefault(require("../../react-class/autoBind"));

var _reactCleanProps = _interopRequireDefault(require("../../react-clean-props"));

var _shouldComponentUpdate2 = _interopRequireDefault(require("./shouldComponentUpdate"));

var _join = _interopRequireDefault(require("../../join"));

var _getGlobal = require("../../../getGlobal");

var _SIZES, _OTHER_SIZES, _MARGINS, _TRACK_SIDES;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var globalObject = (0, _getGlobal.getGlobal)();
var HORIZONTAL = 'horizontal';
var VERTICAL = 'vertical';
var SIZES = (_SIZES = {}, (0, _defineProperty2.default)(_SIZES, VERTICAL, 'height'), (0, _defineProperty2.default)(_SIZES, HORIZONTAL, 'width'), _SIZES);
var OTHER_SIZES = (_OTHER_SIZES = {}, (0, _defineProperty2.default)(_OTHER_SIZES, VERTICAL, 'width'), (0, _defineProperty2.default)(_OTHER_SIZES, HORIZONTAL, 'height'), _OTHER_SIZES);
var MARGINS = (_MARGINS = {}, (0, _defineProperty2.default)(_MARGINS, VERTICAL, 'right'), (0, _defineProperty2.default)(_MARGINS, HORIZONTAL, 'bottom'), _MARGINS);
var TRACK_SIDES = (_TRACK_SIDES = {}, (0, _defineProperty2.default)(_TRACK_SIDES, VERTICAL, ['top', 'bottom']), (0, _defineProperty2.default)(_TRACK_SIDES, HORIZONTAL, ['left', 'right']), _TRACK_SIDES);
var STYLES = {
  vertical: {
    position: 'absolute',
    top: 0,
    bottom: 0,
    right: 0,
    contain: 'layout paint style'
  },
  horizontal: {
    position: 'absolute',
    left: 0,
    right: 0,
    bottom: 0,
    contain: 'layout paint style'
  }
};

var InovuaScrollbar = function (_Component) {
  (0, _inherits2.default)(InovuaScrollbar, _Component);

  var _super = _createSuper(InovuaScrollbar);

  function InovuaScrollbar(props) {
    var _this;

    (0, _classCallCheck2.default)(this, InovuaScrollbar);
    _this = _super.call(this, props);
    (0, _autoBind.default)((0, _assertThisInitialized2.default)(_this));
    _this.scrollPos = 0;
    _this.state = {
      scrollPos: 0
    };

    _this.refTrack = function (c) {
      _this.trackNode = c;
    };

    _this.refThumb = function (c) {
      _this.thumbNode = c;
    };

    return _this;
  }

  (0, _createClass2.default)(InovuaScrollbar, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      return (0, _shouldComponentUpdate2.default)(this, nextProps, nextState);
    }
  }, {
    key: "setVisible",
    value: function setVisible(visible) {
      this.visible = visible;

      if (!visible && this.state.over) {
        return;
      }

      if (this.state.visible === visible) {
        return;
      }

      this.setState({
        visible: visible
      });
    }
  }, {
    key: "setScrollPos",
    value: function setScrollPos(scrollPos) {
      this.scrollPos = scrollPos;
      var transform = this.getThumbTransform();

      if (this.currentTransform == transform) {
        return;
      }

      this.thumbNode.style.transform = this.currentTransform = transform;
    }
  }, {
    key: "getScrollPos",
    value: function getScrollPos() {
      return this.scrollPos;
    }
  }, {
    key: "render",
    value: function render() {
      var _Object$assign;

      var props = this.props;
      var autoHide = props.autoHide;
      var className = props.className,
          style = props.style,
          orientation = props.orientation,
          vertical = props.vertical,
          horizontal = props.horizontal,
          thumbVisible = props.visible;

      if (orientation) {
        vertical = orientation == VERTICAL;
        horizontal = !vertical;
      }

      this.orientation = orientation = horizontal ? HORIZONTAL : VERTICAL;
      var sizeName = SIZES[orientation];
      var otherSizeName = OTHER_SIZES[orientation];

      if (autoHide === false) {
        thumbVisible = true;
      } else {
        if (this.state.visible !== undefined) {
          thumbVisible = this.state.visible;
        }

        if (this.state.active) {
          thumbVisible = true;
        }
      }

      var hiding = !thumbVisible && this.prevVisible;
      var showing = thumbVisible && !this.prevVisible;
      className = (0, _join.default)(className, 'inovua-react-scroll-container__scrollbar', "inovua-react-scroll-container__scrollbar--orientation-".concat(orientation), "inovua-react-scroll-container__scrollbar--direction-".concat(this.props.rtl ? 'rtl' : 'ltr'), !thumbVisible && 'inovua-react-scroll-container__scrollbar--hidden', hiding && 'inovua-react-scroll-container__scrollbar--hiding', this.state.active && 'inovua-react-scroll-container__scrollbar--active', showing && 'inovua-react-scroll-container__scrollbar--showing');
      style = Object.assign({}, style, STYLES[orientation]);

      if (showing && this.props.showTransitionDuration) {
        style.transitionDuration = this.props.showTransitionDuration;
      }

      if (hiding && this.props.hideTransitionDuration) {
        style.transitionDuration = this.props.hideTransitionDuration;
      }

      this.prevVisible = thumbVisible;
      var divProps = (0, _reactCleanProps.default)(props, InovuaScrollbar.propTypes);
      var thumbSize = this.getThumbSize();
      var transform = this.getThumbTransform(orientation, thumbSize);
      var scrollThumbOverWidth = Math.max(this.props.scrollThumbOverWidth, this.props.scrollThumbWidth);
      var thumbRadius = this.props.scrollThumbRadius !== undefined ? this.props.scrollThumbRadius : this.props.scrollThumbWidth;
      var thumbStyle = Object.assign({}, this.props.scrollThumbStyle, (_Object$assign = {}, (0, _defineProperty2.default)(_Object$assign, sizeName, thumbSize), (0, _defineProperty2.default)(_Object$assign, otherSizeName, this.state.over || this.state.active || this.props.alwaysShowTrack ? scrollThumbOverWidth : this.props.scrollThumbWidth), (0, _defineProperty2.default)(_Object$assign, "transform", transform), (0, _defineProperty2.default)(_Object$assign, "borderRadius", thumbRadius), (0, _defineProperty2.default)(_Object$assign, "transitionDuration", this.props.scrollTrackOverTransitionDuration), _Object$assign));
      var trackSides = TRACK_SIDES[orientation];
      var scrollThumbMargin = this.props.scrollThumbMargin || 0;

      if (this.props.scrollThumbMargin) {
        style[MARGINS[orientation]] = scrollThumbMargin;

        if (this.props.scrollThumbStartEndRespectMargin) {
          style[trackSides[0]] = this.props.scrollThumbMargin;
        }
      }

      style[trackSides[1]] = scrollThumbMargin + (this.props.oppositeVisible ? this.props.scrollThumbWidth : 0);
      var thumbClassName = "inovua-react-scroll-container__thumb inovua-react-scroll-container__thumb--orientation-".concat(orientation, " inovua-react-scroll-container__thumb--direction-").concat(this.props.rtl ? 'rtl' : 'ltr');
      var trackClassName = "inovua-react-scroll-container__track inovua-react-scroll-container__track--orientation-".concat(orientation, " inovua-react-scroll-container__track--direction-").concat(this.props.rtl ? 'rtl' : 'ltr');
      var trackVisible = this.props.alwaysShowTrack || thumbVisible && this.state.over || this.props.showTrackOnDrag && this.state.active;

      if (trackVisible) {
        trackClassName += ' inovua-react-scroll-container__track--visible';
      }

      var trackStyle = (0, _defineProperty2.default)({
        pointerEvents: 'none'
      }, otherSizeName, scrollThumbOverWidth);

      if (this.props.dragToScroll) {
        if (thumbVisible) {
          trackStyle.pointerEvents = 'all';
        }

        trackStyle.borderRadius = thumbRadius;
        trackClassName += ' inovua-react-scroll-container__track--drag-to-scroll';

        if (this.state.active) {
          trackStyle.cursor = 'auto';
        }
      }

      if (this.props.rtl) {
        var leftVal = style.left;
        style.left = style.right;
        style.right = leftVal;
      }

      var onThumbMouseDown = thumbVisible && this.props.dragToScroll ? this.onThumbMouseDown : null;
      var onTrackClick = thumbVisible && this.props.dragToScroll ? this.onTrackClick : null;
      var onTrackWheel = this.props.dragToScroll && this.state.over ? this.onTrackWheel : null;
      return _react.default.createElement("div", _objectSpread(_objectSpread({}, divProps), {}, {
        style: style,
        className: className,
        "data-orientation": orientation
      }), _react.default.createElement("div", {
        ref: this.refTrack,
        style: trackStyle,
        className: trackClassName,
        onClick: onTrackClick,
        onWheel: onTrackWheel,
        onMouseEnter: this.props.dragToScroll ? this.onMouseEnter : null,
        onMouseLeave: this.props.dragToScroll ? this.onMouseLeave : null
      }, _react.default.createElement("div", {
        ref: this.refThumb,
        style: thumbStyle,
        className: thumbClassName,
        onMouseDown: onThumbMouseDown
      })));
    }
  }, {
    key: "setOver",
    value: function setOver(over) {
      var _this2 = this;

      var doSetOver = function doSetOver(overValue) {
        _this2.setState({
          over: overValue
        }, function () {
          if (!overValue) {
            if (_this2.visible !== _this2.state.visible) {
              _this2.setVisible(_this2.visible);
            }
          }
        });
      };

      if (this.setOverFalseTimeoutId) {
        clearTimeout(this.setOverFalseTimeoutId);
      }

      if (!over) {
        this.setOverFalseTimeoutId = setTimeout(function () {
          doSetOver(false);
        }, 500);
      } else {
        this.setOverFalseTimeoutId = setTimeout(function () {
          doSetOver(true);
        }, 35);
      }
    }
  }, {
    key: "onMouseEnter",
    value: function onMouseEnter() {
      this.setOver(true);
    }
  }, {
    key: "onMouseLeave",
    value: function onMouseLeave() {
      this.setOver(false);
    }
  }, {
    key: "onTrackWheel",
    value: function onTrackWheel(event) {
      var delta = this.orientation == VERTICAL ? event.deltaY : event.deltaX;
      event.preventDefault();
      this.props.onWheelScroll(this.orientation, delta, event);
    }
  }, {
    key: "onTrackClick",
    value: function onTrackClick(event) {
      var target = event.target;

      if (target != this.trackNode) {
        return;
      }

      var rect = target.getBoundingClientRect();
      var offsetX = event.clientX - rect.left;
      var offsetY = event.clientY - rect.top;
      var pos = this.orientation == VERTICAL ? offsetY : offsetX;
      var thumbPos = this.getThumbPosition();
      var direction = pos > thumbPos ? 1 : -1;

      if (this.props.onPageScroll) {
        this.props.onPageScroll(this.orientation, direction);
      }
    }
  }, {
    key: "getCoord",
    value: function getCoord(event) {
      return this.orientation == VERTICAL ? event.pageY : event.pageX;
    }
  }, {
    key: "getThumbPosition",
    value: function getThumbPosition() {
      return this.scrollPosToThumbPos(this.getScrollPos(), this.orientation, this.getThumbSize());
    }
  }, {
    key: "onThumbMouseDown",
    value: function onThumbMouseDown(event) {
      event.preventDefault();
      event.stopPropagation();
      this.initialPos = this.getCoord(event);
      this.thumbSize = this.getThumbSize();
      this.initialThumbPos = this.getThumbPosition();
      this.setState({
        active: true
      });
      globalObject.addEventListener('mousemove', this.onMouseMove);
      globalObject.addEventListener('mouseup', this.onMouseUp);
      this.props.onStartDrag(this.orientation);
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      var pos = this.getCoord(event);
      var diff = pos - this.initialPos;
      var scrollPos = this.thumbPosToScrollPos(this.initialThumbPos + diff, this.orientation, this.thumbSize);

      if (this.orientation == VERTICAL) {
        this.onScrollThumbScrollTop(scrollPos);
      } else {
        this.onScrollThumbScrollLeft(scrollPos);
      }
    }
  }, {
    key: "onScrollThumbScrollTop",
    value: function onScrollThumbScrollTop(scrollPos) {
      this.props.onScrollThumbScrollTop(scrollPos);
    }
  }, {
    key: "onScrollThumbScrollLeft",
    value: function onScrollThumbScrollLeft(scrollPos) {
      this.props.onScrollThumbScrollLeft(scrollPos);
    }
  }, {
    key: "onMouseUp",
    value: function onMouseUp() {
      globalObject.removeEventListener('mousemove', this.onMouseMove);
      globalObject.removeEventListener('mouseup', this.onMouseUp);
      this.setState({
        active: false
      });
      this.props.onStopDrag(this.orientation);
    }
  }, {
    key: "getThumbTransform",
    value: function getThumbTransform() {
      var orientation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.orientation;
      var thumbSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getThumbSize();
      var scrollPos = this.scrollPosToThumbPos(this.getScrollPos(), orientation, thumbSize) || 0;

      if (orientation == VERTICAL) {
        return "translate3d(0px, ".concat(scrollPos, "px, 0px)");
      }

      if (this.props.rtl) {
        scrollPos = -scrollPos;
      }

      return "translate3d(".concat(scrollPos, "px, 0px, 0px)");
    }
  }, {
    key: "thumbPosToScrollPos",
    value: function thumbPosToScrollPos(thumbPos, orientation, thumbSize) {
      var _this$props = this.props,
          clientSize = _this$props.clientSize,
          scrollSize = _this$props.scrollSize,
          trackSize = _this$props.trackSize;
      var scrollPos = thumbPos * (scrollSize - clientSize) / (trackSize - thumbSize);
      return scrollPos;
    }
  }, {
    key: "scrollPosToThumbPos",
    value: function scrollPosToThumbPos(scrollPos, orientation, thumbSize) {
      var _this$props2 = this.props,
          clientSize = _this$props2.clientSize,
          scrollSize = _this$props2.scrollSize,
          trackSize = _this$props2.trackSize;
      var thumbPos = scrollPos / (scrollSize - clientSize) * (trackSize - thumbSize);
      return Math.floor(thumbPos);
    }
  }, {
    key: "getRatio",
    value: function getRatio() {
      return this.props.trackSize / this.props.clientSize;
    }
  }, {
    key: "getThumbSize",
    value: function getThumbSize() {
      var _this$props3 = this.props,
          scrollSize = _this$props3.scrollSize,
          clientSize = _this$props3.clientSize;
      var thumbSize = scrollSize ? clientSize * clientSize / scrollSize : 0;
      thumbSize *= this.getRatio();
      thumbSize = Math.max(thumbSize, this.props.scrollThumbMinSize);
      return thumbSize || 0;
    }
  }]);
  return InovuaScrollbar;
}(_react.Component);

exports.default = InovuaScrollbar;
InovuaScrollbar.defaultProps = {
  onScrollThumbScrollTop: function onScrollThumbScrollTop() {},
  onScrollThumbScrollLeft: function onScrollThumbScrollLeft() {},
  onStartDrag: function onStartDrag() {},
  onStopDrag: function onStopDrag() {},
  scrollThumbMargin: 2,
  scrollThumbMinSize: 10,
  showTrackOnDrag: false
};
InovuaScrollbar.propTypes = {
  alwaysShowTrack: _propTypes.default.bool,
  autoHide: _propTypes.default.bool,
  clientSize: _propTypes.default.number,
  dragToScroll: _propTypes.default.bool,
  emptyScrollOffset: _propTypes.default.number,
  hideTransitionDuration: _propTypes.default.string,
  horizontal: _propTypes.default.bool,
  showTrackOnDrag: _propTypes.default.bool,
  onStartDrag: _propTypes.default.func,
  onStopDrag: _propTypes.default.func,
  onPageScroll: _propTypes.default.func,
  onScrollThumbScrollLeft: _propTypes.default.func,
  onScrollThumbScrollTop: _propTypes.default.func,
  onWheelScroll: _propTypes.default.func,
  oppositeVisible: _propTypes.default.bool,
  orientation: _propTypes.default.oneOf([VERTICAL, HORIZONTAL]),
  nativeScrollbarWidth: _propTypes.default.number.isRequired,
  scrollSize: _propTypes.default.number,
  scrollThumbMargin: _propTypes.default.number.isRequired,
  scrollThumbMinSize: _propTypes.default.number,
  scrollThumbOverWidth: _propTypes.default.number,
  scrollThumbRadius: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  scrollThumbStartEndRespectMargin: _propTypes.default.bool,
  scrollThumbStyle: _propTypes.default.shape({}),
  scrollThumbWidth: _propTypes.default.number,
  scrollTrackOverTransitionDuration: _propTypes.default.string,
  showTransitionDuration: _propTypes.default.string,
  size: _propTypes.default.number,
  trackSize: _propTypes.default.number,
  vertical: _propTypes.default.bool,
  visible: _propTypes.default.bool,
  rtl: _propTypes.default.bool
};
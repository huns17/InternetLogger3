/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _region = _interopRequireDefault(require("../region"));

function ALIGN_TO_NORMALIZED(sourceRegion, targetRegion, positions, config) {
  targetRegion = _region.default.from(targetRegion);
  config = config || {};
  var constrainTo = config.constrain,
      syncOption = config.sync,
      offsets = config.offset || [],
      syncWidth = false,
      syncHeight = false,
      sourceClone = sourceRegion.clone();

  if (!Array.isArray(positions)) {
    positions = positions ? [positions] : [];
  }

  if (!Array.isArray(offsets)) {
    offsets = offsets ? [offsets] : [];
  }

  if (constrainTo) {
    constrainTo = constrainTo === true ? _region.default.getDocRegion() : constrainTo.getRegion();
  }

  if (syncOption) {
    if (syncOption.size) {
      syncWidth = true;
      syncHeight = true;
    } else {
      syncWidth = syncOption === true ? true : syncOption.width || false;
      syncHeight = syncOption === true ? true : syncOption.height || false;
    }
  }

  if (syncWidth) {
    sourceClone.setWidth(targetRegion.getWidth());
  }

  if (syncHeight) {
    sourceClone.setHeight(targetRegion.getHeight());
  }

  var offset,
      i = 0,
      len = positions.length,
      pos,
      intersection,
      itArea,
      maxArea = -1,
      maxAreaIndex = -1;

  for (; i < len; i++) {
    pos = positions[i];
    offset = offsets[i];
    sourceClone.alignToRegion(targetRegion, pos);

    if (offset) {
      if (!Array.isArray(offset)) {
        offset = offsets[i] = [offset.x || offset.left, offset.y || offset.top];
      }

      sourceClone.shift({
        left: offset[0],
        top: offset[1]
      });
    }

    if (constrainTo) {
      intersection = sourceClone.getIntersection(constrainTo);

      if (intersection && intersection.equals(sourceClone)) {
        sourceRegion.set(sourceClone);
        return pos;
      } else {
        if (intersection && (itArea = intersection.getArea()) > maxArea) {
          maxArea = itArea;
          maxAreaIndex = i;
        }
      }
    } else {
      sourceRegion.set(sourceClone);
      return pos;
    }
  }

  if (~maxAreaIndex) {
    pos = positions[maxAreaIndex];
    offset = offsets[maxAreaIndex];
    sourceClone.alignToRegion(targetRegion, pos);

    if (offset) {
      sourceClone.shift({
        left: offset[0],
        top: offset[1]
      });
    }

    intersection = sourceClone.getIntersection(constrainTo);
    sourceClone.setRegion(intersection);
    sourceClone.alignToRegion(targetRegion, pos);

    if (offset) {
      sourceClone.shift({
        left: offset[0],
        top: offset[1]
      });
    }

    sourceRegion.set(sourceClone);
    return pos;
  }
}

var _default = ALIGN_TO_NORMALIZED;
exports.default = _default;
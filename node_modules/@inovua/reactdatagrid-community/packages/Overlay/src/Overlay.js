/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _cleanProps = _interopRequireDefault(require("../../../common/cleanProps"));

var _assign = _interopRequireDefault(require("../../../common/assign"));

var _eventManager = _interopRequireDefault(require("./eventManager"));

var _getMinMaxSize = _interopRequireDefault(require("./utils/getMinMaxSize"));

var _join = _interopRequireDefault(require("./utils/join"));

var _shouldComponentUpdate2 = _interopRequireDefault(require("./utils/shouldComponentUpdate"));

var _normalizeEvent = _interopRequireDefault(require("./utils/normalizeEvent"));

var _getFocusableElements = _interopRequireDefault(require("./utils/getFocusableElements"));

var _getPositionRelativeToElement = _interopRequireDefault(require("../../../common/getPositionRelativeToElement"));

var _Arrow = _interopRequireDefault(require("./Arrow"));

var _positionsMap = require("../../../common/getPositionRelativeToElement/positionsMap");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var InovuaOverlay = function (_Component) {
  (0, _inherits2.default)(InovuaOverlay, _Component);

  var _super = _createSuper(InovuaOverlay);

  function InovuaOverlay(props) {
    var _this;

    (0, _classCallCheck2.default)(this, InovuaOverlay);
    _this = _super.call(this, props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "componentDidUpdate", function (prevProps) {
      if (prevProps.visible !== _this.props.visible) {
        _this.handleVisibleChange(_this.props.visible);
      }
    });
    _this.state = {
      visible: props.defaultVisible,
      position: null,
      arrowConfig: null,
      renderTrigger: null
    };
    _this.handleDocumentScroll = _this.handleDocumentScroll.bind((0, _assertThisInitialized2.default)(_this));
    _this.onHide = _this.onHide.bind((0, _assertThisInitialized2.default)(_this));
    _this.onShow = _this.onShow.bind((0, _assertThisInitialized2.default)(_this));
    _this.handleKeyDown = _this.handleKeyDown.bind((0, _assertThisInitialized2.default)(_this));
    _this.getOverlayNode = _this.getOverlayNode.bind((0, _assertThisInitialized2.default)(_this));
    _this.getVisible = _this.getVisible.bind((0, _assertThisInitialized2.default)(_this));
    _this.getActiveTargetNode = _this.getActiveTargetNode.bind((0, _assertThisInitialized2.default)(_this));

    _this.rootRef = function (node) {
      _this.rootNode = node;
    };

    _this.fixedRef = function (node) {
      _this.fixedNode = node;
    };

    return _this;
  }

  (0, _createClass2.default)(InovuaOverlay, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      return (0, _shouldComponentUpdate2.default)(this, nextProps, nextState);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.register();
      this.componentIsMounted = true;

      if (this.props.updatePositionOnScroll) {
        window.addEventListener('scroll', this.handleDocumentScroll, true);
      }

      var doPosition = function doPosition() {
        var target = _this2.getTarget();

        if ((0, _typeof2.default)(target) === 'object') {
          _this2.activeTargetNode = target;

          _this2.setPosition(_this2.props.onInitialPosition);

          if (_this2.getVisible()) {
            _this2.onShow({
              target: target
            });
          }
        }
      };

      if (this.props.rafOnMount) {
        requestAnimationFrame(doPosition);
      } else {
        doPosition();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unregister();
      this.componentIsMounted = null;
      this.activeTargetNode = null;

      if (this.props.updatePositionOnScroll) {
        window.removeEventListener('scroll', this.handleDocumentScroll, true);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var props = this.props;
      var className = this.prepareClassName();
      var contentClassName = this.prepareContentClassName();
      var style = this.prepareStyle();
      var contentStyle = this.prepareContentStyle();
      return _react.default.createElement("div", _objectSpread(_objectSpread({}, (0, _cleanProps.default)(props, InovuaOverlay.propTypes)), {}, {
        className: className,
        ref: this.rootRef,
        style: style,
        onKeyDown: this.handleKeyDown
      }), _react.default.createElement("div", _objectSpread(_objectSpread({
        className: contentClassName
      }, this.getChildrenProps()), {}, {
        style: contentStyle
      })), props.arrow && this.renderArrow(), props.relativeToViewport && this.renderFixed());
    }
  }, {
    key: "renderFixed",
    value: function renderFixed() {
      return _react.default.createElement("div", {
        style: {
          position: 'fixed',
          top: 0,
          left: 0,
          width: 0,
          height: 0
        },
        ref: this.fixedRef
      });
    }
  }, {
    key: "renderArrow",
    value: function renderArrow() {
      if (!this.state.arrowConfig) {
        return null;
      }

      var rootClassName = this.props.rootClassName;
      var position = this.state.arrowConfig.position;
      var location = this.state.arrowConfig.location;
      var className = (0, _join.default)("".concat(rootClassName, "__arrow"), "".concat(rootClassName, "__arrow--").concat(location), this.props.arrowClassName);
      var style = (0, _assign.default)({}, this.props.arrowStyle);

      if (this.props.border) {
        (0, _assign.default)(style, {
          border: this.props.border
        });
      }

      if (this.props.background != undefined) {
        (0, _assign.default)(style, {
          background: this.props.background
        });
      }

      var wrapperClassName = (0, _join.default)("".concat(rootClassName, "__arrow-wrapper"), "".concat(rootClassName, "__arrow-wrapper--").concat(location));
      return _react.default.createElement(_Arrow.default, {
        className: className,
        wrapperClassName: wrapperClassName,
        position: position,
        style: style,
        size: this.props.arrowSize
      });
    }
  }, {
    key: "getChildrenProps",
    value: function getChildrenProps() {
      var children = this.props.children;
      var targetNode = this.getPositionTarget();
      var childrenProps = {
        children: children
      };
      var childrenParams = {
        targetNode: targetNode,
        visible: this.getVisible()
      };

      if (typeof children === 'function') {
        return {
          children: children(childrenParams)
        };
      }

      if (children === undefined && targetNode) {
        var tooltip = targetNode.getAttribute('data-tooltip');

        if (tooltip != null) {
          return {
            dangerouslySetInnerHTML: {
              __html: tooltip
            }
          };
        }
      }

      return childrenProps;
    }
  }, {
    key: "prepareClassName",
    value: function prepareClassName() {
      var props = this.props,
          state = this.state;
      var rootClassName = props.rootClassName,
          theme = props.theme,
          visibleClassName = props.visibleClassName,
          relativeToViewport = props.relativeToViewport;
      var visible = this.getVisible();
      var className = (0, _join.default)(rootClassName, props.className, visible && "".concat(rootClassName, "--visible"), visible && visibleClassName, !visible && "".concat(rootClassName, "--invisible"), relativeToViewport && "".concat(rootClassName, "--position-fixed"), theme && "".concat(rootClassName, "--theme-").concat(theme));

      if (this.props.fade) {
        className = (0, _join.default)(className, props.fade && "".concat(rootClassName, "--has-transition"), state.transitionEnter && "".concat(rootClassName, "--transition-enter"), state.transitionEnterActive && "".concat(rootClassName, "--transition-enter-active"), state.transitionLeave && "".concat(rootClassName, "--transition-leave"), state.transitionLeaveActive && "".concat(rootClassName, "--transition-leave-active"));
      }

      return className;
    }
  }, {
    key: "prepareContentClassName",
    value: function prepareContentClassName() {
      return (0, _join.default)(this.props.contentClassName, "".concat(this.props.rootClassName, "__content"));
    }
  }, {
    key: "prepareStyle",
    value: function prepareStyle() {
      var style = (0, _assign.default)({
        zIndex: this.props.zIndex
      }, this.props.style);

      if (this.props.fade) {
        (0, _assign.default)(style, this.getTransitionStyle());
      }

      if (this.props.border) {
        (0, _assign.default)(style, {
          border: this.props.border
        });
      }

      if (this.state.position) {
        if (this.props.useTransform) {
          style.transform = "translate3d(".concat(Math.round(this.state.position.left || 0), "px, ").concat(Math.round(this.state.position.top || 0), "px, 0px)");
          style.left = 0;
          style.top = 0;
        } else {
          (0, _assign.default)(style, {
            left: Math.round(this.state.position.left)
          });

          if (this.state.position.top != null) {
            style.top = Math.round(this.state.position.top);
          }
        }

        if (this.state.position.bottom != null) {
          style.bottom = Math.round(this.state.position.bottom);
        }

        if (this.state.position.width) {
          style.width = this.state.position.width;
        }
      }

      return style;
    }
  }, {
    key: "prepareContentStyle",
    value: function prepareContentStyle() {
      var style = (0, _assign.default)({}, this.props.contentStyle);

      if (this.props.background != undefined) {
        (0, _assign.default)(style, {
          background: this.props.background
        });
      }

      if (this.props.padding != undefined) {
        (0, _assign.default)(style, {
          padding: this.props.padding
        });
      }

      if (this.props.height != undefined) {
        (0, _assign.default)(style, {
          height: this.props.height
        });
      }

      if (this.props.width != undefined) {
        (0, _assign.default)(style, {
          width: this.props.width
        });
      }

      var maxMinSize = (0, _getMinMaxSize.default)(this.props);
      (0, _assign.default)(style, maxMinSize);
      return style;
    }
  }, {
    key: "getTransitionStyle",
    value: function getTransitionStyle() {
      var state = this.state;
      var style = {};

      if (state.transitionEnterActive || state.transitionLeaveActive) {
        style.transitionDuration = state.transitionEnterActive ? "".concat(this.getFadeInDuration(), "ms") : "".concat(this.getFadeOutDuration(), "ms");
        style.transitionTimingFunction = state.transitionEnterActive ? this.getFadeInTransitionFunction() : this.getFadeOutTransitionFunction();
      }

      return style;
    }
  }, {
    key: "onShow",
    value: function onShow(event) {
      var _this3 = this;

      this.activeTargetNode = event.target;
      this.setState({
        renderTrigger: !this.state.renderTrigger
      }, function () {
        _this3.setPosition();

        _this3.setVisible(true);
      });
    }
  }, {
    key: "onHide",
    value: function onHide(event) {
      this.setVisible(false);
    }
  }, {
    key: "register",
    value: function register() {
      var _this4 = this;

      this.eventManager = this.getEventManager()({
        showEvent: (0, _normalizeEvent.default)(this.props.showEvent),
        hideEvent: (0, _normalizeEvent.default)(this.props.hideEvent),
        target: this.getTarget(),
        hideOnScroll: this.props.hideOnScroll,
        hideOnClickOutside: this.props.hideOnClickOutside,
        hideOnEscape: this.props.hideOnEscape,
        onShow: this.onShow,
        onHide: this.onHide,
        getShowDelay: function getShowDelay() {
          return _this4.props.showDelay;
        },
        getHideDelay: function getHideDelay() {
          return _this4.props.hideDelay;
        },
        getVisible: this.getVisible,
        getOverlayNode: this.getOverlayNode,
        getActiveTargetNode: this.getActiveTargetNode
      });
    }
  }, {
    key: "unregister",
    value: function unregister() {
      if (this.eventManager) {
        this.eventManager.unregister();
      }
    }
  }, {
    key: "getEventManager",
    value: function getEventManager() {
      return this.props.eventManager;
    }
  }, {
    key: "getTarget",
    value: function getTarget() {
      var target;
      var rootNode = this.getOverlayNode();

      if (this.props.target) {
        target = this.props.target;

        if (typeof target === 'function') {
          target = target(this.props, rootNode, this);
        }
      } else {
        if (rootNode) {
          target = rootNode.parentElement;
        }
      }

      return target;
    }
  }, {
    key: "setVisible",
    value: function setVisible(visible) {
      if (!this.isVisibleControlled()) {
        if (visible !== this.getVisible()) {
          this.handleVisibleChange(visible);
        }

        this.setState({
          visible: visible
        });
      }

      if (visible) {
        this.props.onShow();
      } else {
        this.props.onHide();
      }

      this.props.onVisibleChange(visible);
    }
  }, {
    key: "isVisibleControlled",
    value: function isVisibleControlled() {
      return this.props.visible != null;
    }
  }, {
    key: "getVisible",
    value: function getVisible() {
      return this.isVisibleControlled() ? this.props.visible : this.state.visible;
    }
  }, {
    key: "setPosition",
    value: function setPosition(callback) {
      this.setState(this.getPositionConfig(), callback);
    }
  }, {
    key: "getPositionConfig",
    value: function getPositionConfig() {
      var _this$props = this.props,
          constrainTo = _this$props.constrainTo,
          offset = _this$props.offset,
          syncWidth = _this$props.syncWidth;
      var positions = this.props.positions;
      var targetNode = this.getPositionTarget();
      var tooltipPositions = targetNode ? targetNode.getAttribute('data-tooltip-positions') : null;

      if (tooltipPositions) {
        positions = tooltipPositions.split(',').map(function (position) {
          return position && position.trim ? position.trim() : position;
        });
      }

      var normalizedPositions = Array.isArray(positions) ? positions : [positions];
      var newState = (0, _getPositionRelativeToElement.default)({
        showArrow: true,
        constrainTo: constrainTo,
        offset: offset,
        targetNode: targetNode,
        overlayNode: this.getOverlayNode(),
        positions: normalizedPositions,
        adjustOnPositionBottom: this.props.adjustOnPositionBottom,
        relativeToViewport: this.props.relativeToViewport,
        arrowSize: this.props.arrowSize
      });

      if (this.props.relativeToViewport && this.fixedNode) {
        var fixedRect = this.fixedNode.getBoundingClientRect();

        if (newState && newState.position) {
          var useTransform = this.props.useTransform;
          newState.position = {
            top: newState.position.top - (useTransform ? 0 : fixedRect.top),
            left: newState.position.left - (useTransform ? 0 : fixedRect.left)
          };

          if (syncWidth) {
            newState.position.width = newState.alignRegion.width;
          }
        }
      }

      return newState;
    }
  }, {
    key: "handleDocumentScroll",
    value: function handleDocumentScroll() {
      if (this.props.updatePositionOnScroll) {
        this.updateDomPosition();
      }
    }
  }, {
    key: "updateDomPosition",
    value: function updateDomPosition() {
      var positionConfig = this.getPositionConfig();

      if (this.rootNode && positionConfig) {
        var newPosition = positionConfig.position;

        if (newPosition.bottom !== undefined) {
          this.rootNode.style.bottom = "".concat(newPosition.bottom, "px");
        }

        if (this.props.useTransform) {
          var oldPosition = this.state.position || {
            top: 0,
            left: 0
          };
          this.rootNode.style.transform = "translate3d(".concat(Math.round(newPosition.left || oldPosition.left), "px, ").concat(Math.round(newPosition.top || oldPosition.top), "px, 0px)");
        } else {
          if (newPosition.top !== undefined) {
            this.rootNode.style.top = "".concat(Math.round(newPosition.top), "px");
          }

          this.rootNode.style.left = "".concat(Math.round(newPosition.left), "px");
        }
      }
    }
  }, {
    key: "getOverlayNode",
    value: function getOverlayNode() {
      return this.rootNode;
    }
  }, {
    key: "getActiveTargetNode",
    value: function getActiveTargetNode() {
      return this.activeTargetNode;
    }
  }, {
    key: "getPositionTarget",
    value: function getPositionTarget() {
      var target = this.getTarget();

      if (target instanceof Element) {
        return target;
      }

      return this.getActiveTargetNode();
    }
  }, {
    key: "handleVisibleChange",
    value: function handleVisibleChange(visible) {
      if (!this.props.fade) {
        return null;
      }

      if (visible) {
        this.setupEnterTransition();
      } else {
        this.setupLeaveTransition();
      }
    }
  }, {
    key: "setupEnterTransition",
    value: function setupEnterTransition() {
      var _this5 = this;

      this.props.onFadeInStart();
      this.setState({
        transitionEnter: true,
        transitionEnterActive: false,
        transitionLeave: false,
        transitionLeaveActive: false
      }, function () {
        setTimeout(function () {
          if (_this5.componentIsMounted) {
            _this5.setState({
              transitionEnterActive: true
            }, function () {
              _this5.props.onFadeInEnd();
            });
          }
        }, 16);
      });
    }
  }, {
    key: "setupLeaveTransition",
    value: function setupLeaveTransition() {
      var _this6 = this;

      this.props.onFadeOutStart();
      this.setState({
        transitionLeave: true,
        transitionLeaveActive: false,
        transitionEnter: false,
        transitionEnterActive: false
      }, function () {
        setTimeout(function () {
          if (_this6.componentIsMounted) {
            _this6.setState({
              transitionLeaveActive: true
            }, function () {
              setTimeout(function () {
                if (_this6.componentIsMounted) {
                  _this6.setState({
                    transitionLeave: false,
                    transitionLeaveActive: false
                  }, function () {
                    _this6.props.onFadeOutEnd();
                  });
                }
              }, _this6.getFadeOutDuration());
            });
          }
        }, 16);
      });
    }
  }, {
    key: "getFadeInDuration",
    value: function getFadeInDuration() {
      if (this.props.fadeInDuration) {
        return this.props.fadeInDuration;
      }

      return this.props.fadeDuration;
    }
  }, {
    key: "getFadeOutDuration",
    value: function getFadeOutDuration() {
      if (this.props.fadeOutDuration) {
        return this.props.fadeOutDuration;
      }

      return this.props.fadeDuration;
    }
  }, {
    key: "getFadeInTransitionFunction",
    value: function getFadeInTransitionFunction() {
      if (this.props.fadeInTransitionFunction) {
        return this.props.fadeInTransitionFunction;
      }

      return this.props.fadeTransitionFunction;
    }
  }, {
    key: "getFadeOutTransitionFunction",
    value: function getFadeOutTransitionFunction() {
      if (this.props.fadeOutTransitionFunction) {
        return this.props.fadeOutTransitionFunction;
      }

      return this.props.fadeTransitionFunction;
    }
  }, {
    key: "handleKeyDown",
    value: function handleKeyDown(event) {
      if (this.props.captureTabNavigation && event.key === 'Tab') {
        this.captureTabNavigation(event);
      }

      if (this.props.onKeyDown) {
        this.props.onKeyDown(event);
      }
    }
  }, {
    key: "captureTabNavigation",
    value: function captureTabNavigation(event) {
      var shiftKey = event.shiftKey;
      var nodes = (0, _getFocusableElements.default)(this.rootNode);

      if (!nodes.length) {
        return null;
      }

      var firstNode = nodes[0];
      var lastNode = nodes[nodes.length - 1];

      if (lastNode === event.target && !shiftKey) {
        firstNode.focus();
        event.preventDefault();
        event.stopPropagation();
      }

      if (firstNode === event.target && shiftKey) {
        lastNode.focus();
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }, {
    key: "show",
    value: function show() {
      this.setVisible(true);
    }
  }, {
    key: "hide",
    value: function hide() {
      this.setVisible(false);
    }
  }]);
  return InovuaOverlay;
}(_react.Component);

var emptyFn = function emptyFn() {};

InovuaOverlay.defaultProps = {
  captureTabNavigation: false,
  updatePositionOnScroll: false,
  zIndex: 100,
  theme: 'default',
  rootClassName: 'inovua-react-toolkit-overlay',
  background: null,
  padding: null,
  eventManager: _eventManager.default,
  target: null,
  showEvent: ['mouseenter'],
  hideEvent: ['mouseleave'],
  defaultVisible: false,
  arrow: true,
  arrowStyle: {},
  arrowSize: 11,
  showDelay: null,
  hideDelay: null,
  hideOnClickOutside: true,
  hideOnScroll: false,
  fade: false,
  fadeDuration: 300,
  fadeInDuration: 300,
  fadeOutDuration: 50,
  fadeTransitionFunction: 'ease',
  positions: _positionsMap.posiblePositions,
  constrainTo: true,
  offset: 10,
  rafOnMount: true,
  relativeToViewport: true,
  adjustOnPositionBottom: false,
  onVisibleChange: emptyFn,
  onShow: emptyFn,
  onHide: emptyFn,
  onFadeInStart: emptyFn,
  onFadeOutStart: emptyFn,
  onFadeInEnd: emptyFn,
  onFadeOutEnd: emptyFn
};
InovuaOverlay.propTypes = {
  shouldComponentUpdate: _propTypes.default.func,
  captureTabNavigation: _propTypes.default.bool,
  updatePositionOnScroll: _propTypes.default.bool,
  children: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),
  rootClassName: _propTypes.default.string,
  border: _propTypes.default.string,
  background: _propTypes.default.string,
  theme: _propTypes.default.string,
  zIndex: _propTypes.default.number,
  contentStyle: _propTypes.default.object,
  contentClassName: _propTypes.default.string,
  padding: _propTypes.default.number,
  height: _propTypes.default.number,
  width: _propTypes.default.number,
  minSize: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string, _propTypes.default.shape({
    height: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
    width: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
  })]),
  maxSize: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string, _propTypes.default.shape({
    height: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
    width: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
  })]),
  arrow: _propTypes.default.bool,
  arrowClassName: _propTypes.default.string,
  arrowStyle: _propTypes.default.object,
  arrowSize: _propTypes.default.number,
  visible: _propTypes.default.bool,
  visibleClassName: _propTypes.default.string,
  defaultVisible: _propTypes.default.bool,
  target: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.object, _propTypes.default.func]),
  eventManager: _propTypes.default.func,
  showEvent: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.string), _propTypes.default.string]),
  hideEvent: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.string), _propTypes.default.string]),
  showDelay: _propTypes.default.number,
  hideDelay: _propTypes.default.number,
  hideOnClickOutside: _propTypes.default.bool,
  hideOnScroll: _propTypes.default.bool,
  hideOnEscape: _propTypes.default.bool,
  useTransform: _propTypes.default.bool,
  fade: _propTypes.default.bool,
  fadeDuration: _propTypes.default.number,
  fadeInDuration: _propTypes.default.number,
  fadeOutDuration: _propTypes.default.number,
  fadeTransitionFunction: _propTypes.default.string,
  fadeInTransitionFunction: _propTypes.default.string,
  fadeOutTransitionFunction: _propTypes.default.string,
  constrainTo: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.object, _propTypes.default.func, _propTypes.default.bool]),
  positions: function positions(props, propName, componentName) {
    var positions = props[propName];

    if (typeof positions === 'string') {
      if (_positionsMap.posiblePositions.indexOf(positions) === -1) {
        return new Error("\nInvalid prop ".concat(propName, " suplied to ").concat(componentName, ".\nFollowing values are allowed: ").concat(_positionsMap.posiblePositions.join(', '), "\n"));
      }
    }
  },
  offset: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({
    x: _propTypes.default.number,
    y: _propTypes.default.number
  }), _propTypes.default.arrayOf(_propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({
    x: _propTypes.default.number,
    y: _propTypes.default.number
  })]))]),
  rafOnMount: _propTypes.default.bool,
  relativeToViewport: _propTypes.default.bool,
  adjustOnPositionBottom: _propTypes.default.bool,
  syncWidth: _propTypes.default.bool,
  onInitialPosition: _propTypes.default.func,
  onVisibleChange: _propTypes.default.func,
  onShow: _propTypes.default.func,
  onHide: _propTypes.default.func,
  onFadeInStart: emptyFn,
  onFadeOutStart: emptyFn,
  onFadeInEnd: emptyFn,
  onFadeOutEnd: emptyFn
};
var _default = InovuaOverlay;
exports.default = _default;
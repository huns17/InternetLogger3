/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _isMobile = _interopRequireDefault(require("../../../common/isMobile"));

var _cleanProps = _interopRequireDefault(require("../../../common/cleanProps"));

var _debounce = _interopRequireDefault(require("../../../common/debounce"));

var _join = _interopRequireDefault(require("../../../packages/join"));

var _Flex = require("../../Flex");

var _NotifyResize = require("../../NotifyResize");

var _InertialScroller = require("../../InertialScroller");

var _ua = require("../../../common/ua");

var _reactScrollContainerPro = _interopRequireDefault(require("../../../packages/react-scroll-container-pro"));

var _Arrow = _interopRequireDefault(require("./Arrow"));

var _getGlobal = require("../../../getGlobal");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var globalObject = (0, _getGlobal.getGlobal)();
var VIEW_STYLE_VERTICAL = {
  maxHeight: '100%'
};
var VIEW_STYLE_HORIZONTAL = {
  maxWidth: '100%'
};

var observe = function observe(targetNode, callback, cfg) {
  var config = cfg || {
    attributes: false,
    childList: true,
    subtree: true
  };
  var observer = new MutationObserver(callback);
  observer.observe(targetNode, config);
  return function () {
    observer.disconnect();
  };
};

var measureScrollSize = function measureScrollSize(node) {
  return {
    width: node.scrollWidth,
    height: node.scrollHeight
  };
};

var scrollerResizerProps = {
  useNativeIfAvailable: false,
  measureSize: measureScrollSize
};

var callAll = function callAll() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    fns.forEach(function (fn) {
      fn && fn.apply(void 0, args);
    });
  };
};

var pint = globalObject.parseInt;
var raf = globalObject.requestAnimationFrame;
var getCompStyle = globalObject.getComputedStyle;

var NO_SCROLLBARS = function NO_SCROLLBARS() {
  return false;
};

var InovuaArrowScroller = function (_Component) {
  (0, _inherits2.default)(InovuaArrowScroller, _Component);

  var _super = _createSuper(InovuaArrowScroller);

  function InovuaArrowScroller(props) {
    var _this;

    (0, _classCallCheck2.default)(this, InovuaArrowScroller);
    _this = _super.call(this, props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getScrollerNodeClientSize", function (node) {
      var result = {
        width: node.firstChild.offsetWidth,
        height: node.firstChild.offsetHeight
      };
      return result;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onScrollContainerDidMount", function (scrollContainer, domNode, notifyResizer) {
      _this._unobserve = observe(domNode, function () {
        if (notifyResizer && notifyResizer.checkResize) {
          notifyResizer.checkResize();
        }
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onScrollContainerWillUnmount", function () {
      if (_this._unobserve) {
        _this._unobserve();
      }
    });
    _this.scrollInfo = {
      scrollPos: 0,
      hasStartScroll: false,
      hasEndScroll: false,
      scrollerSize: {
        start: 0,
        end: 0
      }
    };
    _this.state = {
      scrolling: false,
      activeScroll: 0
    };
    _this.handleResize = (0, _debounce.default)(_this.handleResize.bind((0, _assertThisInitialized2.default)(_this)), 50, {
      leading: false,
      trailing: true
    });
    _this.updateScrollInfo = _this.updateScrollInfo.bind((0, _assertThisInitialized2.default)(_this));
    _this.rafUpdateScrollInfo = _this.rafUpdateScrollInfo.bind((0, _assertThisInitialized2.default)(_this));
    _this.onContainerScroll = _this.onContainerScroll.bind((0, _assertThisInitialized2.default)(_this));
    _this.strip = (0, _react.createRef)();

    _this.refScrollContainer = function (scrollContainer) {
      _this.scrollerTarget = scrollContainer;
    };

    _this.setRootRef = function (ref) {
      _this.root = ref;

      if (!_this.props.nativeScroll) {
        _this.scrollerTarget = _this.root;
      }
    };

    return _this;
  }

  (0, _createClass2.default)(InovuaArrowScroller, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      raf(function () {
        var name = _this2.getOffsetSizeName();

        _this2.scrollInfo.scrollerSize = {
          start: _this2.props.scroller === (true || 'auto') ? _this2.start[name] : null,
          end: _this2.props.scroller === (true || 'auto') ? _this2.end[name] : null
        };

        _this2.syncScroll({
          force: true
        });

        _this2.componentIsMounted = true;
        _this2.inertialManager = new _InertialScroller.InertialManager({
          arrowSelector: ".".concat(_this2.props.rootClassName, "__arrow"),
          node: _this2.root,
          viewNode: _this2.strip.current,
          setScrollPosition: function setScrollPosition() {
            return raf(function () {
              return _this2.setScrollPosition();
            });
          },
          enableMouseDrag: false
        });
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.componentIsMounted = false;

      if (this.inertialManager) {
        this.inertialManager.removeEventListeners();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var props = this.props;
      var useTransformOnScroll = props.useTransformOnScroll,
          nativeScroll = props.nativeScroll,
          vertical = props.vertical,
          rootClassName = props.rootClassName,
          rtl = props.rtl,
          theme = props.theme;
      var scrollInfo = this.scrollInfo;
      var scrollValue = rtl ? scrollInfo.scrollPos : -scrollInfo.scrollPos;
      var innerWrapperClassName = (0, _join.default)("".concat(rootClassName, "__inner-wrapper"), "".concat(rootClassName, "__inner-wrapper--direction-").concat(vertical ? 'column' : 'row'));
      var className = (0, _join.default)(props.className, rootClassName, !vertical && "".concat(rootClassName, "--direction-horizontal"), vertical && "".concat(rootClassName, "--direction-vertical"), rtl && "".concat(rootClassName, "--rtl"), nativeScroll && "".concat(rootClassName, "--native-scroll"), theme && "".concat(rootClassName, "--theme-").concat(theme));
      var transformValue;
      var moveStyle = {};

      if (useTransformOnScroll) {
        moveStyle.transform = 'translate3d(0px, 0px, 0px)';
      }

      if (vertical) {
        if (useTransformOnScroll) {
          moveStyle.transform = "translate3d(0px, ".concat(scrollValue, "px, 0px)");
        } else {
          moveStyle.top = scrollValue;
        }
      } else {
        if (useTransformOnScroll) {
          moveStyle.transform = "translate3d(".concat(scrollValue, "px, 0px, 0px)");
        } else {
          moveStyle.left = scrollValue;
        }
      }

      var resizer = _react.default.createElement(_NotifyResize.NotifyResize, {
        key: "resizer",
        notifyOnMount: true,
        onResize: this.handleResize,
        notifyResizeDelay: props.notifyResizeDelay
      });

      var children = [].concat((0, _toConsumableArray2.default)(_react.default.Children.toArray(props.children)), [resizer]);

      var content = _react.default.createElement(_Flex.Flex, _objectSpread(_objectSpread({
        key: "content",
        wrap: false
      }, props.childProps), {}, {
        className: innerWrapperClassName,
        ref: this.strip,
        children: children,
        style: nativeScroll ? null : moveStyle
      }));

      var finalChildren = [resizer, content, this.renderScroller(-1), this.renderScroller(1)];

      if (nativeScroll) {
        var scrollContainerProps = this.props.scrollContainerProps;
        var viewStyle = vertical ? VIEW_STYLE_VERTICAL : VIEW_STYLE_HORIZONTAL;

        if (scrollContainerProps && scrollContainerProps.viewStyle) {
          viewStyle = _objectSpread(_objectSpread({}, scrollContainerProps.viewStyle), viewStyle);
        }

        var style = {
          maxHeight: '100%'
        };
        var scrollerStyle;

        if (this.props.rtl) {
          viewStyle.direction = 'rtl';
          viewStyle.maxWidth = '';
          style.alignItems = 'flex-end';
          style.maxWidth = '100%';
          scrollerStyle = {
            alignItems: 'flex-end'
          };
        }

        var prevChildren = finalChildren;
        finalChildren = _react.default.createElement(_reactScrollContainerPro.default, {
          applyCSSContainOnScroll: false,
          style: style,
          scrollerStyle: scrollerStyle,
          emptyScrollOffset: 20,
          getScrollerNodeClientSize: this.props.rtl ? this.getScrollerNodeClientSize : null,
          className: "".concat(this.props.rootClassName, "__scroll-container"),
          shouldAllowScrollbars: NO_SCROLLBARS,
          dragToScroll: false,
          nativeScroll: scrollContainerProps ? scrollContainerProps.nativeScroll !== undefined ? scrollContainerProps.nativeScroll : false : false,
          viewStyle: viewStyle,
          ref: this.refScrollContainer,
          scrollerResizerProps: scrollerResizerProps,
          onDidMount: this.onScrollContainerDidMount,
          onWillUnmount: this.onScrollContainerWillUnmount,
          onResize: scrollContainerProps && scrollContainerProps.onResize ? callAll(scrollContainerProps.onResize, this.rafUpdateScrollInfo) : this.rafUpdateScrollInfo,
          children: prevChildren,
          onContainerScroll: this.onContainerScroll,
          theme: props.theme
        });

        if (this.props.rtl) {
          finalChildren = [finalChildren, resizer];
        }
      }

      return _react.default.createElement(_Flex.Flex, _objectSpread(_objectSpread({}, (0, _cleanProps.default)(props, InovuaArrowScroller.propTypes)), {}, {
        ref: this.setRootRef,
        className: className,
        alignItems: "start",
        children: finalChildren
      }));
    }
  }, {
    key: "renderScroller",
    value: function renderScroller(direction) {
      var _this3 = this;

      var _this$props = this.props,
          scroller = _this$props.scroller,
          vertical = _this$props.vertical,
          rootClassName = _this$props.rootClassName,
          nativeScroll = _this$props.nativeScroll;

      if (!scroller) {
        return null;
      }

      var arrowName = vertical ? direction == (this.props.rtl ? 1 : -1) ? 'up' : 'down' : direction == (this.props.rtl ? 1 : -1) ? 'left' : 'right';
      var scrollInfo = this.scrollInfo;
      var disabled = direction == -1 ? !scrollInfo.hasStartScroll : !scrollInfo.hasEndScroll;
      var arrowRootClassName = "".concat(rootClassName, "__arrow");
      var className = (0, _join.default)(arrowRootClassName, "".concat(arrowRootClassName, "--auto"), "".concat(arrowRootClassName, "--direction-").concat(arrowName), this.state.activeScroll == direction && "".concat(arrowRootClassName, "--active"), scroller === 'auto' && disabled && "".concat(arrowRootClassName, "--hidden"), scroller === 'auto' && !disabled && "".concat(arrowRootClassName, "--visible"), scroller === true && disabled && "".concat(arrowRootClassName, "--disabled"), nativeScroll && "".concat(arrowRootClassName, "--native-scroll"));
      var onClick = !disabled && this.props.scrollOnClick ? this.handleClick.bind(this, direction) : null;
      var onMouseDown = !disabled && (!this.props.scrollOnClick || _isMobile.default) ? this.startScroll.bind(this, direction) : null;
      var onMouseEnter = !disabled && this.props.scrollOnMouseEnter ? this.startMouseOverScroll.bind(this, direction) : null;
      var onMouseLeave = !this.props.scrollOnClick || _isMobile.default || this.props.scrollOnMouseEnter ? this.stopMouseOverScroll.bind(this, direction) : null;
      var onDoubleClick = !disabled ? this.handleScrollMax.bind(this, direction) : null;
      var scrollerName = direction == -1 ? 'start' : 'end';
      var domProps = {
        ref: function ref(_ref) {
          _this3[scrollerName] = _ref;
        },
        key: "scroller-".concat(direction),
        disabled: disabled,
        className: className,
        onClick: onClick,
        onDoubleClick: onDoubleClick,
        onMouseDown: !_isMobile.default ? onMouseDown : null,
        onTouchStart: _isMobile.default ? onMouseDown : null,
        onTouchEnd: _isMobile.default ? onMouseLeave : null,
        onMouseEnter: !_isMobile.default ? onMouseEnter : null,
        onMouseLeave: !_isMobile.default ? onMouseLeave : null,
        children: this.renderArrowIcon(arrowName)
      };
      var result;

      if (typeof this.props.renderScroller === 'function') {
        result = this.props.renderScroller({
          domProps: domProps,
          direction: direction
        });
      }

      if (result === undefined) {
        result = _react.default.createElement("div", _objectSpread({}, domProps));
      }

      return result;
    }
  }, {
    key: "renderArrowIcon",
    value: function renderArrowIcon(name) {
      var props = this.props;
      return _react.default.createElement(_Arrow.default, {
        name: name,
        size: props.arrowSize,
        height: props.arrowHeight,
        width: props.arrowWidth,
        className: "".concat(this.props.rootClassName, "__arrow-icon")
      });
    }
  }, {
    key: "getOffsetSizeName",
    value: function getOffsetSizeName() {
      return this.props.vertical ? 'offsetHeight' : 'offsetWidth';
    }
  }, {
    key: "getBorderAndPaddingSize",
    value: function getBorderAndPaddingSize() {
      var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.root;
      var side = arguments.length > 1 ? arguments[1] : undefined;
      var computedStyle = getCompStyle(node);
      var start;
      var end;

      if (this.props.vertical) {
        start = pint(computedStyle.borderTopWidth) + pint(computedStyle.paddingTop);
        end = pint(computedStyle.borderBottomWidth) + pint(computedStyle.paddingBottom);
        return start + end;
      } else {
        start = pint(computedStyle.borderLeftWidth) + pint(computedStyle.paddingLeft);
        end = pint(computedStyle.borderRightWidth) + pint(computedStyle.paddingRight);
      }

      return side ? side == 'start' ? start : end : start + end;
    }
  }, {
    key: "getSizeName",
    value: function getSizeName() {
      return this.props.vertical ? 'height' : 'width';
    }
  }, {
    key: "getAvailableSize",
    value: function getAvailableSize() {
      if (!this.root) {
        return null;
      }

      var size = this.availableSize || (this.props.nativeScroll ? this.props.vertical ? this.scrollerTarget.scrollTopMax : this.scrollerTarget.scrollLeftMax : this.root[this.getOffsetSizeName()] - this.getBorderAndPaddingSize());

      if (this.props.rtl && size < 0) {
        size = -size;
      }

      this.availableSize = size;
      return size;
    }
  }, {
    key: "getCurrentListSize",
    value: function getCurrentListSize() {
      if (!this.strip.current) {
        return null;
      }

      return this.currentListSize = this.currentListSize || this.strip.current[this.getOffsetSizeName()];
    }
  }, {
    key: "handleResize",
    value: function handleResize() {
      if (!this.componentIsMounted) {
        return;
      }

      delete this.currentListSize;
      delete this.availableSize;
      this.syncScroll({
        force: true
      });
    }
  }, {
    key: "handleScrollMax",
    value: function handleScrollMax(direction, event) {
      var _this4 = this;

      event.stopPropagation();
      event.preventDefault();
      var maxPos = direction == -1 ? 0 : this.scrollInfo.maxScrollPos;
      raf(function () {
        _this4.setScrollPosition(maxPos);
      });
    }
  }, {
    key: "handleClick",
    value: function handleClick(direction) {
      var offset = this.getAvailableSize();
      this.scrollBy(offset, direction);
    }
  }, {
    key: "stopScroll",
    value: function stopScroll() {
      globalObject.clearInterval(this.scrollInterval);
      this.setState({
        scrolling: false,
        activeScroll: 0
      });
    }
  }, {
    key: "rafUpdateScrollInfo",
    value: function rafUpdateScrollInfo() {
      raf(this.updateScrollInfo);
    }
  }, {
    key: "updateScrollInfo",
    value: function updateScrollInfo(count) {
      var _this5 = this;

      if (this.componentIsMounted === false) {
        return;
      }

      var availableSize = this.getAvailableSize();

      if (!availableSize) {
        if (!count || count < 5) {
          raf(function () {
            _this5.updateScrollInfo((count || 0) + 1);
          });
          return;
        }
      }

      var listSize = this.getCurrentListSize();
      var scrollInfo = Object.assign(this.scrollInfo, {
        availableSize: availableSize,
        listSize: listSize
      });

      if (this.props.nativeScroll) {
        if (this.scrollerTarget) {
          scrollInfo.maxScrollPos = this.props.vertical ? this.scrollerTarget.scrollTopMax : this.scrollerTarget.scrollLeftMax;
        }
      } else {
        if (listSize > availableSize) {
          scrollInfo.maxScrollPos = listSize - availableSize;
        } else {
          scrollInfo.maxScrollPos = 0;
        }
      }

      if (this.props.rtl && scrollInfo.maxScrollPos < 0) {
        scrollInfo.maxScrollPos = -scrollInfo.maxScrollPos;
      }

      scrollInfo.hasStartScroll = scrollInfo.scrollPos != 0;
      scrollInfo.hasEndScroll = scrollInfo.scrollPos < scrollInfo.maxScrollPos;
      var hasScroll = listSize > availableSize;

      if (hasScroll !== this.state.hasScroll) {
        this.props.onHasScrollChange(hasScroll);
      }

      this.setState({
        hasScroll: hasScroll
      });
    }
  }, {
    key: "startScroll",
    value: function startScroll(direction, event) {
      var _this6 = this;

      var eventName = _isMobile.default ? 'touchend' : 'mouseup';
      event.preventDefault();

      var mouseUpListener = function mouseUpListener() {
        _this6.stopScroll();

        globalObject.removeEventListener(eventName, mouseUpListener);
      };

      globalObject.addEventListener(eventName, mouseUpListener);
      this.scrollInterval = globalObject.setInterval(this.doScroll.bind(this, direction), this.props.scrollSpeed);
      this.setState({
        scrolling: true,
        activeScroll: direction
      });
    }
  }, {
    key: "onContainerScroll",
    value: function onContainerScroll(_ref2) {
      var scrollTop = _ref2.scrollTop,
          scrollLeft = _ref2.scrollLeft;
      this.setScrollPosition(this.props.vertical ? scrollTop : scrollLeft, {
        skip: true
      });
    }
  }, {
    key: "startMouseOverScroll",
    value: function startMouseOverScroll(direction, event) {
      event.preventDefault();
      globalObject.clearInterval(this.mouseOverScrollInterval);
      this.mouseOverScrollInterval = globalObject.setInterval(this.doScroll.bind(this, direction), this.props.mouseoverScrollSpeed);
      this.setState({
        scrolling: true,
        activeScroll: direction
      });
    }
  }, {
    key: "stopMouseOverScroll",
    value: function stopMouseOverScroll() {
      this.stopScroll();
      globalObject.clearInterval(this.mouseOverScrollInterval);
    }
  }, {
    key: "setScrollPosition",
    value: function setScrollPosition(scrollPos) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          force = _ref3.force,
          skip = _ref3.skip;

      if (!this.componentIsMounted) {
        return;
      }

      var scrollInfo = this.scrollInfo;

      if (scrollPos > scrollInfo.maxScrollPos) {
        scrollPos = scrollInfo.maxScrollPos;
      }

      if (scrollPos < 0) {
        scrollPos = 0;
      }

      if (scrollPos === scrollInfo.scrollPos && force !== true) {
        return null;
      }

      Object.assign(scrollInfo, {
        hasStartScroll: scrollPos !== 0,
        hasEndScroll: scrollPos < scrollInfo.maxScrollPos,
        scrollPos: scrollPos
      });

      if (!skip && this.props.nativeScroll && this.scrollerTarget) {
        if (this.props.vertical) {
          this.scrollerTarget.scrollTop = scrollPos;
        } else {
          this.scrollerTarget.scrollLeft = scrollPos;
        }
      }

      this.setState({});
    }
  }, {
    key: "syncScroll",
    value: function syncScroll() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          force = _ref4.force;

      this.updateScrollInfo();
      this.doScroll(0, null, {
        force: force
      });
    }
  }, {
    key: "scrollIntoView",
    value: function scrollIntoView(domNode) {
      var rootNode = this.root;

      if (!domNode || !rootNode) {
        return;
      }

      var rect = domNode.getBoundingClientRect();
      var mainRect = rootNode.getBoundingClientRect();
      var vertical = this.props.vertical;
      var startSideName = vertical ? 'top' : 'left';
      var endSideName = vertical ? 'bottom' : 'right';
      var startDiff = rect[startSideName] - (mainRect[startSideName] + this.getBorderAndPaddingSize(undefined, 'start'));
      var endDiff = rect[endSideName] - (mainRect[endSideName] - this.getBorderAndPaddingSize(undefined, 'end'));
      var scrollIntoViewOffset = this.props.scrollIntoViewOffset;

      if (startDiff < 0) {
        this.doScroll(-startDiff + scrollIntoViewOffset, -1);
      } else if (endDiff > 0) {
        this.doScroll(endDiff + scrollIntoViewOffset, 1);
      }
    }
  }, {
    key: "doScroll",
    value: function doScroll(direction, step) {
      var _this7 = this;

      var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          force = _ref5.force;

      var scrollInfo = this.scrollInfo;
      var newScrollPos = scrollInfo.scrollPos + direction * (step || this.props.scrollStep);
      raf(function () {
        _this7.setScrollPosition(newScrollPos, {
          force: force
        });
      });
    }
  }, {
    key: "scrollBy",
    value: function scrollBy(offset, direction) {
      var _this8 = this;

      var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          force = _ref6.force;

      var scrollInfo = this.scrollInfo;
      var newScrollPos = scrollInfo.scrollPos + direction * offset;
      raf(function () {
        _this8.setScrollPosition(newScrollPos, {
          force: force
        });
      });
    }
  }]);
  return InovuaArrowScroller;
}(_react.Component);

var emptyFn = function emptyFn() {};

InovuaArrowScroller.defaultProps = {
  rootClassName: 'inovua-react-toolkit-arrow-scroller',
  scroller: 'auto',
  scrollStep: 15,
  mouseoverScrollSpeed: 40,
  scrollSpeed: 10,
  scrollSpringConfig: {
    stiffness: 370,
    damping: 60
  },
  scrollIntoViewOffset: 1,
  vertical: false,
  scrollOnClick: false,
  nativeScroll: !_ua.IS_IE,
  scrollOnMouseEnter: true,
  rtl: false,
  useTransformOnScroll: false,
  onHasScrollChange: emptyFn,
  theme: 'default-light'
};
InovuaArrowScroller.propTypes = {
  arrowSize: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({
    width: _propTypes.default.number,
    height: _propTypes.default.number
  })]),
  theme: _propTypes.default.string,
  scrollOnClick: _propTypes.default.bool,
  childProps: _propTypes.default.object,
  scrollOnMouseEnter: _propTypes.default.bool,
  vertical: _propTypes.default.bool,
  notifyResizeDelay: _propTypes.default.number,
  scrollStep: _propTypes.default.number,
  scrollSpeed: _propTypes.default.number,
  mouseoverScrollSpeed: _propTypes.default.number,
  scrollSpringConfig: _propTypes.default.shape({
    stiffness: _propTypes.default.number,
    damping: _propTypes.default.number
  }),
  nativeScroll: _propTypes.default.bool,
  scrollIntoViewOffset: _propTypes.default.number,
  scroller: _propTypes.default.oneOf(['auto', false, true]),
  rootClassName: _propTypes.default.string,
  rtl: _propTypes.default.bool,
  scrollContainerProps: _propTypes.default.object,
  useTransformOnScroll: _propTypes.default.bool,
  onHasScrollChange: _propTypes.default.func,
  renderScroller: _propTypes.default.func
};
var _default = InovuaArrowScroller;
exports.default = _default;
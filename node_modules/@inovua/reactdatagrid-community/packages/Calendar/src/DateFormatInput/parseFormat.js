/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assign = _interopRequireDefault(require("../../../../common/assign"));

var _formats = _interopRequireDefault(require("./formats"));

var SUGGESTIONS = {
  Y: ['YYYY', 'YY'],
  M: ['MM'],
  D: ['DD'],
  H: ['HH'],
  h: ['hh'],
  k: ['kk'],
  m: ['mm'],
  s: ['ss']
};

var _default = function _default(format) {
  var index = 0;
  var positionIndex = 0;
  var suggestions;
  var suggestionMatch;
  var positions = [];
  var matches = [];

  while (index < format.length) {
    var char = format[index];
    var match = _formats.default[char];
    var matchObject = void 0;
    suggestionMatch = null;
    suggestions = SUGGESTIONS[char];

    if (!match && !suggestions) {
      positions[positionIndex] = char;
      matches.push(char);
    } else {
      if (suggestions && suggestions.length) {
        suggestionMatch = suggestions.filter(function (s) {
          return format.substr(index, s.length) == s;
        })[0];
      }

      if (!suggestionMatch) {
        if (!_formats.default[char]) {
          console.warn("Format ".concat(char, " is not supported yet!"));

          if (suggestions) {
            console.warn("Use one of [\"".concat(suggestions.join(','), "\"]"));
          }

          positions[positionIndex] = char;
          matches.push(char);
        } else {
          var currentFormat = _formats.default[char];
          var start = positionIndex;
          var end = positionIndex + (currentFormat.length || 1) - 1;
          matchObject = (0, _assign.default)({}, currentFormat, {
            format: char,
            start: start,
            end: end
          });

          for (; start <= end; start++) {
            positions[positionIndex] = matchObject;
            positionIndex++;
          }

          index++;
          matches.push(matchObject);
          continue;
        }
      } else {
        matchObject = (0, _assign.default)({}, _formats.default[suggestionMatch], {
          format: suggestionMatch,
          start: positionIndex
        });
        matches.push(matchObject);
        var endIndex = positionIndex + suggestionMatch.length;
        matchObject.end = endIndex - 1;

        while (positionIndex < endIndex) {
          positions[positionIndex] = matchObject;
          positionIndex++;
          index++;
        }

        continue;
      }
    }

    positionIndex++;
    index++;
  }

  return {
    positions: positions,
    matches: matches
  };
};

exports.default = _default;
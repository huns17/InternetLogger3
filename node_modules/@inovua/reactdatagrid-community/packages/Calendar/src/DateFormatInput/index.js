/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactClass = _interopRequireDefault(require("../../../react-class"));

var _throttle = _interopRequireDefault(require("../../../../common/throttle"));

var _assign = _interopRequireDefault(require("../../../../common/assign"));

var _join = _interopRequireDefault(require("../../../../common/join"));

var _TimeInput = require("../TimeInput");

var _toMoment2 = _interopRequireDefault(require("../toMoment"));

var _parseFormat2 = _interopRequireDefault(require("./parseFormat"));

var _forwardTime = _interopRequireDefault(require("../utils/forwardTime"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var emptyFn = function emptyFn() {};

var BACKWARDS = {
  Backspace: 1,
  ArrowUp: 1,
  ArrowDown: 1,
  PageUp: 1,
  PageDown: 1
};

var DateFormatInput = function (_Component) {
  (0, _inherits2.default)(DateFormatInput, _Component);

  var _super = _createSuper(DateFormatInput);

  function DateFormatInput(props) {
    var _this;

    (0, _classCallCheck2.default)(this, DateFormatInput);
    _this = _super.call(this, props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "componentDidUpdate", function (prevProps) {
      if (_this.props.value !== undefined && _this.caretPos && _this.isFocused()) {
        _this.setCaretPosition(_this.caretPos);
      }

      var _this$getMinMax = _this.getMinMax(prevProps),
          prevMinDate = _this$getMinMax.minDate,
          prevMaxDate = _this$getMinMax.maxDate;

      var _this$getMinMax2 = _this.getMinMax(_this.props),
          currentMinDate = _this$getMinMax2.minDate,
          currentMaxDate = _this$getMinMax2.maxDate;

      if (prevMinDate !== currentMinDate) {
        _this.setState({
          minDate: currentMinDate
        });
      }

      if (prevMaxDate !== currentMaxDate) {
        _this.setState({
          maxDate: currentMaxDate
        });
      }
    });

    var _parseFormat = (0, _parseFormat2.default)(props.dateFormat),
        positions = _parseFormat.positions,
        matches = _parseFormat.matches;

    var defaultValue = props.defaultValue || Date.now();
    var delay = props.changeDelay;
    _this.throttleSetValue = delay == -1 ? _this.setValue : (0, _throttle.default)(_this.setValue, delay);

    var _this$getMinMax3 = _this.getMinMax(props),
        minDate = _this$getMinMax3.minDate,
        maxDate = _this$getMinMax3.maxDate;

    _this.state = {
      positions: positions,
      matches: matches,
      propsValue: props.value !== undefined,
      value: defaultValue,
      minDate: minDate,
      maxDate: maxDate
    };
    _this.dateFormatInputRef = (0, _react.createRef)();
    return _this;
  }

  (0, _createClass2.default)(DateFormatInput, [{
    key: "getMinMax",
    value: function getMinMax(props) {
      props = props || this.props;
      var minDate = null;

      if (props.minDate) {
        minDate = this.toMoment(props.minDate, props);
      }

      var maxDate = null;

      if (props.maxDate) {
        maxDate = this.toMoment(props.maxDate, props);
      }

      return {
        minDate: minDate,
        maxDate: maxDate
      };
    }
  }, {
    key: "toMoment",
    value: function toMoment(value, props) {
      props = props || this.props;
      return (0, _toMoment2.default)(value, {
        locale: props.locale,
        dateFormat: props.dateFormat === undefined ? this.props.dateFormat : props.dateFormat
      });
    }
  }, {
    key: "render",
    value: function render() {
      var props = this.props;
      var value = this.state.propsValue ? props.value : this.state.value;
      var displayValue = this.displayValue = this.toMoment(value).format(props.dateFormat);
      var className = (0, _join.default)(props.className, props.rootClassName, "".concat(props.rootClassName, "--theme-").concat(props.theme));
      var inputProps = (0, _assign.default)({}, props);
      delete inputProps.changeDelay;
      delete inputProps.date;
      delete inputProps.dateFormat;
      delete inputProps.isDateInput;
      delete inputProps.maxDate;
      delete inputProps.minDate;
      delete inputProps.stopPropagation;
      delete inputProps.updateOnWheel;
      delete inputProps.theme;
      delete inputProps.rootClassName;

      if (typeof props.cleanup == 'function') {
        props.cleanup(inputProps);
      }

      return _react.default.createElement("input", _objectSpread(_objectSpread({}, inputProps), {}, {
        ref: this.dateFormatInputRef,
        defaultValue: undefined,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        value: displayValue,
        onKeyDown: this.onKeyDown,
        onWheel: this.onWheel,
        onChange: this.onChange,
        className: className
      }));
    }
  }, {
    key: "focus",
    value: function focus() {
      this.dateFormatInputRef.current.focus();
    }
  }, {
    key: "onFocus",
    value: function onFocus(event) {
      if (this.props.onFocus) {
        this.props.onFocus(event);
      }

      this.setState({
        focused: true
      });
    }
  }, {
    key: "onBlur",
    value: function onBlur(event) {
      if (this.props.onBlur) {
        this.props.onBlur(event);
      }

      this.setState({
        focused: false
      });
    }
  }, {
    key: "isFocused",
    value: function isFocused() {
      return this.state.focused;
    }
  }, {
    key: "onChange",
    value: function onChange(event) {
      event.stopPropagation();
    }
  }, {
    key: "onDirection",
    value: function onDirection(dir) {
      var event = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.onKeyDown({
        key: dir > 0 ? 'ArrowUp' : 'ArrowDown',
        type: event.type || 'unknown',
        stopPropagation: typeof event.stopPropagation == 'function' ? function () {
          return event.stopPropagation();
        } : emptyFn,
        preventDefault: typeof event.preventDefault == 'function' ? function () {
          return event.preventDefault();
        } : emptyFn
      });
    }
  }, {
    key: "onWheel",
    value: function onWheel(event) {
      if (this.props.updateOnWheel && this.isFocused()) {
        this.onDirection(-event.deltaY, event);
      }

      if (this.props.onWheel) {
        this.props.onWheel(event);
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      var _this2 = this;

      var props = this.props;
      var key = event.key,
          type = event.type,
          which = event.which;

      if (key !== 'Unidentified' && which && which >= 65 && which <= 90) {
        key = ' ';
      }

      if (key != ' ' && key * 1 == key) {
        key = 'Unidentified';
      }

      if (props.stopPropagation) {
        event.stopPropagation();
      }

      var range = this.getSelectedRange();
      var selectedValue = this.getSelectedValue(range);
      var value = this.displayValue;
      var _this$state = this.state,
          positions = _this$state.positions,
          matches = _this$state.matches;
      var valueStr = "".concat(value);
      var currentPosition = positions[range.start];

      if (typeof currentPosition == 'string') {
        currentPosition = positions[range.start + (key in BACKWARDS ? -1 : 1)];
      }

      if (!currentPosition) {
        currentPosition = positions[range.start - 1];
      }

      if (props.onKeyDown && type == 'keydown') {
        if (props.onKeyDown(event, currentPosition) === false) {
          this.caretPos = range;
          return;
        }
      }

      var keyName = key;

      if (key == 'ArrowUp' || key == 'ArrowDown') {
        keyName = 'Arrow';
      }

      var handlerName = "handle".concat(keyName);
      var preventDefault;
      var newValue;
      var newCaretPos;

      if (currentPosition && currentPosition[handlerName]) {
        var returnValue = currentPosition[handlerName](currentPosition, {
          range: range,
          selectedValue: selectedValue,
          value: value,
          positions: positions,
          currentValue: valueStr.substring(currentPosition.start, currentPosition.end + 1),
          matches: matches,
          event: event,
          key: key,
          input: this.getInput(),
          setCaretPosition: function setCaretPosition() {
            return _this2.setCaretPosition.apply(_this2, arguments);
          }
        });
        this.caretPos = range;

        if (returnValue && returnValue.value !== undefined) {
          newValue = valueStr.substring(0, currentPosition.start) + returnValue.value + valueStr.substring(currentPosition.end + 1);
          newCaretPos = returnValue.caretPos || range;

          if (newCaretPos === true) {
            newCaretPos = {
              start: currentPosition.start,
              end: currentPosition.end + 1
            };
          }

          preventDefault = returnValue.preventDefault !== false;
        }
      }

      if (preventDefault || key == 'Backspace' || key == 'Delete' || key == ' ') {
        if (!preventDefault) {
          this.setCaretPosition(this.caretPos = {
            start: range.start + (key == 'Backspace' ? -1 : 1)
          });
        }

        preventDefault = true;
      }

      var config = {
        currentPosition: currentPosition,
        preventDefault: preventDefault,
        event: event,
        value: newValue,
        stop: false
      };

      if (this.props.afterKeyDown && type == 'keydown') {
        this.props.afterKeyDown(config);
      }

      if (!config.stop && newCaretPos !== undefined) {
        var updateCaretPos = function updateCaretPos() {
          return _this2.setCaretPosition(newCaretPos);
        };

        this.caretPos = newCaretPos;
        this.setStateValue(newValue, updateCaretPos, {
          key: key,
          oldValue: valueStr,
          currentPosition: currentPosition
        });
      }

      if (config.preventDefault) {
        event.preventDefault();
      }
    }
  }, {
    key: "getInput",
    value: function getInput() {
      return this.dateFormatInputRef.current;
    }
  }, {
    key: "setCaretPosition",
    value: function setCaretPosition(pos) {
      var dom = this.getInput();

      if (dom) {
        (0, _TimeInput.setCaretPosition)(dom, pos);
      }
    }
  }, {
    key: "format",
    value: function format(mom) {
      var _format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.dateFormat;

      return mom.format(_format);
    }
  }, {
    key: "setStateValue",
    value: function setStateValue(value, callback, _ref) {
      var key = _ref.key,
          oldValue = _ref.oldValue,
          currentPosition = _ref.currentPosition;
      var dateMoment = this.toMoment(value);

      if (!dateMoment.isValid()) {
        var dir = key == 'ArrowUp' || key == 'PageUp' ? 1 : -1;

        if (currentPosition.format == 'MM') {
          dateMoment = this.toMoment(oldValue).add(dir, 'month');
        } else {
          dateMoment = dir > 0 ? this.toMoment(oldValue).date(1) : this.toMoment(oldValue).endOf('month');
        }

        if (!dateMoment.isValid()) {
          return;
        }

        value = this.format(dateMoment);
      }

      var _this$state2 = this.state,
          minDate = _this$state2.minDate,
          maxDate = _this$state2.maxDate;

      if (minDate && dateMoment.isBefore(minDate)) {
        var clone = this.toMoment(dateMoment);
        dateMoment = (0, _forwardTime.default)(clone, this.toMoment(minDate));

        if (dateMoment.isBefore(minDate)) {
          dateMoment = this.toMoment(minDate);
        }

        value = this.format(dateMoment);
      }

      if (maxDate && dateMoment.isAfter(maxDate)) {
        var _clone = this.toMoment(dateMoment);

        dateMoment = (0, _forwardTime.default)(_clone, this.toMoment(maxDate));

        if (dateMoment.isAfter(maxDate)) {
          dateMoment = this.toMoment(maxDate);
        }

        value = this.format(dateMoment);
      }

      this.setState({
        value: value,
        propsValue: false
      }, typeof callback == 'function' && callback);

      if (this.props.onChange) {
        this.throttleSetValue(value, dateMoment);
      }
    }
  }, {
    key: "setValue",
    value: function setValue(value, dateMoment) {
      if (this.props.value === undefined) {
        this.setState({
          value: value,
          propsValue: false
        });
      } else {
        this.setState({
          propsValue: true,
          value: undefined
        });
      }

      if (this.props.onChange) {
        this.props.onChange(value, {
          dateMoment: dateMoment || this.toMoment(value)
        });
      }
    }
  }, {
    key: "getSelectedRange",
    value: function getSelectedRange() {
      var dom = this.getInput();
      return {
        start: (0, _TimeInput.getSelectionStart)(dom),
        end: (0, _TimeInput.getSelectionEnd)(dom)
      };
    }
  }, {
    key: "getSelectedValue",
    value: function getSelectedValue(range) {
      range = range || this.getSelectedRange();
      var value = this.displayValue;
      return value.substring(range.start, range.end);
    }
  }]);
  return DateFormatInput;
}(_reactClass.default);

exports.default = DateFormatInput;
DateFormatInput.defaultProps = {
  rootClassName: 'inovua-react-toolkit-calendar__input',
  theme: 'default',
  isDateInput: true,
  stopPropagation: true,
  updateOnWheel: true,
  changeDelay: 100
};
DateFormatInput.propTypes = {
  isDateInput: _propTypes.default.bool,
  rootClassName: _propTypes.default.string,
  theme: _propTypes.default.string,
  stopPropagation: _propTypes.default.bool,
  updateOnWheel: _propTypes.default.bool,
  dateFormat: _propTypes.default.string.isRequired,
  value: function value(props, propName) {
    if (props[propName] !== undefined) {}
  }
};
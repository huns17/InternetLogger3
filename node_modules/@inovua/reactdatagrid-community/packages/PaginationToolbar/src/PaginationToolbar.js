/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasPrevPage = exports.hasNextPage = exports.getSkipForPage = exports.getPageCount = exports.getCurrentPage = exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _autoBind = _interopRequireDefault(require("../../../packages/react-class/autoBind"));

var _NumericInput = _interopRequireDefault(require("../../NumericInput"));

var _ComboBox = _interopRequireDefault(require("../../ComboBox"));

var _ToolBar = _interopRequireDefault(require("../../ToolBar"));

var _Separator = _interopRequireDefault(require("../../ToolBar/Separator"));

var _reactCleanProps = _interopRequireDefault(require("../../../packages/react-clean-props"));

var _shouldComponentUpdate2 = _interopRequireDefault(require("../../../packages/shouldComponentUpdate"));

var _join = _interopRequireDefault(require("../../../packages/join"));

var _PaginationIcon = _interopRequireDefault(require("./PaginationIcon"));

var _getIcons = require("./getIcons");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var stopPropagation = function stopPropagation(e) {
  return e.stopPropagation();
};

var emptyObject = {};
var PAGE_SIZES = [{
  value: 5
}, {
  value: 10
}, {
  value: 20
}, {
  value: 25
}, {
  value: 40
}, {
  value: 50
}, {
  value: 100
}];
var ICONS = {
  FIRST_PAGE: _getIcons.FIRST_PAGE,
  LAST_PAGE: _getIcons.LAST_PAGE,
  PREV_PAGE: _getIcons.PREV_PAGE,
  NEXT_PAGE: _getIcons.NEXT_PAGE,
  REFRESH: _getIcons.REFRESH
};
var CLASS_NAME = 'inovua-react-pagination-toolbar';

var SPACER = _react.default.createElement("div", {
  className: "".concat(CLASS_NAME, "__spacer")
});

var getPageCount = function getPageCount(_ref) {
  var count = _ref.count,
      limit = _ref.limit;
  return Math.ceil(count / limit);
};

exports.getPageCount = getPageCount;

var getSkipForPage = function getSkipForPage(_ref2) {
  var page = _ref2.page,
      limit = _ref2.limit;
  return Math.max(0, limit * (page - 1));
};

exports.getSkipForPage = getSkipForPage;

var getCurrentPage = function getCurrentPage(_ref3) {
  var skip = _ref3.skip,
      limit = _ref3.limit;
  return Math.floor(skip / limit) + 1;
};

exports.getCurrentPage = getCurrentPage;

var hasNextPage = function hasNextPage(_ref4) {
  var skip = _ref4.skip,
      limit = _ref4.limit,
      count = _ref4.count;
  return getCurrentPage({
    skip: skip,
    limit: limit
  }) < getPageCount({
    count: count,
    limit: limit
  });
};

exports.hasNextPage = hasNextPage;

var hasPrevPage = function hasPrevPage(_ref5) {
  var skip = _ref5.skip,
      limit = _ref5.limit;
  return getCurrentPage({
    skip: skip,
    limit: limit
  }) > 1;
};

exports.hasPrevPage = hasPrevPage;

var InovuaPaginationToolbar = function (_React$Component) {
  (0, _inherits2.default)(InovuaPaginationToolbar, _React$Component);

  var _super = _createSuper(InovuaPaginationToolbar);

  function InovuaPaginationToolbar(props) {
    var _this;

    (0, _classCallCheck2.default)(this, InovuaPaginationToolbar);
    _this = _super.call(this, props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "componentDidUpdate", function (prevProps) {
      var skip = _this.getSkip(prevProps);

      var limit = _this.getLimit(prevProps);

      var pageCount = getPageCount({
        count: prevProps.totalCount,
        limit: limit
      });
      var currentPage = Math.min(pageCount, getCurrentPage({
        skip: skip,
        limit: limit
      }));

      var nextSkip = _this.getSkip(_this.props);

      var nextLimit = _this.getLimit(_this.props);

      var nextPageCount = getPageCount({
        count: _this.props.totalCount,
        limit: nextLimit
      });
      var nextCurrentPage = Math.min(nextPageCount, getCurrentPage({
        skip: nextSkip,
        limit: nextLimit
      }));

      if (prevProps.totalCount !== _this.props.totalCount || currentPage !== nextCurrentPage) {
        _this.forceUpdate(function () {
          _this.setCurrentPageInputValue(nextCurrentPage, _this.props);
        });
      }
    });
    (0, _autoBind.default)((0, _assertThisInitialized2.default)(_this));
    _this.state = {
      skip: props.defaultSkip,
      limit: props.defaultLimit
    };
    _this.ACTIONS = {
      REFRESH: _this.refresh,
      FIRST_PAGE: _this.gotoFirstPage,
      LAST_PAGE: _this.gotoLastPage,
      PREV_PAGE: _this.gotoPrevPage,
      NEXT_PAGE: _this.gotoNextPage
    };

    _this.refNumberInput = function (cmp) {
      _this.numberInput = cmp;
    };

    return _this;
  }

  (0, _createClass2.default)(InovuaPaginationToolbar, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      return (0, _shouldComponentUpdate2.default)(this, nextProps, nextState);
    }
  }, {
    key: "getSkip",
    value: function getSkip() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      return props.skip === undefined ? this.state.skip : props.skip;
    }
  }, {
    key: "getLimit",
    value: function getLimit() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      return props.limit === undefined ? this.state.limit : props.limit;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          totalCount = _this$props.totalCount,
          theme = _this$props.theme,
          rtl = _this$props.rtl,
          remotePagination = _this$props.remotePagination,
          rootClassName = _this$props.rootClassName,
          changeButtonStyles = _this$props.changeButtonStyles;
      var skip = this.getSkip();
      var limit = this.getLimit();
      var skipLimitCount = {
        skip: skip,
        limit: limit,
        count: totalCount
      };
      var currentPage = getCurrentPage(skipLimitCount);
      var pageCount = getPageCount(skipLimitCount);
      var firstPage = this.renderIcon('FIRST_PAGE', currentPage <= 1);
      var lastPage = this.renderIcon('LAST_PAGE', currentPage >= pageCount);
      var prevPage = this.renderIcon('PREV_PAGE', !hasPrevPage(skipLimitCount));
      var nextPage = this.renderIcon('NEXT_PAGE', !hasNextPage(skipLimitCount));
      var refresh = remotePagination ? this.renderIcon('REFRESH', false) : null;
      var start = totalCount ? skip + 1 : 0;
      var end = Math.min(skip + limit, totalCount);
      var className = (0, _join.default)(this.props.className, CLASS_NAME, theme && "".concat(CLASS_NAME, "--theme-").concat(theme), "".concat(CLASS_NAME, "--").concat(rtl ? 'rtl' : 'ltr'), this.props.bordered && "".concat(CLASS_NAME, "--bordered"));
      var combo = this.renderPageSizeCombo();
      var currentPageInput = this.renderCurrentPageInput({
        pageCount: pageCount,
        currentPage: currentPage
      });

      var domProps = _objectSpread(_objectSpread({}, (0, _reactCleanProps.default)(this.props, InovuaPaginationToolbar.propTypes)), {}, {
        className: className,
        theme: theme
      });

      var result;

      if (this.props.renderToolbar) {
        result = this.props.renderToolbar(domProps, {
          gotoFirstPageIcon: firstPage,
          gotoLastPageIcon: lastPage,
          gotoPrevPageIcon: prevPage,
          gotoNextPageIcon: nextPage,
          refreshIcon: refresh,
          pageSizeCombo: combo,
          start: start,
          end: end,
          totalCount: totalCount,
          currentPageInput: currentPageInput
        });

        if (result !== undefined) {
          return result;
        }
      }

      return _react.default.createElement(_ToolBar.default, _objectSpread(_objectSpread({}, domProps), {}, {
        useTransformOnScroll: false,
        onKeyDown: stopPropagation,
        rtl: rtl
      }), _react.default.createElement("div", {
        className: "".concat(CLASS_NAME, "__region")
      }, firstPage, prevPage, _react.default.createElement("span", {
        className: "".concat(CLASS_NAME, "__page-text")
      }, this.props.pageText), ' ', currentPageInput, " ", this.props.ofText, ' ', _react.default.createElement("span", {
        className: "".concat(CLASS_NAME, "__page-count-text"),
        style: {
          minWidth: Math.max("".concat(pageCount).length * 10, 25)
        }
      }, ' ' + (pageCount.toLocaleString ? pageCount.toLocaleString() : pageCount)), nextPage, lastPage, _react.default.createElement(_Separator.default, null), _react.default.createElement("span", {
        className: "".concat(CLASS_NAME, "__per-page-text")
      }, this.props.pageSizes === false ? null : this.props.perPageText), ' ', combo, this.props.pageSizes !== false && refresh ? _react.default.createElement(_Separator.default, null) : null, refresh), SPACER, _react.default.createElement("div", {
        className: "".concat(CLASS_NAME, "__region")
      }, this.props.showingText, ' ', start.toLocaleString ? start.toLocaleString() : start, " -", ' ', end.toLocaleString ? end.toLocaleString() : end, " ", this.props.ofText, ' ', totalCount.toLocaleString ? totalCount.toLocaleString() : totalCount));
    }
  }, {
    key: "renderCurrentPageInput",
    value: function renderCurrentPageInput(_ref6) {
      var pageCount = _ref6.pageCount,
          currentPage = _ref6.currentPage;
      var inputProps = {
        updateOnArrowKeys: false,
        className: "".concat(CLASS_NAME, "__current-page"),
        onBlur: this.onBlur,
        ref: this.refNumberInput,
        defaultValue: currentPage,
        currentPage: currentPage,
        onChange: this.onNumberInputChange,
        enableClearButton: false,
        allowFloat: false,
        allowNegative: false,
        rtl: this.props.rtl,
        minValue: 1,
        maxValue: pageCount,
        style: {
          minWidth: 70
        },
        size: "".concat(pageCount).length,
        theme: this.props.theme
      };
      var result;

      if (this.props.renderCurrentPageInput) {
        result = this.props.renderCurrentPageInput(inputProps);
      }

      if (result === undefined) {
        delete inputProps.currentPage;
        result = _react.default.createElement(_NumericInput.default, _objectSpread({}, inputProps));
      }

      return result;
    }
  }, {
    key: "renderPageSizeCombo",
    value: function renderPageSizeCombo() {
      var _comboProps;

      if (this.props.pageSizes === false) {
        return null;
      }

      var limit = this.getLimit();
      var comboProps = (_comboProps = {
        shadow: false,
        style: {
          minWidth: 70,
          width: 70
        },
        className: "".concat(CLASS_NAME, "__page-size-combo"),
        borderRadius: 0,
        idProperty: 'value',
        displayProperty: 'value',
        value: limit,
        renderListComponent: this.props.renderPageList,
        constrainTo: this.props.constrainTo,
        onChange: this.setPageSize,
        dataSource: this.props.pageSizes ? this.props.pageSizes.map(function (s) {
          return {
            value: s
          };
        }) : PAGE_SIZES,
        collapseOnSelect: true,
        changeValueOnNavigation: false,
        multiple: false,
        searchable: false,
        clearIcon: false
      }, (0, _defineProperty2.default)(_comboProps, "shadow", true), (0, _defineProperty2.default)(_comboProps, "rtl", this.props.rtl), (0, _defineProperty2.default)(_comboProps, "showShadowOnMouseOver", true), (0, _defineProperty2.default)(_comboProps, "allowSelectionToggle", false), (0, _defineProperty2.default)(_comboProps, "highlightFirst", false), (0, _defineProperty2.default)(_comboProps, "theme", this.props.theme), _comboProps);
      var result;

      if (this.props.renderPageSizeCombo) {
        result = this.props.renderPageSizeCombo(comboProps);
      }

      if (result === undefined) {
        result = _react.default.createElement(_ComboBox.default, _objectSpread(_objectSpread({}, comboProps), {}, {
          relativeToViewport: true
        }));
      }

      return result;
    }
  }, {
    key: "renderIcon",
    value: function renderIcon(name, disabled) {
      var icons = this.props.icons || ICONS;
      var icon = icons[name];

      if (this.props.rtl) {
        if (name === 'LAST_PAGE') {
          icon = icons['FIRST_PAGE'];
        } else if (name === 'FIRST_PAGE') {
          icon = icons['LAST_PAGE'];
        }

        if (name === 'NEXT_PAGE') {
          icon = icons['PREV_PAGE'];
        } else if (name === 'PREV_PAGE') {
          icon = icons['NEXT_PAGE'];
        }
      }

      var iconProps = {
        name: name,
        size: this.props.iconSize,
        icon: icon,
        disabled: disabled,
        action: this.ACTIONS[name],
        theme: this.props.theme
      };
      var result;

      if (this.props.renderIcon) {
        result = this.props.renderIcon(iconProps);
      }

      if (result === undefined) {
        result = _react.default.createElement(_PaginationIcon.default, _objectSpread({}, iconProps));
      }

      return result;
    }
  }, {
    key: "setCurrentPageInputValue",
    value: function setCurrentPageInputValue(value) {
      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;
      this.lastNotifiedSkip = getSkipForPage({
        page: value,
        limit: this.getLimit(props)
      });

      if (this.numberInput && typeof this.numberInput.setValue === 'function') {
        this.numberInput.setValue("".concat(value));
      }
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      var currentPage = getCurrentPage({
        skip: this.getSkip(),
        limit: this.getLimit()
      });
      this.setCurrentPageInputValue(currentPage);
    }
  }, {
    key: "onNumberInputChange",
    value: function onNumberInputChange(numericValue) {
      this.gotoPage(numericValue || 1);
    }
  }, {
    key: "setPageSize",
    value: function setPageSize(limit) {
      var currentSkip = this.getSkip();
      var currentPage = getCurrentPage({
        skip: currentSkip,
        limit: this.getLimit()
      });
      var maxPage = getPageCount({
        count: this.props.totalCount,
        limit: limit
      });
      var newPage = Math.min(currentPage, maxPage);
      var newSkip = getSkipForPage({
        page: newPage,
        limit: limit
      });

      if (this.props.onPageSizeChange) {
        this.props.onPageSizeChange(limit);
      }

      if (this.props.onLimitChange) {
        this.props.onLimitChange(limit);
      }

      if (this.props.limit === undefined) {
        this.setState({
          limit: limit
        });
      }

      if (newSkip != currentSkip && this.props.adjustSkipOnLimitChange) {
        this.gotoPage(newPage, {
          limit: limit
        });
      }
    }
  }, {
    key: "gotoPage",
    value: function gotoPage(page) {
      var _this2 = this;

      var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyObject,
          _ref7$limit = _ref7.limit,
          limit = _ref7$limit === void 0 ? this.getLimit() : _ref7$limit;

      var skip = getSkipForPage({
        page: page,
        limit: limit
      });

      if (this.lastNotifiedSkip === skip) {
        return;
      }

      setTimeout(function () {
        delete _this2.lastNotifiedSkip;
      }, 50);
      this.lastNotifiedSkip = skip;

      if (this.props.onPageChange) {
        this.props.onPageChange(page);
      }

      if (this.props.onSkipChange) {
        this.props.onSkipChange(skip);
      }

      if (this.props.skip === undefined) {
        this.setCurrentPageInputValue("".concat(page));
        this.setState({
          skip: skip
        });
      }
    }
  }, {
    key: "refresh",
    value: function refresh() {
      if (this.props.onRefresh) {
        this.props.onRefresh();
      }
    }
  }, {
    key: "gotoFirstPage",
    value: function gotoFirstPage() {
      this.gotoPage(1);
    }
  }, {
    key: "gotoLastPage",
    value: function gotoLastPage() {
      var lastPage = getPageCount({
        count: this.props.totalCount,
        limit: this.getLimit()
      });
      this.gotoPage(lastPage);
    }
  }, {
    key: "gotoNextPage",
    value: function gotoNextPage() {
      var nextPage = getCurrentPage({
        skip: this.getSkip(),
        limit: this.getLimit()
      }) + 1;
      this.gotoPage(nextPage);
    }
  }, {
    key: "gotoPrevPage",
    value: function gotoPrevPage() {
      var prevPage = getCurrentPage({
        skip: this.getSkip(),
        limit: this.getLimit()
      }) - 1;
      this.gotoPage(prevPage);
    }
  }]);
  return InovuaPaginationToolbar;
}(_react.default.Component);

exports.default = InovuaPaginationToolbar;
InovuaPaginationToolbar.defaultProps = {
  adjustSkipOnLimitChange: true,
  theme: 'default-light',
  bordered: true,
  iconSize: 24,
  rtl: false,
  remotePagination: false,
  pageText: 'Page ',
  ofText: ' of ',
  perPageText: 'Results per page',
  showingText: 'Showing ',
  rootClassName: 'inovua-react-pagination-toolbar'
};
InovuaPaginationToolbar.propTypes = {
  adjustSkipOnLimitChange: _propTypes.default.bool,
  pagination: _propTypes.default.any,
  bordered: _propTypes.default.bool,
  iconSize: _propTypes.default.number,
  pageText: _propTypes.default.node,
  ofText: _propTypes.default.node,
  perPageText: _propTypes.default.node,
  showingText: _propTypes.default.node,
  limit: _propTypes.default.number,
  defaultLimit: _propTypes.default.number,
  skip: _propTypes.default.number,
  defaultSkip: _propTypes.default.number,
  totalCount: _propTypes.default.number,
  gotoNextPage: _propTypes.default.func,
  gotoPrevPage: _propTypes.default.func,
  pageSize: _propTypes.default.number,
  currentPage: _propTypes.default.number,
  pageCount: _propTypes.default.number,
  gotoPage: _propTypes.default.func,
  onRefresh: _propTypes.default.func,
  hasNextPage: _propTypes.default.func,
  hasPrevPage: _propTypes.default.func,
  gotoLastPage: _propTypes.default.func,
  gotoFirstPage: _propTypes.default.func,
  remotePagination: _propTypes.default.bool,
  localPagination: _propTypes.default.any,
  renderPageList: _propTypes.default.any,
  reload: _propTypes.default.any,
  constrainTo: _propTypes.default.any,
  onPageChange: _propTypes.default.func,
  onSkipChange: _propTypes.default.func,
  onLimitChange: _propTypes.default.func,
  onPageSizeChange: _propTypes.default.func,
  pageSizes: _propTypes.default.arrayOf(_propTypes.default.number),
  renderCurrentPageInput: _propTypes.default.func,
  rootClassName: _propTypes.default.string,
  renderIcon: _propTypes.default.func,
  renderPageSizeCombo: _propTypes.default.func,
  renderToolbar: _propTypes.default.func,
  rtl: _propTypes.default.bool,
  theme: _propTypes.default.string
};
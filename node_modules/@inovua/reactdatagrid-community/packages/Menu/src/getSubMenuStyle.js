/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _regionAlign = _interopRequireDefault(require("../../../packages/region-align"));

var _assign = _interopRequireDefault(require("../../../common/assign"));

var _align = _interopRequireDefault(require("./align"));

var _getGlobal = require("../../../getGlobal");

var globalObject = (0, _getGlobal.getGlobal)();

function transformPxStringToInt(pxValue) {
  var value = parseFloat(pxValue.split('px')[0]);
  return typeof value === 'number' && !isNaN(value) ? value : 0;
}

function _default(props, state, domNode) {
  var _this = this;

  if (state.activeSubMenuIndex == null || !this.componentIsMounted) {
    this.prevMenuIndex = -1;
    return;
  }

  var overItem = this.getItemByIndex(state.activeSubMenuIndex);
  var offset = overItem && overItem.getOffset();
  var left = offset.left + offset.width;
  var top = offset.top;
  var menuIndex = state.activeSubMenuIndex;
  var sameMenu = this.prevMenuIndex == menuIndex;

  if (this.aligning && !sameMenu) {
    this.aligning = false;
  }

  this.prevMenuIndex = menuIndex;
  var style = {
    left: left,
    top: top,
    pointerEvents: 'none',
    position: 'absolute'
  };

  if (!this.aligning && !sameMenu) {
    setTimeout(function () {
      if (!_this.componentIsMounted) {
        return;
      }

      var thisRegion = _regionAlign.default.from(domNode);

      var menuComputedStyle = globalObject.getComputedStyle(domNode);
      var paddingLeft = transformPxStringToInt(menuComputedStyle.paddingLeft);

      var menuItemRegion = _regionAlign.default.from({
        left: thisRegion.left + paddingLeft,
        top: thisRegion.top + offset.top,
        width: offset.width,
        height: offset.height
      });

      var subMenuMounted = _this.subMenu && _this.subMenu.componentIsMounted;

      if (!subMenuMounted) {
        return;
      }

      var submenuNode = _this.subMenu.node;

      var subMenuRegion = _regionAlign.default.from(submenuNode);

      var initialHeight = subMenuRegion.height;
      var alignPosition = (0, _align.default)(props, subMenuRegion, menuItemRegion, props.constrainTo, domNode);
      var newHeight = subMenuRegion.height;
      var maxHeight;

      if (newHeight < initialHeight && props.subMenuConstrainMargin != null) {
        maxHeight = newHeight - props.subMenuConstrainMargin;
      } else if (newHeight < initialHeight) {
        maxHeight = newHeight;
      }

      if (maxHeight && alignPosition == -1) {
        subMenuRegion.top = subMenuRegion.bottom - maxHeight;
      }

      var newLeft = subMenuRegion.left - thisRegion.left;
      var newTop = subMenuRegion.top - thisRegion.top;

      if (Math.abs(newLeft - left) < 5) {
        newLeft = left;
      }

      if (Math.abs(newTop - top) < 5) {
        newTop = top;
      }

      _this.subMenuPosition = newLeft < 0 ? 'left' : 'right';

      if (newHeight === 0) {
        return;
      }

      _this.alignOffset = {
        left: newLeft,
        top: newTop
      };
      _this.aligning = true;

      _this.setState({
        submenuAlignPosition: alignPosition,
        submenuMaxHeight: props.submenuMaxHeight || maxHeight
      });
    }, 0);
  }

  if (sameMenu || this.aligning && this.alignOffset) {
    (0, _assign.default)(style, this.alignOffset);
    style.visibility = 'visible';
    delete style.pointerEvents;
    delete style.overflow;
  }

  this.aligning = false;
  return style;
}
/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactClass = _interopRequireDefault(require("../../../packages/react-class"));

var _regionAlign = _interopRequireDefault(require("../../../packages/region-align"));

var _uglified = _interopRequireDefault(require("../../../packages/uglified"));

var _shallowequal = _interopRequireDefault(require("../../../common/shallowequal"));

var _ArrowScroller = _interopRequireDefault(require("../../ArrowScroller"));

var _MenuItem = _interopRequireDefault(require("./MenuItem"));

var _MenuSeparator = _interopRequireDefault(require("./MenuSeparator"));

var _containsNode = _interopRequireDefault(require("../../../common/containsNode"));

var _cleanProps = _interopRequireDefault(require("../../../common/cleanProps"));

var _join = _interopRequireDefault(require("../../../common/join"));

var _assign = _interopRequireDefault(require("../../../common/assign"));

var _getConstrainRegion = _interopRequireDefault(require("../../../common/getConstrainRegion"));

var _isMobile = _interopRequireDefault(require("../../../common/isMobile"));

var _prepareStyle = _interopRequireDefault(require("./utils/prepareStyle"));

var _getFirstNonDisabledItem = _interopRequireDefault(require("./utils/getFirstNonDisabledItem"));

var _getNextNavigableItem = _interopRequireDefault(require("./utils/getNextNavigableItem"));

var _getSeparatorIndexes = _interopRequireDefault(require("./utils/getSeparatorIndexes"));

var _prepareAlignOffset = _interopRequireDefault(require("./utils/prepareAlignOffset"));

var _getSingleSelectNames = _interopRequireDefault(require("./utils/getSingleSelectNames"));

var _increaseColSpan = require("./utils/increaseColSpan");

var _getRegionRelativeToParent = _interopRequireDefault(require("./getRegionRelativeToParent"));

var _shouldComponentUpdate2 = _interopRequireDefault(require("../../../common/shouldComponentUpdate"));

var _getSubMenuStyle = _interopRequireDefault(require("./getSubMenuStyle"));

var _getItemStyleProps = _interopRequireDefault(require("./utils/getItemStyleProps"));

var _submenuAlignPositions = require("./submenuAlignPositions");

var _ua = require("../../../common/ua");

var _getGlobal = require("../../../getGlobal");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var globalObject = (0, _getGlobal.getGlobal)();

function emptyFn() {}

var raf = globalObject.requestAnimationFrame;

var getAlignToRegion = function getAlignToRegion(alignTo, node) {
  if (typeof alignTo === 'function') {
    alignTo = alignTo(node);
  }

  if (typeof alignTo == 'string') {
    alignTo = globalObject.document ? globalObject.document.querySelector(alignTo) : alignTo;
  }

  return _regionAlign.default.from(alignTo);
};

var InovuaMenu = function (_Component) {
  (0, _inherits2.default)(InovuaMenu, _Component);

  var _super = _createSuper(InovuaMenu);

  function InovuaMenu(props) {
    var _this;

    (0, _classCallCheck2.default)(this, InovuaMenu);
    _this = _super.call(this, props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "updatePosition", function () {
      _this.checkAlignment(undefined, true);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "updateAlignment", function (alignTo) {
      _this.checkAlignment(undefined, true, alignTo);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleDocumentScroll", function () {
      if (_this.props.updatePositionOnScroll) {
        _this.updatePosition();
      }
    });
    _this.state = {
      mouseOver: false,
      hidden: true,
      enableAnimation: false,
      transitionEnded: false,
      hasScroll: false,
      activeSubMenuIndex: null,
      nextActiveSubMenuIndex: null,
      showUpArrow: false,
      showDownArrow: true,
      focusedItem: props.enableKeyboardNavigation ? props.defaultFocusedItem : null,
      selected: props.defaultSelected
    };

    _this.setupShowHideDelay();

    _this.setRootRef = function (ref) {
      _this.node = ref;
    };

    _this.setItemRef = function (index) {
      return function (ref) {
        if (!_this.childrenRefs) {
          _this.childrenRefs = [];
        }

        _this.childrenRefs[index] = ref;
      };
    };

    _this.setSubMenuRef = function (ref) {
      _this.subMenu = ref;
    };

    _this.setSubMenuWrapRef = function (ref) {
      _this.subMenuWrap = ref;
    };

    _this.setScrollerRef = function (ref) {
      _this.scroller = ref;
    };

    _this.setTableRef = function (ref) {
      _this.table = ref;
    };

    return _this;
  }

  (0, _createClass2.default)(InovuaMenu, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      return (0, _shouldComponentUpdate2.default)(this, nextProps, nextProps);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.componentIsMounted = false;
      this.chidrenRefs = null;
      this.props.componentWillUnmount(this, {
        hasFocus: this.hasFocus(),
        depth: this.props.depth
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.autoFocus && prevState.hidden && !this.state.hidden) {
        this.focus();
      }

      if (prevProps.visible && !this.props.visible) {
        this.setState({
          positionStyle: null
        });
      }

      if (!prevProps.visible && this.props.visible || !(0, _shallowequal.default)(prevProps.alignTo, this.props.alignTo) || this.props.constrainTo != prevProps.constrainTo) {
        this.checkAlignment(this.props);
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.componentIsMounted = true;

      if (this.props.visible === false) {
        return;
      }

      if (this.props.componentDidMount) {
        this.props.componentDidMount(this);
      }

      this.checkAlignment();
      this.setupEnterAnimation();

      if (this.props.autoFocus) {
        requestAnimationFrame(function () {
          _this2.focus();
        });
      }

      if (this.props.updatePositionOnScroll) {
        window.addEventListener('scroll', this.handleDocumentScroll, {
          passive: true
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var state = this.state,
          props = this.props;
      var style = (0, _prepareStyle.default)(props, state);
      var className = this.prepareClassName(props, state);
      var table = this.renderTable();
      var scrollerArrow = props.showScrollArrows === undefined ? 'auto' : !!props.showScrollArrows;
      return _react.default.createElement("div", _objectSpread(_objectSpread({
        tabIndex: 0
      }, (0, _cleanProps.default)(props, InovuaMenu.propTypes)), {}, {
        ref: this.setRootRef,
        onMouseLeave: this.handleMouseLeave,
        onMouseEnter: this.handleMouseEnter,
        onKeyDown: this.handleKeyDown,
        onBlur: this.handleOnBlur,
        className: className,
        style: style
      }), this.state.activeSubMenuIndex !== null && this.renderSubMenu(props, state), props.disableScroller ? table : _react.default.createElement(_ArrowScroller.default, _objectSpread({
        scroller: scrollerArrow
      }, this.getScrollerProps()), table));
    }
  }, {
    key: "renderTable",
    value: function renderTable() {
      var props = this.props,
          state = this.state;
      var className = (0, _join.default)("".concat(props.rootClassName, "__table"), props.tableClassName);
      return _react.default.createElement("table", {
        cellSpacing: 0,
        cellPadding: 0,
        className: className,
        ref: this.setTableRef
      }, _react.default.createElement("tbody", null, this.renderItems()));
    }
  }, {
    key: "renderItems",
    value: function renderItems() {
      var _this3 = this;

      var props = this.props,
          state = this.state;

      if (!props.items) {
        return null;
      }

      var commonProps = this.getCommonItemProps();
      var siblingItemHasSubMenu = this.doesAnyItemHasSubMenu();
      var siblingItemHasSelectInput = this.dosAnyItemHaveSelectInput();
      var hasDescription = props.items.filter(function (item) {
        return !!item.secondaryLabel;
      }).length;
      var hasIcon = props.items.filter(function (item) {
        return !!item.icon;
      }).length;
      return props.items.map(function (item, index, items) {
        if (item === '-') {
          return _react.default.createElement(_MenuSeparator.default, {
            style: props.menuSeparatorStyle,
            key: index,
            rootClassName: props.rootClassName
          });
        }

        var columns = props.columns;

        if (hasDescription) {
          columns = [].concat((0, _toConsumableArray2.default)(columns), [{
            name: 'secondaryLabel',
            isDescription: true,
            style: _objectSpread(_objectSpread({}, props.secondaryLabelStyle), item.secondaryLabelStyle)
          }]);
        }

        if (hasIcon) {
          columns = [{
            name: 'icon',
            isIcon: true
          }].concat((0, _toConsumableArray2.default)(columns));
        }

        if (props.labelStyle || item.labelStyle) {
          columns = columns.map(function (column) {
            if (!column) {
              return column;
            }

            if (typeof column === 'string' && column === 'label') {
              return {
                name: 'label',
                style: _objectSpread(_objectSpread({}, props.labelStyle), item.labelStyle)
              };
            }

            if (column && column.name && column.name === 'label') {
              return _objectSpread(_objectSpread({}, column), {}, {
                style: _objectSpread(_objectSpread({}, columns.style), props.labelStyle)
              });
            }

            return column;
          });
        }

        var hasSubMenu = item.items && !!item.items.length || item.children && !!item.children.length;
        var focused = state.focusedItem === index;
        var expanded = commonProps.expandedIndex === index;
        var className = props.itemClassName;

        var selectionProps = _this3.getSelectionProps(item);

        if (props.enableSelection && siblingItemHasSelectInput && !selectionProps) {
          if (props.selectionInputPosition === 'start') {
            columns = (0, _increaseColSpan.increaseFirstColumnColSpan)(columns);
          } else {
            columns = (0, _increaseColSpan.increaseLastColumnColSpan)(columns);
          }
        }

        if (!hasSubMenu && siblingItemHasSubMenu) {
          columns = (0, _increaseColSpan.increaseLastColumnColSpan)(columns);
        }

        var itemProps = _objectSpread(_objectSpread(_objectSpread({
          index: index,
          item: item,
          hasSubMenu: hasSubMenu,
          items: items,
          focused: focused,
          expanded: expanded,
          className: className,
          columns: columns,
          key: index,
          disabled: item.disabled,
          theme: props.theme,
          ref: _this3.setItemRef(index)
        }, commonProps), selectionProps), item.props);

        var Component = props.itemFactory || _MenuItem.default;
        return _react.default.createElement(Component, _objectSpread({}, itemProps));
      });
    }
  }, {
    key: "getSelectionProps",
    value: function getSelectionProps(item) {
      var props = this.props;

      if (!props.items || props.items && !props.items.length) {
        return null;
      }

      var selected = this.getSelected();
      var singleSelectNames = (0, _getSingleSelectNames.default)({
        items: props.items,
        nameProperty: props.nameProperty
      });
      var selectionProps;

      if (props.enableSelection) {
        var value = item[props.valueProperty];
        var name = item[props.nameProperty];
        var multiple = singleSelectNames && !singleSelectNames[name];
        var checked = multiple ? value !== undefined ? selected[name] === value : selected[name] === name : selected[name] === value;

        if (name) {
          selectionProps = {
            name: name,
            value: value,
            checked: checked,
            multiple: multiple,
            allowUnselect: props.allowUnselect,
            enableSelection: true,
            browserNativeSelectInputs: props.browserNativeSelectInputs,
            renderCheckInput: item.renderCheckInput !== undefined ? item.renderCheckInput : props.renderCheckInput,
            renderRadioInput: item.renderRadioInput !== undefined ? item.renderRadioInput : props.renderRadioInput,
            selectionInputPosition: item.selectionInputPosition !== undefined ? item.selectionInputPosition : props.selectionInputPosition
          };
        }
      }

      return selectionProps;
    }
  }, {
    key: "getCommonItemProps",
    value: function getCommonItemProps() {
      var _objectSpread2;

      var props = this.props;
      var menuHasSubmenu = !!props.items.filter(function (item) {
        return item.items && item.items.length;
      }).length;
      var itemStyleProps = (0, _getItemStyleProps.default)(props);
      return _objectSpread((_objectSpread2 = {
        menuHasSubmenu: menuHasSubmenu,
        expanderStyle: props.expanderStyle,
        expanderSize: props.expanderSize,
        globalCellStyle: props.cellStyle,
        itemDisabledStyle: props.itemDisabledStyle,
        itemDisabledClassName: props.itemDisabledClassName,
        itemOverStyle: props.itemOverStyle,
        itemActiveStyle: props.itemActiveStyle
      }, (0, _defineProperty2.default)(_objectSpread2, "menuHasSubmenu", props.menuHasSubmenu), (0, _defineProperty2.default)(_objectSpread2, "rootClassName", props.rootClassName), (0, _defineProperty2.default)(_objectSpread2, "showWarnings", props.showWarnings), (0, _defineProperty2.default)(_objectSpread2, "titleStyle", props.titleStyle), (0, _defineProperty2.default)(_objectSpread2, "onClick", this.onMenuItemClick), (0, _defineProperty2.default)(_objectSpread2, "onMouseOver", this.onMenuItemMouseEnter), (0, _defineProperty2.default)(_objectSpread2, "onMouseOut", this.onMenuItemMouseLeave), (0, _defineProperty2.default)(_objectSpread2, "submenuWillUnmount", this.onSubmenuWillUnmount), (0, _defineProperty2.default)(_objectSpread2, "onExpanderClick", this.onMenuItemExpanderClick), (0, _defineProperty2.default)(_objectSpread2, "onSelectChange", this.handleSelectionChange), (0, _defineProperty2.default)(_objectSpread2, "selectOnClick", props.selectOnClick), (0, _defineProperty2.default)(_objectSpread2, "expander", props.expander), (0, _defineProperty2.default)(_objectSpread2, "rtl", props.rtl), (0, _defineProperty2.default)(_objectSpread2, "height", props.itemHeight), (0, _defineProperty2.default)(_objectSpread2, "checkIconSize", props.checkIconSize), (0, _defineProperty2.default)(_objectSpread2, "radioIconSize", props.radioIconSize), (0, _defineProperty2.default)(_objectSpread2, "closeSubmenuRecursively", this.closeSubmenuRecursively), (0, _defineProperty2.default)(_objectSpread2, "closeSubMenu", this.closeSubMenu), (0, _defineProperty2.default)(_objectSpread2, "expandedIndex", this.getExpandedIndex()), _objectSpread2), itemStyleProps);
    }
  }, {
    key: "renderSubMenu",
    value: function renderSubMenu(props, state) {
      var domNode = this.node;
      var menuProps = this.getSubMenuProps();

      var wrapperStyle = _getSubMenuStyle.default.bind(this)(_objectSpread(_objectSpread({}, props), {}, {
        alignPositions: this.getDefaultAlignPositions()
      }), state, domNode);

      var wrapperClassName = "".concat(this.props.rootClassName, "__submenu-wrapper");
      return _react.default.createElement("div", {
        className: wrapperClassName,
        ref: this.setSubMenuWrapRef,
        style: wrapperStyle,
        onMouseEnter: this.handleSubMenuMouseEnter,
        onMouseLeave: this.handleSubMenuMouseLeave
      }, _react.default.createElement(InovuaMenu, _objectSpread({
        key: state.activeSubMenuIndex
      }, menuProps)));
    }
  }, {
    key: "hasItemSubMenu",
    value: function hasItemSubMenu(index) {
      var items = this.getItemsByIndex(index);
      return items && items.length;
    }
  }, {
    key: "getItemsByIndex",
    value: function getItemsByIndex(index) {
      var item = this.props.items && this.props.items[index];

      if (!item) {
        return null;
      }

      var items = item && item.items;
      return items;
    }
  }, {
    key: "getSubMenuProps",
    value: function getSubMenuProps() {
      var props = this.props,
          state = this.state;
      var index = this.state.activeSubMenuIndex;
      var items = this.getItemsByIndex(index);
      var item = this.props.items[index];

      var overridingProps = _objectSpread(_objectSpread({}, this.props.submenuProps), item.menuProps);

      if (overridingProps.selected === undefined && overridingProps.defaultSelected === undefined) {
        overridingProps.selected = this.getSelected();
      }

      var menuProps = _objectSpread(_objectSpread(_objectSpread({}, this.props), {}, {
        onDismiss: emptyFn
      }, overridingProps), {}, {
        items: items,
        depth: props.depth + 1,
        ref: this.setSubMenuRef,
        subMenu: true,
        parentMenu: this,
        closeSubMenu: this.closeSubMenu,
        closeSubmenuRecursively: this.closeSubmenuRecursively,
        componentWillUnmount: this.submenuWillUnmount,
        parentIndex: index,
        maxHeight: state.submenuMaxHeight || props.submenuMaxHeight || state.maxHeight || props.maxHeight,
        onActivate: this.onSubMenuActivate,
        onInactivate: this.onSubMenuInactivate,
        scrollerProps: props.scrollerProps,
        constrainTo: props.constrainTo,
        expander: props.expander,
        onSelectionChange: this.handleSubmenuSelectionChange,
        alignPosition: state.submenuAlignPosition
      });

      delete menuProps.autoFocus;
      delete menuProps.className;
      delete menuProps.onClick;
      delete menuProps.defaultFocusedItem;
      delete menuProps.onChildClick;
      delete menuProps.visible;
      return menuProps;
    }
  }, {
    key: "getAlignPositions",
    value: function getAlignPositions(props) {
      if (props.alignPositions == null) {
        return this.getDefaultAlignPositions();
      }

      return props.alignPositions;
    }
  }, {
    key: "getDefaultAlignPositions",
    value: function getDefaultAlignPositions() {
      var props = this.props;
      return props.rtl ? _submenuAlignPositions.alignPositionRTL : _submenuAlignPositions.alignPositionLTR;
    }
  }, {
    key: "getScrollerProps",
    value: function getScrollerProps() {
      var _this4 = this,
          _objectSpread3;

      var props = this.props,
          state = this.state;
      var className = (0, _join.default)(props.scrollerProps.className, "".concat(props.rootClassName, "__scroll-container"));
      var style = (0, _assign.default)({}, props.scrollerProps.style);
      var maxHeight = state.maxHeight != undefined && props.submenu ? state.maxHeight : props.maxHeight;

      if (maxHeight != null) {
        (0, _assign.default)(style, {
          maxHeight: maxHeight
        });
      }

      var scrollProps = _objectSpread(_objectSpread({}, props.scrollerProps), {}, (_objectSpread3 = {
        renderScroller: props.renderScroller,
        nativeScroll: props.nativeScroll,
        scrollContainerProps: props.scrollContainerProps,
        className: className,
        notifyResizeDelay: props.notifyResizeDelay,
        ref: this.setScrollerRef,
        style: style,
        theme: props.theme,
        vertical: true
      }, (0, _defineProperty2.default)(_objectSpread3, "theme", props.theme), (0, _defineProperty2.default)(_objectSpread3, "scrollOnMouseEnter", props.scrollOnMouseEnter), (0, _defineProperty2.default)(_objectSpread3, "onHasScrollChange", function onHasScrollChange(hasScroll) {
        return _this4.setState({
          hasScroll: hasScroll
        });
      }), _objectSpread3));

      return scrollProps;
    }
  }, {
    key: "prepareClassName",
    value: function prepareClassName(props, state) {
      var hidden = props.visible != undefined ? !props.visible : state.hidden;
      var className = (0, _join.default)(props.rootClassName, props.theme && "".concat(props.rootClassName, "--theme-").concat(props.theme), props.className, !props.visible || props.items && !props.items.length && "".concat(props.rootClassName, "--no-display"), props.absolute && "".concat(props.rootClassName, "--absolute"), !props.rtl ? "".concat(props.rootClassName, "--ltr") : "".concat(props.rootClassName, "--rtl"), hidden && "".concat(props.rootClassName, "--hidden"), _isMobile.default && "".concat(props.rootClassName, "--mobile"), props.subMenu && "".concat(props.rootClassName, "__submenu"), "".concat(props.rootClassName, "--depth-").concat(props.depth), state.hasScroll && "".concat(props.rootClassName, "--has-overflow"), props.shadow && "".concat(props.rootClassName, "--shadow"), state.hasScroll && "".concat(props.rootClassName, "--has-scroll"));

      if (props.alignPosition !== undefined) {
        var position = props.alignPosition === 1 ? 'up' : 'down';
        className = (0, _join.default)(className, "".concat(props.rootClassName, "--position-").concat(position));
      }

      if (state.enableAnimation) {
        className = (0, _join.default)(className, "".concat(props.rootClassName, "--animation-enabled"), state.transitionEnded && "".concat(props.rootClassName, "--transition-end"), state.transitionStart && "".concat(props.rootClassName, "--transition-start"));
      }

      return className;
    }
  }, {
    key: "handleMouseEnter",
    value: function handleMouseEnter(event) {
      if (typeof this.props.onMouseEnter === 'function') {
        this.props.onMouseEnter(event);
      }

      this.setState({
        mouseInside: true
      });
      this.onActivate();
    }
  }, {
    key: "handleMouseLeave",
    value: function handleMouseLeave(event) {
      if (typeof this.props.onMouseLeave === 'function') {
        this.props.onMouseLeave(event);
      }

      this.setNextSubmenu();
      this.setState({
        mouseInside: false
      });

      if (!this.state.activeSubMenuIndex && !this.state.nextActiveSubMenuIndex) {
        this.onInactivate({
          hasFocus: this.hasFocus(),
          parentIndex: this.props.parentIndex
        });
      }
    }
  }, {
    key: "handleKeyDown",
    value: function handleKeyDown(event) {
      if (typeof this.props.onKeyDown === 'function') {
        this.props.onKeyDown(event);
      }

      if (!this.props.enableKeyboardNavigation) {
        return;
      }

      var stop = function stop(event) {
        event.stopPropagation();
      };

      stop(event);

      switch (event.key) {
        case 'ArrowUp':
          this.handleArrowUp(event);
          break;

        case 'ArrowDown':
          this.handleArrowDown(event);
          break;

        case 'ArrowLeft':
          this.handleArrowLeft(event);
          break;

        case 'ArrowRight':
          this.handleArrowRight(event);
          break;

        case 'Enter':
          this.handleEnterOnFocusedItem(event);
          break;

        case ' ':
          this.handleSpaceOnFocusedItem(event);
          break;
      }
    }
  }, {
    key: "handleArrowUp",
    value: function handleArrowUp(event) {
      var lastItemIndex = this.props.items && this.props.items.length ? this.props.items.length : null;
      var props = this.props;
      var focusedItemIndex = this.state.focusedItem != null ? this.state.focusedItem : lastItemIndex;
      var newFocusedItemIndex = (0, _getNextNavigableItem.default)(props.items, focusedItemIndex, -1);

      if (newFocusedItemIndex == null) {
        return;
      }

      this.setFocusedIndex(newFocusedItemIndex);
    }
  }, {
    key: "handleArrowDown",
    value: function handleArrowDown(event) {
      var props = this.props;
      var focusedItemIndex = this.state.focusedItem != null ? this.state.focusedItem : -1;
      var newFocusedItemIndex = (0, _getNextNavigableItem.default)(props.items, focusedItemIndex, 1);

      if (newFocusedItemIndex == null) {
        return;
      }

      this.setFocusedIndex(newFocusedItemIndex);
    }
  }, {
    key: "handleArrowLeft",
    value: function handleArrowLeft(event) {
      if (this.props.rtl) {
        this.openSubMenuAction(this.state.focusedItem);
      } else {
        this.closeSubMenuAction();
      }
    }
  }, {
    key: "handleArrowRight",
    value: function handleArrowRight(event) {
      if (this.props.rtl) {
        this.closeSubMenuAction();
      } else {
        this.openSubMenuAction(this.state.focusedItem);
      }
    }
  }, {
    key: "handleEnterOnFocusedItem",
    value: function handleEnterOnFocusedItem(event) {
      var focusedItem = this.getFocusedItem();

      if (this.props.simulateClickOnEnterKeyPress && focusedItem != null && typeof focusedItem.handleClick === 'function') {
        focusedItem.handleClick({
          stopPropagation: function stopPropagation() {}
        });
      }
    }
  }, {
    key: "handleSpaceOnFocusedItem",
    value: function handleSpaceOnFocusedItem() {
      var activeItemProps = this.getFocusedItemProps();

      if (!activeItemProps) {
        return;
      }

      this.handleSelectionChange({
        name: activeItemProps.name,
        value: activeItemProps.value,
        checked: !activeItemProps.checked,
        multiple: activeItemProps.multiple
      });
    }
  }, {
    key: "handleOnBlur",
    value: function handleOnBlur(event) {
      var _this5 = this;

      if (typeof this.props.onBlur === 'function') {
        this.props.onBlur(event);
      }

      if (this.props.stopBlurPropagation) {
        event.stopPropagation();
      }

      if (this.preventOnBlurRecursiveClose) {
        return;
      }

      this.dismissTriggeredByBlur = true;
      setTimeout(function () {
        if (!_this5.hasGeneralFocus()) {
          _this5.dismiss(event);
        }
      }, _ua.IS_IE ? this.props.hideSubMenuDelay : 20);
    }
  }, {
    key: "dismiss",
    value: function dismiss(event) {
      this.closeSubmenuRecursively();
      this.props.onDismiss(event);
    }
  }, {
    key: "scrollItemIntoView",
    value: function scrollItemIntoView(index) {
      var itemNode = this.getItemDOMNodeByIndex(index);

      if (!this.scroller || !itemNode) {
        return;
      }

      this.scroller.scrollIntoView(itemNode);
    }
  }, {
    key: "closeSubmenuRecursively",
    value: function closeSubmenuRecursively() {
      this.closeSubMenu();
      this.props.closeSubmenuRecursively();
    }
  }, {
    key: "closeSubMenuAction",
    value: function closeSubMenuAction() {
      if (this.hasSubMenuOpened()) {
        this.closeSubMenu();
      } else if (this.isSubMenu()) {
        this.preventOnBlurRecursiveClose = true;
        this.props.closeSubMenu({
          autoFocus: true
        });
      }
    }
  }, {
    key: "openSubMenuAction",
    value: function openSubMenuAction(focusedItemIndex) {
      var focusedItem = this.getItemByIndex(focusedItemIndex);

      if (!focusedItem) {
        return;
      }

      if (focusedItem && !focusedItem.hasSubmenu()) {
        return;
      }

      if (focusedItemIndex === this.state.activeSubMenuIndex) {
        this.subMenu && this.subMenu.focusFirstItem();
        return;
      }

      var menuOffset = focusedItem && focusedItem.getOffset();
      this.setSubMenu({
        menuOffset: menuOffset,
        index: focusedItemIndex
      });
    }
  }, {
    key: "onActivate",
    value: function onActivate() {
      if (!this.state.activated) {
        this.setState({
          activated: true
        });

        if (this.props.onActivate) {
          this.props.onActivate();
        }
      }
    }
  }, {
    key: "onInactivate",
    value: function onInactivate(options) {
      if (this.state.activated) {
        this.setState({
          activated: false
        });

        if (this.props.onInactivate) {
          this.props.onInactivate(options);
        }
      }
    }
  }, {
    key: "handleSubMenuMouseEnter",
    value: function handleSubMenuMouseEnter() {
      this.setState({
        mouseOverSubMenu: true
      });
    }
  }, {
    key: "handleSubMenuMouseLeave",
    value: function handleSubMenuMouseLeave() {
      this.setState({
        mouseOverSubMenu: false
      });
    }
  }, {
    key: "isSubMenuActive",
    value: function isSubMenuActive() {
      return this.state.subMenuActive;
    }
  }, {
    key: "onSubMenuActivate",
    value: function onSubMenuActivate() {
      this.setState({
        subMenuActive: true
      });

      if (this.closeSubmenuTimeout) {
        clearTimeout(this.closeSubmenuTimeout);
      }
    }
  }, {
    key: "onSubMenuInactivate",
    value: function onSubMenuInactivate(submenuConfig) {
      var _this6 = this;

      var ts = +new Date();
      var nextItem = this.state.nextItem;
      var nextTimestamp = this.state.nextTimestamp || 0;
      this.setState({
        subMenuActive: false,
        timestamp: ts
      }, function () {
        setTimeout(function () {
          if (ts != _this6.state.timestamp || nextItem && ts - nextTimestamp < 100) {
            _this6.setSubMenu({
              menuOffset: _this6.state.nextOffset,
              index: _this6.state.nextActiveSubMenuIndex
            }, function () {
              _this6.focus();
            });

            return;
          } else {
            _this6.focus();
          }

          var mouseHasEnteredSubmenuParentItem = submenuConfig && submenuConfig.parentIndex === _this6.itemOverIndex;

          if (!_this6.isSubMenuActive() && !mouseHasEnteredSubmenuParentItem) {
            _this6.closeSubMenu({
              autoFocus: submenuConfig && submenuConfig.hasFocus
            });
          }
        }, 10);
      });
    }
  }, {
    key: "onMenuItemMouseEnter",
    value: function onMenuItemMouseEnter(_ref) {
      var menuOffset = _ref.menuOffset,
          index = _ref.index,
          hasSubMenu = _ref.hasSubMenu;

      if (!this.componentIsMounted) {
        return;
      }

      this.itemOverIndex = index;

      if (!hasSubMenu) {
        if (this.state.activeSubMenuIndex != null) {
          this.setNextSubmenu({
            menuOffset: null,
            index: null
          });
        }

        return;
      }

      if (this.state.activeSubMenuIndex == null) {
        this.setSubMenu({
          menuOffset: menuOffset,
          index: index
        });
      } else {
        this.setNextSubmenu({
          menuOffset: menuOffset,
          index: index
        });
      }
    }
  }, {
    key: "onMenuItemMouseLeave",
    value: function onMenuItemMouseLeave(_ref2) {
      var leaveOffset = _ref2.leaveOffset,
          index = _ref2.index,
          event = _ref2.event;

      if (this.itemOverIndex === index) {
        this.itemOverIndex = null;
      }

      if (!leaveOffset) {
        return;
      }

      var elementAtMousePosition = globalObject.document.elementFromPoint(leaveOffset.x, leaveOffset.y);

      if (elementAtMousePosition === this.subMenuWrap || (0, _containsNode.default)(this.subMenuWrap, elementAtMousePosition)) {
        return;
      }

      if (this.state.activeSubMenuIndex !== null) {
        this.delayCloseSubmenu(leaveOffset);
      }

      if (this.showTimeout) {
        clearTimeout(this.showTimeout);
      }
    }
  }, {
    key: "delayCloseSubmenu",
    value: function delayCloseSubmenu() {
      var _this7 = this;

      if (!this.componentIsMounted) {
        return;
      }

      if (this.closeSubmenuTimeoutId) {
        return;
      }

      this.closeSubmenuTimeout = setTimeout(function () {
        _this7.closeSubmenuTimeout = null;

        _this7.setSubMenu({
          menuOffset: _this7.state.nextOffset,
          index: _this7.state.nextActiveSubMenuIndex
        });
      }, 100);
    }
  }, {
    key: "removeMouseMoveListener",
    value: function removeMouseMoveListener() {
      if (this.onWindowMouseMove) {
        globalObject.removeEventListener('mousemove', this.onWindowMouseMove);
        this.onWindowMouseMove = null;
      }
    }
  }, {
    key: "setSubMenu",
    value: function setSubMenu() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          menuOffset = _ref3.menuOffset,
          _ref3$index = _ref3.index,
          index = _ref3$index === void 0 ? null : _ref3$index;

      var callback = arguments.length > 1 ? arguments[1] : undefined;
      this.removeMouseMoveListener();

      if (!this.componentIsMounted) {
        return;
      }

      if (this.state.activeSubMenuIndex === index) {
        if (callback) {
          callback();
        }

        return;
      }

      if (this.hasItemSubMenu(index) && !this.state.mouseInside) {
        this.onInactivate();
      }

      this.setState({
        menuOffset: menuOffset,
        activeSubMenuIndex: index,
        nextOffset: null,
        nextTimestamp: null,
        timestamp: +new Date()
      }, callback);
    }
  }, {
    key: "setNextSubmenu",
    value: function setNextSubmenu() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$menuOffset = _ref4.menuOffset,
          menuOffset = _ref4$menuOffset === void 0 ? null : _ref4$menuOffset,
          _ref4$index = _ref4.index,
          index = _ref4$index === void 0 ? null : _ref4$index;

      var ts = +new Date();
      this.setState({
        timestamp: ts,
        nextOffset: menuOffset,
        nextActiveSubMenuIndex: index,
        nextTimestamp: +new Date()
      });
    }
  }, {
    key: "closeSubMenu",
    value: function closeSubMenu(options) {
      return;
      this.setSubMenu();

      if (options && options.autoFocus) {
        this.focus();
      }
    }
  }, {
    key: "onMenuItemExpanderClick",
    value: function onMenuItemExpanderClick(event) {
      event.nativeEvent.expanderClick = true;
    }
  }, {
    key: "onMenuItemClick",
    value: function onMenuItemClick() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var itemProps = arguments.length > 1 ? arguments[1] : undefined;
      var index = arguments.length > 2 ? arguments[2] : undefined;
      var props = this.props;
      var stopped = event && event.isPropagationStopped ? event.isPropagationStopped() : false;

      if (props.stopClickPropagation && event.stopPropagation) {
        event.stopPropagation();
      }

      if (_isMobile.default && itemProps && event && event.nativeEvent && event.nativeEvent.expanderClick) {
        var offset = {
          x: event.pageX,
          y: event.pageY
        };
        var menuOffset = (0, _getRegionRelativeToParent.default)(event.currentTarget, props.rootClassName);
        this.onMenuItemMouseEnter({
          hasSubMenu: itemProps.hasSubMenu,
          menuOffset: menuOffset,
          index: itemProps.index
        });
        return;
      }

      if (!stopped) {
        props.onClick(event, itemProps, index);

        if (_isMobile.default && props.onTouchStart) {
          props.onTouchStart(event, itemProps, index);
        }

        var dismissOnClick = itemProps && itemProps.item && itemProps.item.dismissOnClick !== undefined ? itemProps.item.dismissOnClick : props.dismissOnClick;

        if (props.autoDismiss) {
          if (!itemProps.hasSubMenu) {
            this.dismiss();
          } else if (dismissOnClick) {
            props.closeSubmenuRecursively();
          }
        } else if (dismissOnClick) {
          props.closeSubmenuRecursively();
        }

        if (props.selectOnClick && itemProps.name !== undefined) {
          this.handleSelectionChange({
            name: itemProps.name,
            value: itemProps.value,
            checked: !itemProps.checked,
            multiple: itemProps.multiple
          });
        }

        this.onChildClick(event, itemProps);
      }

      if (!this.isSeparator(index)) {
        this.setFocusedIndex(index);
      }
    }
  }, {
    key: "onChildClick",
    value: function onChildClick(event, props) {
      if (this.props.onChildClick) {
        this.props.onChildClick(event, props);
      }

      if (this.props.parentMenu) {
        this.props.parentMenu.onChildClick(event, props);
      }
    }
  }, {
    key: "setupShowHideDelay",
    value: function setupShowHideDelay() {
      var _this8 = this;

      var setSubMenu = this.setSubMenu;

      this.setSubMenu = function () {
        var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            menuOffset = _ref5.menuOffset,
            index = _ref5.index;

        var callback = arguments.length > 1 ? arguments[1] : undefined;

        if (_this8.showTimeout) {
          clearTimeout(_this8.showTimeout);
        }

        if (_this8.hideTimeout) {
          clearTimeout(_this8.hideTimeout);
        }

        if (index != null) {
          if (_this8.props.showSubMenuDelay) {
            _this8.showTimeout = setTimeout(function () {
              return setSubMenu({
                menuOffset: menuOffset,
                index: index
              }, callback);
            }, _this8.props.showSubMenuDelay);
          } else {
            setSubMenu({
              menuOffset: menuOffset,
              index: index
            }, callback);
          }
        } else {
          if (_this8.props.hideSubMenuDelay) {
            _this8.hideTimeout = setTimeout(function () {
              return setSubMenu({
                menuOffset: menuOffset,
                index: index
              }, callback);
            }, _this8.props.hideSubMenuDelay);
          } else {
            setSubMenu({
              menuOffset: menuOffset,
              index: index
            }, callback);
          }
        }
      };
    }
  }, {
    key: "setupEnterAnimation",
    value: function setupEnterAnimation() {
      var _this9 = this;

      setTimeout(function () {
        var enableAnimation = _this9.props.enableAnimation && _this9.props.subMenu || _this9.props.enableRootAnimation && !_this9.props.subMenu;

        if (_this9.componentIsMounted) {
          _this9.setState({
            hidden: false,
            enableAnimation: enableAnimation
          });
        }

        if (enableAnimation) {
          setTimeout(function () {
            if (_this9.componentIsMounted) {
              _this9.setState({
                transitionStart: true
              });
            }

            setTimeout(function () {
              if (_this9.componentIsMounted) {
                _this9.setState({
                  transitionEnded: true
                });
              }
            }, 16);
          }, 16);
        }
      }, 0);
    }
  }, {
    key: "checkAlignment",
    value: function checkAlignment(props, skipReset, alignTo) {
      var _this10 = this;

      props = props || this.props;
      alignTo = alignTo || props.alignTo;

      if (props.visible === false) {
        return;
      }

      if ((props.constrainTo || alignTo) && !props.subMenu) {
        var doAlign = function doAlign() {
          var props = _this10.props;

          var alignPositions = _this10.getAlignPositions(props);

          var domNode = _this10.node;

          if (!domNode) {
            return;
          }

          domNode.style.visibility = '';
          var alignOffset = (0, _prepareAlignOffset.default)(props.alignOffset);

          var domRegion = _regionAlign.default.from(domNode);

          var actualRegion = domRegion.clone();
          var constrainRegion = props.constrainTo ? (0, _getConstrainRegion.default)(props.constrainTo, domNode) : null;
          var positionStyle;

          if (alignTo) {
            var alignRegion = getAlignToRegion(alignTo, domNode);
            actualRegion.alignTo(alignRegion, alignPositions, {
              offset: alignOffset,
              constrain: constrainRegion
            });
            var offsetParent = domNode.offsetParent;

            if (_ua.IS_FF && offsetParent === document.body && getComputedStyle(domNode).position === 'fixed') {
              offsetParent = null;
            }

            var offsetParentRect = offsetParent ? null : domNode.getBoundingClientRect();

            var offsetParentRegion = _regionAlign.default.from(offsetParent || {
              top: offsetParentRect.top,
              left: offsetParentRect.left
            });

            var newTop = actualRegion.top - offsetParentRegion.top;
            var newLeft = actualRegion.left - offsetParentRegion.left;
            var transform = "translate3d(".concat(Math.floor(newLeft), "px, ").concat(Math.floor(newTop), "px, 0px)");
            positionStyle = {
              transform: transform,
              top: 0,
              left: 0
            };
          }

          if (constrainRegion) {
            positionStyle = positionStyle || {};

            if (actualRegion.bottom >= constrainRegion.bottom) {
              positionStyle.maxHeight = constrainRegion.bottom - actualRegion.top;
            }
          }

          if (positionStyle) {
            _this10.setState({
              positionStyle: positionStyle
            });
          }
        };

        if (!skipReset) {
          this.node.style.transform = 'translate3d(0px, 0px, 0px)';
          this.node.style.visibility = 'hidden';
          this.node.style.top = '0px';
          this.node.style.left = '0px';
        }

        raf(doAlign);
      }
    }
  }, {
    key: "setFocusedIndex",
    value: function setFocusedIndex(newFocusedItem) {
      if (this.props.enableKeyboardNavigation) {
        var focusedItem = this.state.focusedItem;

        if (focusedItem === newFocusedItem) {
          newFocusedItem = null;
        }

        this.scrollItemIntoView(newFocusedItem);
        this.setState({
          focusedItem: newFocusedItem
        });
      }
    }
  }, {
    key: "getItemDOMNodeByIndex",
    value: function getItemDOMNodeByIndex(index) {
      var item = this.getItemByIndex(index);
      var itemNode = item && item.getDOMNode();
      return itemNode;
    }
  }, {
    key: "getItemByIndex",
    value: function getItemByIndex(index) {
      return this.childrenRefs[index];
    }
  }, {
    key: "getItemPropsByIndex",
    value: function getItemPropsByIndex(index) {
      var item = this.getItemByIndex(index);
      return item && item.props;
    }
  }, {
    key: "getFocusedItemProps",
    value: function getFocusedItemProps() {
      var focusedItemIndex = this.state.focusedItem;
      var focusedItemProps = this.getItemPropsByIndex(focusedItemIndex);
      return focusedItemProps;
    }
  }, {
    key: "getFocusedItem",
    value: function getFocusedItem() {
      return this.state.focusedItem != null && this.getItemByIndex(this.state.focusedItem);
    }
  }, {
    key: "focus",
    value: function focus() {
      if (!this.node) {
        return;
      }

      if (this.node.focus) {
        this.node.focus();
      }
    }
  }, {
    key: "hasSubMenuOpened",
    value: function hasSubMenuOpened() {
      return this.state.activeSubMenuIndex != null;
    }
  }, {
    key: "isSubMenu",
    value: function isSubMenu() {
      return !!this.props.subMenu;
    }
  }, {
    key: "doesAnyItemHasSubMenu",
    value: function doesAnyItemHasSubMenu() {
      var props = this.props;
      return props.items && !!props.items.filter(function (item) {
        return item.items && item.items.length;
      }).length;
    }
  }, {
    key: "dosAnyItemHaveSelectInput",
    value: function dosAnyItemHaveSelectInput() {
      var _this11 = this;

      var props = this.props;
      return props.items && !!props.items.filter(function (item) {
        return item[_this11.props.nameProperty];
      }).length;
    }
  }, {
    key: "hasGeneralFocus",
    value: function hasGeneralFocus() {
      var hasFocus = this.hasFocus();

      if (hasFocus) {
        return hasFocus;
      }

      if (this.hasSubMenuOpened()) {
        return this.hasSubMenuFocus();
      }

      return this.hasChildFocus();
    }
  }, {
    key: "hasSubMenuFocus",
    value: function hasSubMenuFocus() {
      if (this.subMenu) {
        return this.subMenu.hasFocus();
      }

      return null;
    }
  }, {
    key: "hasFocus",
    value: function hasFocus() {
      return globalObject.document ? this.node === globalObject.document.activeElement : false;
    }
  }, {
    key: "hasChildFocus",
    value: function hasChildFocus() {
      if (!globalObject.document) {
        return false;
      }

      return (0, _containsNode.default)(this.node, globalObject.document.activeElement);
    }
  }, {
    key: "onSubmenuWillUnmount",
    value: function onSubmenuWillUnmount(instance, config) {
      var _this12 = this;

      if (config && config.hasFocus) {
        setTimeout(function () {
          _this12.focus();
        }, 0);
      }
    }
  }, {
    key: "focusFirstItem",
    value: function focusFirstItem() {
      var fistNonDisabledItem = (0, _getFirstNonDisabledItem.default)(this.props.items);
      this.focusItem(fistNonDisabledItem);
    }
  }, {
    key: "focusItem",
    value: function focusItem(index) {
      this.focus();
      this.setFocusedIndex(index);
    }
  }, {
    key: "getSubmenuNode",
    value: function getSubmenuNode() {
      return this.subMenu && this.subMenu.getNode();
    }
  }, {
    key: "getNode",
    value: function getNode() {
      return this.node;
    }
  }, {
    key: "getSelected",
    value: function getSelected() {
      return this.isSelectedControlled() ? this.props.selected : this.state.selected;
    }
  }, {
    key: "isSelectedControlled",
    value: function isSelectedControlled() {
      return this.props.selected !== undefined;
    }
  }, {
    key: "handleSelectionChange",
    value: function handleSelectionChange(_ref6) {
      var name = _ref6.name,
          value = _ref6.value,
          checked = _ref6.checked,
          multiple = _ref6.multiple;

      var newSelected = _objectSpread({}, this.getSelected());

      var options = {
        name: name,
        value: value,
        checked: checked,
        multiple: multiple
      };

      if (!multiple) {
        newSelected[name] = value;
      } else if (checked) {
        newSelected[name] = value === undefined ? name : value;
      }

      if (!checked) {
        if (multiple || this.props.allowUnselect) {
          delete newSelected[name];
        }
      }

      this.setSelected(newSelected, options);
    }
  }, {
    key: "setSelected",
    value: function setSelected(newSelected, options) {
      if (!this.isSelectedControlled()) {
        this.setState({
          selected: newSelected
        });
      }

      this.props.onSelectionChange(newSelected, options);
    }
  }, {
    key: "handleSubmenuSelectionChange",
    value: function handleSubmenuSelectionChange(selected, options) {
      this.setSelected(selected, options);
    }
  }, {
    key: "getExpandedIndex",
    value: function getExpandedIndex() {
      return this.state.activeSubMenuIndex;
    }
  }, {
    key: "isSeparator",
    value: function isSeparator(index) {
      var props = this.props;
      var separatorIndexes = (0, _getSeparatorIndexes.default)(props.items);
      return separatorIndexes.indexOf(index) !== -1;
    }
  }]);
  return InovuaMenu;
}(_reactClass.default);

InovuaMenu.defaultProps = {
  rootClassName: 'inovua-react-toolkit-menu',
  depth: 0,
  rtl: false,
  isMenu: true,
  enableScroll: true,
  submenuStyle: null,
  scrollerProps: {},
  theme: 'default-light',
  dismissOnClick: true,
  disableScroller: false,
  shadow: true,
  submenuAlignOffset: _submenuAlignPositions.alignOffsetLTR,
  rtlSubmenuAlignOffset: _submenuAlignPositions.alignOffsetRTL,
  showSubMenuDelay: 150,
  hideSubMenuDelay: 150,
  expanderSize: 10,
  scrollOnMouseEnter: true,
  onClick: function onClick() {},
  onSelectionChange: function onSelectionChange() {},
  columns: ['label'],
  items: null,
  maxHeight: 'auto',
  scrollArrowIncrementType: 'step',
  enableAnimation: true,
  fadeDuration: 100,
  fadeTransitionFunction: 'ease',
  enableRootAnimation: false,
  itemStyle: {},
  itemOverStyle: {},
  itemDisabledStyle: {},
  itemExpandedStyle: {},
  cellStyle: {},
  stopClickPropagation: true,
  stopBlurPropagation: true,
  scrollProps: {},
  inTriangleWaitDelay: 300,
  alignOffset: {
    x: 0,
    y: 0
  },
  simulateClickOnEnterKeyPress: true,
  enableKeyboardNavigation: true,
  defaultFocusedItem: null,
  autoFocus: false,
  closeSubMenu: function closeSubMenu() {},
  closeSubmenuRecursively: function closeSubmenuRecursively() {},
  onDismiss: function onDismiss() {},
  componentWillUnmount: function componentWillUnmount() {},
  componentDidMount: function componentDidMount() {},
  useMouseInTriangleCheck: false,
  allowUnselect: false,
  enableSelection: false,
  nameProperty: 'name',
  valueProperty: 'value',
  selectionInputPosition: 'start',
  defaultSelected: {},
  selectOnClick: true,
  checkIconSize: 16,
  radioIconSize: 16,
  notifyResizeDelay: 16,
  browserNativeSelectInputs: false,
  showWarnings: !_uglified.default
};
InovuaMenu.propTypes = {
  rootClassName: _propTypes.default.string,
  items: _propTypes.default.array,
  columns: _propTypes.default.array,
  dismissOnClick: _propTypes.default.bool,
  autoDismiss: _propTypes.default.bool,
  disableScroller: _propTypes.default.bool,
  showSubMenuDelay: _propTypes.default.number,
  hideSubMenuDelay: _propTypes.default.number,
  notifyResizeDelay: _propTypes.default.number,
  scrollOnMouseEnter: _propTypes.default.bool,
  padding: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  border: _propTypes.default.string,
  borderRadius: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  rowActiveStyle: _propTypes.default.object,
  rowOverStyle: _propTypes.default.object,
  rowStyle: _propTypes.default.object,
  maxHeight: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  submenuMaxHeight: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  minSize: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string, _propTypes.default.shape({
    height: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
    width: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
  })]),
  maxSize: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string, _propTypes.default.shape({
    height: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
    width: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
  })]),
  onClick: _propTypes.default.func,
  showScrollArrows: _propTypes.default.bool,
  scrollProps: _propTypes.default.object,
  scrollArrowIncrementType: _propTypes.default.oneOf(['step', 'page']),
  renderScroller: _propTypes.default.func,
  enableAnimation: _propTypes.default.bool,
  fadeDuration: _propTypes.default.number,
  fadeTransitionFunction: _propTypes.default.string,
  enableRootAnimation: _propTypes.default.bool,
  itemStyle: _propTypes.default.object,
  itemClassName: _propTypes.default.string,
  itemActiveStyle: _propTypes.default.object,
  itemActiveClassName: _propTypes.default.string,
  itemOverStyle: _propTypes.default.object,
  itemOverClassName: _propTypes.default.string,
  itemDisabledStyle: _propTypes.default.object,
  itemDisabledClassName: _propTypes.default.string,
  itemExpandedStyle: _propTypes.default.object,
  itemExpandedClassName: _propTypes.default.string,
  itemFocusedStyle: _propTypes.default.object,
  itemFocusedClassName: _propTypes.default.string,
  itemOverFocusedStyle: _propTypes.default.object,
  visible: _propTypes.default.bool,
  itemHeight: _propTypes.default.number,
  cellStyle: _propTypes.default.object,
  secondaryLabelStyle: _propTypes.default.object,
  labelStyle: _propTypes.default.object,
  titleStyle: _propTypes.default.object,
  alignTo: _propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.func, _propTypes.default.string]),
  inTriangleWaitDelay: _propTypes.default.number,
  alignPositions: _propTypes.default.arrayOf(_propTypes.default.string),
  alignOffset: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object, _propTypes.default.number]),
  submenuAlignOffset: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.shape({
    x: _propTypes.default.number,
    y: _propTypes.default.number
  }), _propTypes.default.number]),
  rtlSubmenuAlignOffset: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.shape({
    x: _propTypes.default.number,
    y: _propTypes.default.number
  }), _propTypes.default.number]),
  alignPosition: _propTypes.default.oneOf([1, -1]),
  rtl: _propTypes.default.bool,
  enableKeyboardNavigation: _propTypes.default.bool,
  defaultFocusedItem: _propTypes.default.number,
  autoFocus: _propTypes.default.bool,
  closeSubMenu: _propTypes.default.func,
  closeSubmenuRecursively: _propTypes.default.func,
  simulateClickOnEnterKeyPress: _propTypes.default.bool,
  onChildClick: _propTypes.default.func,
  onDismiss: _propTypes.default.func,
  expanderStyle: _propTypes.default.object,
  depth: _propTypes.default.number,
  isMenu: _propTypes.default.bool,
  constrainTo: _propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.string, _propTypes.default.bool, _propTypes.default.func]),
  enableScroll: _propTypes.default.bool,
  submenuStyle: _propTypes.default.object,
  scrollerProps: _propTypes.default.object,
  theme: _propTypes.default.string,
  stopClickPropagation: _propTypes.default.bool,
  componentWillUnmount: _propTypes.default.func,
  componentDidMount: _propTypes.default.func,
  itemStyleProps: _propTypes.default.object,
  childrenLength: _propTypes.default.number,
  separatorIndexes: _propTypes.default.string,
  tableClassName: _propTypes.default.string,
  shadow: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.string]),
  stopBlurPropagation: _propTypes.default.bool,
  submenuProps: _propTypes.default.object,
  menuHasSubmenu: _propTypes.default.bool,
  depthSet: _propTypes.default.bool,
  subMenu: _propTypes.default.bool,
  parentIndex: _propTypes.default.number,
  parentMenu: _propTypes.default.object,
  onActivate: _propTypes.default.func,
  onInactivate: _propTypes.default.func,
  expander: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.bool, _propTypes.default.func]),
  expanderSize: _propTypes.default.number,
  overStyle: _propTypes.default.object,
  activeStyle: _propTypes.default.object,
  disabledStyle: _propTypes.default.object,
  expandedStyle: _propTypes.default.object,
  menuSeparatorStyle: _propTypes.default.object,
  useMouseInTriangleCheck: _propTypes.default.bool,
  selected: _propTypes.default.object,
  defaultSelected: _propTypes.default.object,
  allowUnselect: _propTypes.default.bool,
  enableSelection: _propTypes.default.bool,
  nativeScroll: _propTypes.default.bool,
  scrollContainerProps: _propTypes.default.object,
  nameProperty: _propTypes.default.string,
  valueProperty: _propTypes.default.string,
  renderCheckInput: _propTypes.default.func,
  renderRadioInput: _propTypes.default.func,
  onSelectionChange: _propTypes.default.func,
  selectionInputPosition: _propTypes.default.oneOf(['start', 'end']),
  selectOnClick: _propTypes.default.bool,
  checkIconSize: _propTypes.default.number,
  radioIconSize: _propTypes.default.number,
  showWarnings: _propTypes.default.bool,
  updatePositionOnScroll: _propTypes.default.bool,
  browserNativeSelectInputs: _propTypes.default.bool
};
var _default = InovuaMenu;
exports.default = _default;
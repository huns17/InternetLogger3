/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateFilters = exports.hasTypeOperators = exports.hasTypeOperator = exports.default = exports.checkForEmptyValue = exports.buildTypeOperators = exports.buildFilterParam = void 0;

var _filterTypes = _interopRequireDefault(require("./filterTypes"));

var buildTypeOperators = function buildTypeOperators(filterTypes) {
  return Object.keys(filterTypes).reduce(function (acc, filterTypeName) {
    var filterType = filterTypes[filterTypeName];

    if (!filterType || !filterType.operators) {
      return acc;
    }

    var operators = filterType.operators.reduce(function (operatorAccumulator, operator) {
      operatorAccumulator[operator.name] = operator;
      return operatorAccumulator;
    }, {});
    acc[filterTypeName] = operators;
    return acc;
  }, {});
};

exports.buildTypeOperators = buildTypeOperators;

var buildFilterParam = function buildFilterParam(item, fv) {
  var filterTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _filterTypes.default;
  var columnsMap = arguments.length > 3 ? arguments[3] : undefined;
  var filterParam = {};
  var name = fv.name,
      getFilterValue = fv.getFilterValue,
      filterValue = fv.value,
      type = fv.type;
  filterParam.emptyValue = fv.hasOwnProperty('emptyValue') ? fv.emptyValue : filterTypes[type].emptyValue;
  filterParam.filterValue = filterValue;

  if (columnsMap) {
    filterParam.column = columnsMap[name];
  }

  filterParam.data = item;
  filterParam.value = typeof getFilterValue === 'function' ? getFilterValue({
    data: item,
    value: item[name]
  }) : item[name];
  return filterParam;
};

exports.buildFilterParam = buildFilterParam;

var hasTypeOperators = function hasTypeOperators(fn, currentTypeOperators, type) {
  if (!fn && !currentTypeOperators) {
    console.error("No filter of type \"".concat(type, "\" found!"));
    return true;
  }

  return false;
};

exports.hasTypeOperators = hasTypeOperators;

var hasTypeOperator = function hasTypeOperator(fn, currentTypeOperators, type, operator) {
  if (!fn && !currentTypeOperators[operator]) {
    console.error("No operator \"".concat(operator, "\" found for filter type \"").concat(type, "\"!"));
    return true;
  }

  return false;
};

exports.hasTypeOperator = hasTypeOperator;

var checkForEmptyValue = function checkForEmptyValue(filterValue, emptyValue, filterOnEmptyValue) {
  if (filterValue === emptyValue && !filterOnEmptyValue) {
    return true;
  }

  return false;
};

exports.checkForEmptyValue = checkForEmptyValue;

var validateFilters = function validateFilters(fv) {
  var filterTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _filterTypes.default;
  var currentTypeOperators = arguments.length > 2 ? arguments[2] : undefined;
  var active = fv.active,
      fn = fv.fn,
      type = fv.type,
      operator = fv.operator;
  var emptyValue = fv.hasOwnProperty('emptyValue') ? fv.emptyValue : filterTypes[type].emptyValue;
  var filterOnEmptyValue = currentTypeOperators[operator].filterOnEmptyValue;

  if (active === false) {
    return true;
  }

  if (!filterTypes[type]) {
    return true;
  }

  if (hasTypeOperators(fn, currentTypeOperators, type)) {
    return true;
  }

  if (hasTypeOperator(fn, currentTypeOperators, type, operator)) {
    return true;
  }

  if (checkForEmptyValue(fv.value, emptyValue, filterOnEmptyValue)) {
    return true;
  }

  return false;
};

exports.validateFilters = validateFilters;

var doFilter = function doFilter(item, filterValueArray) {
  var filterTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _filterTypes.default;
  var columnsMap = arguments.length > 3 ? arguments[3] : undefined;
  var typeOperators = buildTypeOperators(filterTypes);

  for (var i = 0, len = filterValueArray.length; i < len; i++) {
    var fv = filterValueArray[i];
    var type = fv.type,
        operator = fv.operator,
        fn = fv.fn;
    var currentTypeOperators = typeOperators[type];

    if (validateFilters(fv, filterTypes, currentTypeOperators)) {
      continue;
    }

    var filterParam = buildFilterParam(item, fv, filterTypes, columnsMap);
    var filterFn = fn || currentTypeOperators[operator].fn;

    if (filterFn(filterParam) !== true) {
      return false;
    }
  }

  return true;
};

var filter = function filter(data, filterValueArray) {
  var filterTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _filterTypes.default;
  var columnsMap = arguments.length > 3 ? arguments[3] : undefined;

  var filterFn = function filterFn(item) {
    var result = doFilter(item, filterValueArray, filterTypes, columnsMap);
    return result;
  };

  if (data === undefined) {
    return filterFn;
  }

  return data.filter(filterFn);
};

var _default = filter;
exports.default = _default;
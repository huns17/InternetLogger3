/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.sortCells = exports.getCellIndex = void 0;

var _getColumnRenderRange = _interopRequireDefault(require("./getColumnRenderRange"));

var getCellIndex = function getCellIndex(cell) {
  return cell.getProps().index;
};

exports.getCellIndex = getCellIndex;

var sortCells = function sortCells(cells) {
  return cells.sort(function (cell1, cell2) {
    return getCellIndex(cell1) - getCellIndex(cell2);
  });
};

exports.sortCells = sortCells;

function _default(columnRenderStartIndex) {
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;
  var range = arguments.length > 2 ? arguments[2] : undefined;
  columnRenderStartIndex = columnRenderStartIndex === undefined ? props.columnRenderStartIndex : columnRenderStartIndex;
  range = range || _getColumnRenderRange.default.call(this, columnRenderStartIndex, props);
  var endIndex = range.end;
  var startIndex = range.start;
  var sortedCells = sortCells(this.cells);
  var visibleCellPositions = {};
  sortedCells.forEach(function (cell) {
    visibleCellPositions[getCellIndex(cell)] = true;
  });
  var gaps = [];

  for (; startIndex <= endIndex; startIndex++) {
    if (!visibleCellPositions[startIndex]) {
      gaps.push(startIndex);
    }
  }

  return {
    gaps: gaps,
    range: range
  };
}
/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactCleanProps = _interopRequireDefault(require("../../../packages/react-clean-props"));

var _shallowequal = require("../../../packages/shallowequal");

var _join = _interopRequireDefault(require("../../../packages/join"));

var _clamp = _interopRequireDefault(require("../../../utils/clamp"));

var _Cell = _interopRequireDefault(require("../Cell"));

var _renderCellsMaybeLocked = _interopRequireDefault(require("./renderCellsMaybeLocked"));

var _adjustCellProps = _interopRequireDefault(require("./adjustCellProps"));

var _usePrevious = _interopRequireDefault(require("../../../hooks/usePrevious"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var CLASS_NAME = 'InovuaReactDataGrid__row';

var rowClean = function rowClean(p) {
  var result = _objectSpread({}, p);

  delete result.activeRowRef;
  return result;
};

var skipSelect = function skipSelect(event) {
  event.nativeEvent.skipSelect = true;
};

var getValueForPivotColumn = function getValueForPivotColumn(item, path) {
  return path.reduce(function (acc, field, index) {
    if (!acc || acc[field] == null) {
      return null;
    }

    if (index === path.length - 1) {
      return acc[field];
    }

    return acc[field].pivotSummary || acc[field].values;
  }, item);
};

var getValueForPivotColumnSummary = function getValueForPivotColumnSummary(item, _ref) {
  var path = _ref.pivotSummaryPath;
  var i = 0;
  var root = item;
  var current;

  while ((current = path[i]) && root) {
    if (!root.pivotSummary) {
      return null;
    }

    root = root.pivotSummary[current.value];
    i++;
  }

  if (root && root.pivotColumnSummary) {
    return root.pivotColumnSummary[path[path.length - 1].field];
  }

  return null;
};

var DataGridRow = _react.default.forwardRef(function (props, ref) {
  var cells = (0, _react.useRef)([]);
  var cellRef = (0, _react.useRef)();
  var domRef = (0, _react.useRef)(null);
  var columnRenderStartIndex = (0, _react.useRef)(0);
  var hasBorderTop = (0, _react.useRef)(false);
  var hasBorderBottom = (0, _react.useRef)(false);
  var maxRowspan = (0, _react.useRef)(1);
  var scrollingInProgress = (0, _react.useRef)(false);
  var scrollingDirection = (0, _react.useRef)('vertical');

  var initCells = function initCells() {
    cellRef.current = function (c) {
      if (!c) return;
      cells.current.push(c);
    };
  };

  var cleanupCells = (0, _react.useCallback)(function () {
    cells.current = cells.current.filter(Boolean);
    return cells.current;
  }, []);
  var getCells = (0, _react.useCallback)(function () {
    return cells.current;
  }, []);
  var prevColumnRenderCount = (0, _usePrevious.default)(props.columnRenderCount, props.columnRenderCount);

  if (props.columnRenderCount < prevColumnRenderCount) {
    cleanupCells();
    getCells().forEach(function (cell) {
      if (cell.getProps().computedLocked) {
        return;
      }

      cell.setStateProps(null);
    });
  }

  var getDOMNode = (0, _react.useCallback)(function () {
    return domRef.current;
  }, []);

  var setActiveRowRef = function setActiveRowRef() {
    props.activeRowRef.current = {
      instance: {
        hasBorderBottom: hasBorderBottom.current,
        hasBorderTop: hasBorderTop.current,
        props: props
      },
      node: getDOMNode()
    };
  };

  if (props.active) {
    setActiveRowRef();
  }

  (0, _react.useEffect)(function () {
    initCells();

    if (props.columnRenderStartIndex) {
      setColumnRenderStartIndex(props.columnRenderStartIndex);
    }

    return function () {
      cells.current = [];
    };
  }, []);
  var prevRowIndex = (0, _usePrevious.default)(props.rowIndex, props.rowIndex);
  var prevEditing = (0, _usePrevious.default)(props.editing, props.editing);
  var prevActive = (0, _usePrevious.default)(props.active, props.active);
  (0, _react.useEffect)(function () {
    if (props.groupProps && props.rowIndex !== prevRowIndex) {
      fixForColspan();
    }

    if (props.editing !== prevEditing) {
      updateEditCell();
    }

    if (!prevActive && props.active) {
      setActiveRowRef();
    }
  });
  var onCellUnmount = (0, _react.useCallback)(function (_cellProps, cell) {
    if (cells.current) {
      cells.current = cells.current.filter(function (c) {
        return c !== cell;
      });
    }
  }, []);
  var orderCells = (0, _react.useCallback)(function () {
    var cells = cleanupCells();
    var sortedProps = cells.map(function (c) {
      return c.getProps();
    }).sort(function (p1, p2) {
      return p1.index - p2.index;
    });
    cells.sort(function (cell1, cell2) {
      return cell1.props.renderIndex - cell2.props.renderIndex;
    });
    cells.forEach(function (c, i) {
      c.setStateProps(sortedProps[i]);
    });
  }, [cleanupCells]);
  var updateEditCell = (0, _react.useCallback)(function () {
    var cells = getCells();
    var editColumnIndex = props.editColumnIndex;

    for (var i = 0, len = cells.length, cell; i < len; i++) {
      cell = cells[i];

      if (getCellIndex(cell) === editColumnIndex) {
        setCellIndex(cell, editColumnIndex);
      }

      if (cell.getProps().inEdit) {
        setCellIndex(cell, getCellIndex(cell));
      }
    }
  }, [props.editColumnIndex]);
  var fixForColspan = (0, _react.useCallback)(function () {
    if (props.computedHasColSpan) {
      setColumnRenderStartIndex(columnRenderStartIndex.current);
    }
  }, [props.computedHasColSpan]);
  var setScrolling = (0, _react.useCallback)(function (scrolling) {
    var node = getDOMNode() || domRef.current;
    var scrollingDir = scrollingDirection.current;

    if (scrolling !== false) {
      scrollingDirection.current = scrolling;
    }

    var oldScrollingInProgress = scrollingInProgress.current;
    scrollingDirection.current = scrollingDir;
    scrollingInProgress.current = scrolling ? true : false;

    if (!node) {
      return;
    }

    if (oldScrollingInProgress !== scrollingInProgress.current) {
      var _className = "".concat(CLASS_NAME, "--scrolling");

      if (scrollingInProgress.current) {
        node.classList.add(_className);
      } else {
        node.classList.remove(_className);
      }
    }

    return;
  }, []);
  var renderRowDetails = (0, _react.useCallback)(function (rowDetailsInfo) {
    if (props.computedRenderRowDetails) {
      return props.computedRenderRowDetails(rowDetailsInfo);
    }

    return 'Please specify `renderRowDetails`';
  }, []);
  var onContextMenu = (0, _react.useCallback)(function (event) {
    var passedProps = props.passedProps,
        onRowContextMenu = props.onRowContextMenu;

    if (onRowContextMenu) {
      onRowContextMenu(props, event);
    }

    if (passedProps && passedProps.onContextMenu) {
      passedProps.onContextMenu(event, props);
    }
  }, [props.passedProps, props.passedProps.onContextMenu, props.onRowContextMenu]);
  var setCellIndex = (0, _react.useCallback)(function (cell, index, cellProps) {
    cellProps = cellProps || (props.computedHasColSpan ? getPropsForCells().slice(index, index + 1)[0] : getPropsForCells(index, index)[0]);
    cell.setStateProps(cellProps);
  }, [props.computedHasColSpan]);
  var getCellIndex = (0, _react.useCallback)(function (cell) {
    return cell.getProps().computedVisibleIndex;
  }, []);
  var sortCells = (0, _react.useCallback)(function (cells) {
    return cells.sort(function (cell1, cell2) {
      return getCellIndex(cell1) - getCellIndex(cell2);
    });
  }, []);
  var getCellAt = (0, _react.useCallback)(function (index) {
    return getCells().filter(function (c) {
      return c.getProps().computedVisibleIndex === index;
    })[0];
  }, []);
  var getCellById = (0, _react.useCallback)(function (id) {
    return getCells().filter(function (c) {
      return c.getProps().id === id;
    })[0];
  }, []);
  var getSortedCells = (0, _react.useCallback)(function () {
    return sortCells(getCells().slice());
  }, []);
  var getGaps = (0, _react.useCallback)(function (startIndex, endIndex) {
    var visibleCellPositions = {};
    var sortedCells = getSortedCells();
    sortedCells.forEach(function (cell) {
      var cellProps = cell.getProps();

      if (cellProps.computedLocked) {
        return;
      }

      var computedVisibleIndex = cellProps.computedVisibleIndex,
          computedColspan = cellProps.computedColspan,
          groupProps = cellProps.groupProps;

      if (groupProps && computedVisibleIndex <= groupProps.depth + 1) {
        return;
      }

      visibleCellPositions[computedVisibleIndex] = true;

      if (computedColspan) {
        for (var i = 0; i < computedColspan; i++) {
          visibleCellPositions[computedVisibleIndex + i] = true;
        }
      }
    });
    var gaps = [];

    for (; startIndex <= endIndex; startIndex++) {
      if (!visibleCellPositions[startIndex]) {
        gaps.push(startIndex);
      }
    }

    return gaps;
  }, []);
  var getVirtualizeColumns = (0, _react.useCallback)(function () {
    return props.virtualizeColumns;
    return scrollingDirection.current !== 'horizontal' ? props.virtualizeColumns : false;
  }, [props.virtualizeColumns]);
  var toggleRowExpand = (0, _react.useCallback)(function (rowIndex) {
    if (typeof rowIndex !== 'number') {
      rowIndex = props.realIndex;
    }

    props.toggleRowExpand(rowIndex);
  }, [props.realIndex, props.toggleRowExpand]);
  var toggleNodeExpand = (0, _react.useCallback)(function (rowIndex) {
    if (typeof rowIndex !== 'number') {
      rowIndex = props.realIndex;
    }

    props.toggleNodeExpand(rowIndex);
  }, [props.realIndex, props.toggleNodeExpand]);
  var loadNodeAsync = (0, _react.useCallback)(function () {
    var _props$loadNodeAsync;

    (_props$loadNodeAsync = props.loadNodeAsync) === null || _props$loadNodeAsync === void 0 ? void 0 : _props$loadNodeAsync.call(props, props.data);
  }, [props.loadNodeAsync, props.data]);
  var isRowExpandable = (0, _react.useCallback)(function (rowIndex) {
    if (typeof rowIndex !== 'number') {
      rowIndex = props.realIndex;
    }

    return props.isRowExpandableAt(rowIndex);
  }, [props.realIndex, props.isRowExpandableAt]);
  var setRowExpanded = (0, _react.useCallback)(function (expanded, _) {
    var rowIndex = props.realIndex;
    var _expanded = expanded;

    if (typeof expanded === 'number') {
      rowIndex = expanded;
      _expanded = _;
    }

    props.setRowExpanded(rowIndex, _expanded);
  }, [props.realIndex, props.setRowExpanded]);

  var getCurrentGaps = function getCurrentGaps() {};

  var setColumnRenderStartIndex = (0, _react.useCallback)(function (columnStartIndex) {
    if (columnRenderStartIndex.current === columnStartIndex) {
      return;
    }

    columnRenderStartIndex.current = columnStartIndex;

    if (getVirtualizeColumns() === false) {
      return;
    }

    var newCellProps;
    var renderRange;
    var cellPropsAt;

    if (props.computedHasColSpan) {
      newCellProps = getPropsForCells();
      renderRange = getColumnRenderRange(newCellProps);

      cellPropsAt = function cellPropsAt(index) {
        return newCellProps[index];
      };
    } else {
      var _renderRange, _renderRange2;

      renderRange = getColumnRenderRange();
      newCellProps = getPropsForCells((_renderRange = renderRange) === null || _renderRange === void 0 ? void 0 : _renderRange.start, (((_renderRange2 = renderRange) === null || _renderRange2 === void 0 ? void 0 : _renderRange2.end) || 0) + 1);

      cellPropsAt = function cellPropsAt(index) {
        return newCellProps.filter(function (cellProps) {
          return cellProps.computedVisibleIndex === index;
        })[0];
      };
    }

    if (!renderRange) {
      return;
    }

    var _renderRange3 = renderRange,
        start = _renderRange3.start,
        end = _renderRange3.end;
    var gaps = getGaps(start, end);

    if (!gaps.length) {
      return;
    }

    var gapsMap = gaps.reduce(function (acc, gapIndex) {
      acc[gapIndex] = true;
      return acc;
    }, {});
    var tempCellMap = {};
    var calls = [];
    getCells().forEach(function (cell) {
      var cellProps = cell.getProps();
      var groupProps = cellProps.groupProps,
          cellIndex = cellProps.computedVisibleIndex,
          computedColspan = cellProps.computedColspan,
          computedLocked = cellProps.computedLocked;

      if (computedLocked) {
        return;
      }

      if (!props.groupColumn && groupProps && cellIndex <= groupProps.depth + 1) {
        return;
      }

      var outside = cellIndex < start || cellIndex > end || cellIndex === undefined;

      if (outside && computedColspan) {
        var endCellIndex = cellIndex + (computedColspan - 1);
        outside = cellIndex < start && endCellIndex < start || cellIndex > end;
      }

      var outOfView = outside || tempCellMap[cellIndex] || gapsMap[cellIndex];
      tempCellMap[cellIndex] = true;
      var newIndex;

      if (outOfView && gaps.length) {
        newIndex = gaps[gaps.length - 1];
        calls.push([cell, newIndex]);
        gaps.length -= 1;
      }
    });
    calls.forEach(function (call) {
      var cell = call[0];
      var newIndex = call[1];
      setCellIndex(cell, newIndex, cellPropsAt(newIndex));
    });
  }, [props.columnRenderStartIndex, props.computedHasColSpan, props.columnRenderCount, props.virtualizeColumns]);
  var propsRef = (0, _react.useRef)(props);
  propsRef.current = props;

  var getPropsForCells = function getPropsForCells(startIndex, endIndex) {
    var _columns$filter$;

    var props = propsRef.current;
    var initialColumns = props.columns;
    var columns = initialColumns;
    var hasLockedStart = props.hasLockedStart,
        data = props.data,
        onGroupToggle = props.onGroupToggle,
        computedPivot = props.computedPivot,
        rowHeight = props.rowHeight,
        remoteRowIndex = props.remoteRowIndex,
        initialRowHeight = props.initialRowHeight,
        lastLockedStartIndex = props.lastLockedStartIndex,
        lastLockedEndIndex = props.lastLockedEndIndex,
        lastUnlockedIndex = props.lastUnlockedIndex,
        minRowHeight = props.minRowHeight,
        realIndex = props.realIndex,
        showHorizontalCellBorders = props.showHorizontalCellBorders,
        showVerticalCellBorders = props.showVerticalCellBorders,
        empty = props.empty,
        treeColumn = props.treeColumn,
        groupColumn = props.groupColumn,
        totalDataCount = props.totalDataCount,
        depth = props.depth,
        dataSourceArray = props.dataSourceArray,
        computedGroupBy = props.computedGroupBy,
        groupProps = props.groupProps,
        summaryProps = props.summaryProps,
        indexInGroup = props.indexInGroup,
        firstUnlockedIndex = props.firstUnlockedIndex,
        firstLockedEndIndex = props.firstLockedEndIndex,
        selectAll = props.selectAll,
        deselectAll = props.deselectAll,
        columnUserSelect = props.columnUserSelect,
        multiSelect = props.multiSelect,
        selection = props.selection,
        setRowSelected = props.setRowSelected,
        computedRowExpandEnabled = props.computedRowExpandEnabled,
        rtl = props.rtl,
        lastRow = props.last,
        computedCellSelection = props.computedCellSelection,
        lastNonEmpty = props.lastNonEmpty,
        maxVisibleRows = props.maxVisibleRows,
        onCellClick = props.onCellClick,
        editStartEvent = props.editStartEvent,
        naturalRowHeight = props.naturalRowHeight,
        renderNodeTool = props.renderNodeTool,
        computedTreeEnabled = props.computedTreeEnabled,
        rowExpanded = props.expanded,
        expandGroupTitle = props.expandGroupTitle,
        expandColumnFn = props.expandColumn,
        onCellSelectionDraggerMouseDown = props.onCellSelectionDraggerMouseDown,
        onCellMouseDown = props.onCellMouseDown,
        onCellEnter = props.onCellEnter,
        computedCellMultiSelectionEnabled = props.computedCellMultiSelectionEnabled,
        getCellSelectionKey = props.getCellSelectionKey,
        lastCellInRange = props.lastCellInRange,
        computedRowspans = props.computedRowspans,
        renderIndex = props.renderIndex,
        nativeScroll = props.nativeScroll,
        onDragRowMouseDown = props.onDragRowMouseDown,
        theme = props.theme,
        onContextMenu = props.onContextMenu,
        setActiveIndex = props.setActiveIndex,
        renderTreeCollapseTool = props.renderTreeCollapseTool,
        renderTreeExpandTool = props.renderTreeExpandTool,
        renderTreeLoadingTool = props.renderTreeLoadingTool,
        onColumnMouseEnter = props.onColumnMouseEnter,
        onColumnMouseLeave = props.onColumnMouseLeave,
        columnIndexHovered = props.columnIndexHovered,
        computedEnableColumnHover = props.computedEnableColumnHover,
        columnHoverClassName = props.columnHoverClassName,
        enableColumnAutosize = props.enableColumnAutosize,
        renderRowDetailsExpandIcon = props.renderRowDetailsExpandIcon,
        renderRowDetailsCollapsedIcon = props.renderRowDetailsCollapsedIcon;
    var expandColumnId = expandColumnFn ? expandColumnFn({
      data: data
    }) : undefined;
    var virtualizeColumns = getVirtualizeColumns();
    var visibleColumnCount = columns.length;
    var expandColumnIndex = expandColumnId ? (_columns$filter$ = columns.filter(function (c) {
      return c.id === expandColumnId;
    })[0]) === null || _columns$filter$ === void 0 ? void 0 : _columns$filter$.computedVisibleIndex : undefined;

    if (startIndex !== undefined) {
      columns = columns.slice(startIndex, endIndex ? endIndex + 1 : startIndex + 1);
    }

    startIndex = startIndex || 0;
    var hasBorderTopVar = false;
    var hasBorderBottomVar = false;
    var hiddenCells = {};
    var belongsToColspan = {};
    var columnsTillColspanStart = {};
    var lastInGroup = indexInGroup == props.groupCount - 1;
    var activeCell = props.computedActiveCell && getCellSelectionKey ? getCellSelectionKey.apply(void 0, (0, _toConsumableArray2.default)(props.computedActiveCell)) : null;
    var lastInRange = lastCellInRange || activeCell || null;
    var maxRowspanVar = 1;
    var cellPropsArray = columns.map(function (column, xindex) {
      var theColumnIndex = xindex + startIndex;
      var columnProps = column;
      var name = columnProps.name,
          computedVisibleIndex = columnProps.computedVisibleIndex;
      var value = data ? data[name] : null;
      var rowIndex = realIndex;

      if (groupProps && data && data.groupColumnSummary) {
        value = data.groupColumnSummary[name];
      }

      if (groupProps && data && column.groupColumn) {
        value = data.value;
      }

      if (columnProps.pivotColumnPath) {
        value = data.pivotSummary ? getValueForPivotColumn(data.pivotSummary, columnProps.pivotColumnPath) : value;
      }

      if (columnProps.pivotGrandSummaryColumn) {} else {
        if (columnProps.pivotSummaryPath) {
          value = data.pivotSummary ? getValueForPivotColumnSummary(data, {
            pivotSummaryPath: columnProps.pivotSummaryPath,
            pivotGrandSummaryColumn: columnProps.pivotGrandSummaryColumn
          }) : value;
        }
      }

      var defaults = {};

      if (columnUserSelect !== undefined) {
        defaults.userSelect = columnUserSelect;
      }

      var groupTitleCell = !groupColumn && groupProps && groupProps.depth + 1 == computedVisibleIndex;
      var groupExpandCell = !groupColumn && groupProps && groupProps.depth == computedVisibleIndex;
      var hidden = groupProps ? expandGroupTitle && !groupColumn ? computedVisibleIndex > groupProps.depth + 1 : false : false;

      if (expandColumnIndex != null && computedVisibleIndex > expandColumnIndex) {
        hidden = true;
      }

      var cellProps = _objectSpread(_objectSpread(_objectSpread({}, defaults), columnProps), {}, {
        remoteRowIndex: remoteRowIndex,
        indexInColumns: theColumnIndex,
        depth: depth,
        expandColumnIndex: expandColumnIndex,
        expandColumn: expandColumnIndex === computedVisibleIndex,
        editStartEvent: editStartEvent,
        onCellClick: onCellClick,
        computedRowspan: computedRowspans ? computedRowspans[column.id] : 1,
        groupNestingSize: props.groupNestingSize,
        treeNestingSize: props.treeNestingSize,
        data: data,
        naturalRowHeight: naturalRowHeight,
        totalDataCount: totalDataCount,
        onCellSelectionDraggerMouseDown: onCellSelectionDraggerMouseDown,
        onCellMouseDown: onCellMouseDown,
        onCellEnter: onCellEnter,
        rtl: rtl,
        computedPivot: computedPivot,
        selectAll: selectAll,
        deselectAll: deselectAll,
        selection: selection,
        renderNodeTool: renderNodeTool,
        onDragRowMouseDown: onDragRowMouseDown,
        multiSelect: multiSelect,
        treeColumn: treeColumn !== undefined ? treeColumn === columnProps.id : false,
        setRowSelected: setRowSelected,
        setRowExpanded: computedRowExpandEnabled ? setRowExpanded : null,
        toggleRowExpand: computedRowExpandEnabled ? toggleRowExpand : null,
        toggleNodeExpand: computedTreeEnabled ? toggleNodeExpand : null,
        loadNodeAsync: computedTreeEnabled ? loadNodeAsync : null,
        rowActive: props.active,
        rowSelected: props.selected,
        rowExpanded: rowExpanded,
        rowIndex: rowIndex,
        rowHeight: rowHeight,
        groupColumnVisible: !!groupColumn,
        minRowHeight: minRowHeight,
        groupProps: groupProps,
        summaryProps: summaryProps,
        empty: empty,
        computedGroupBy: computedGroupBy,
        nativeScroll: nativeScroll,
        computedCellMultiSelectionEnabled: computedCellMultiSelectionEnabled,
        lastRowInGroup: lastInGroup,
        columnIndex: computedVisibleIndex,
        first: computedVisibleIndex == 0,
        last: computedVisibleIndex == visibleColumnCount - 1,
        value: value,
        virtualizeColumns: virtualizeColumns,
        hasLockedStart: hasLockedStart,
        rowIndexInGroup: indexInGroup,
        rowRenderIndex: renderIndex,
        hidden: hidden,
        groupTitleCell: groupTitleCell,
        groupExpandCell: groupExpandCell,
        isRowExpandable: computedRowExpandEnabled ? isRowExpandable : null,
        tryRowCellEdit: tryRowCellEdit,
        tryNextRowEdit: tryNextRowEdit,
        onGroupToggle: onGroupToggle,
        initialRowHeight: rowExpanded ? initialRowHeight : rowHeight,
        theme: theme,
        onContextMenu: onContextMenu,
        setActiveIndex: setActiveIndex,
        renderTreeCollapseTool: renderTreeCollapseTool,
        renderTreeExpandTool: renderTreeExpandTool,
        renderTreeLoadingTool: renderTreeLoadingTool,
        onColumnMouseEnter: onColumnMouseEnter,
        onColumnMouseLeave: onColumnMouseLeave,
        columnIndexHovered: columnIndexHovered,
        computedEnableColumnHover: computedEnableColumnHover,
        columnHoverClassName: columnHoverClassName,
        renderRowDetailsExpandIcon: renderRowDetailsExpandIcon,
        renderRowDetailsCollapsedIcon: renderRowDetailsCollapsedIcon
      });

      if (computedCellSelection && getCellSelectionKey) {
        cellProps.cellSelected = computedCellSelection[getCellSelectionKey(rowIndex, computedVisibleIndex)];

        if (cellProps.cellSelected) {
          cellProps.hasRightSelectedSibling = cellProps.last ? false : computedCellSelection[getCellSelectionKey(rowIndex, computedVisibleIndex + 1)];
          cellProps.hasLeftSelectedSibling = cellProps.first ? false : computedCellSelection[getCellSelectionKey(rowIndex, computedVisibleIndex - 1)];
          cellProps.hasTopSelectedSibling = computedCellSelection[getCellSelectionKey(rowIndex - 1, computedVisibleIndex)];
          cellProps.hasBottomSelectedSibling = computedCellSelection[getCellSelectionKey(rowIndex + 1, computedVisibleIndex)];
        }
      }

      if (getCellSelectionKey && (activeCell || lastInRange)) {
        var cellKey = getCellSelectionKey(rowIndex, computedVisibleIndex);

        if (activeCell && activeCell === cellKey) {
          cellProps.cellActive = true;
        }

        if (lastInRange && lastInRange === cellKey) {
          cellProps.lastInRange = true;
        }
      }

      if (cellProps.visibilityTransitionDuration || cellProps.showTransitionDuration || cellProps.hideTransitionDuration) {
        cellProps.onTransitionEnd = onTransitionEnd(cellProps, columnProps);
      }

      if (props.editing && props.editColumnIndex === cellProps.columnIndex) {
        cellProps.inEdit = true;
        cellProps.editValue = props.editValue;
      }

      if (virtualizeColumns && !cellProps.computedLocked || enableColumnAutosize || props.editable || cellProps.computedEditable) {
        cellProps.cellRef = cellRef.current;
        cellProps.onUnmount = onCellUnmount;
      }

      var computedLocked = cellProps.computedLocked,
          colspan = cellProps.colspan;
      var lockedStart = computedLocked === 'start';
      var lockedEnd = computedLocked === 'end';
      var unlocked = !computedLocked;
      var computedColspan = 1;

      if (typeof colspan === 'function') {
        computedColspan = cellProps.computedColspan = Math.max(1, colspan({
          remoteRowIndex: remoteRowIndex,
          dataSourceArray: dataSourceArray,
          data: cellProps.data,
          value: cellProps.value,
          rowIndex: cellProps.rowIndex,
          column: column,
          columns: columns,
          empty: empty
        }));

        if (lockedStart) {
          computedColspan = (0, _clamp.default)(computedColspan, 1, Math.max(lastLockedStartIndex - computedVisibleIndex + 1, 1));
        }

        if (lockedEnd) {
          computedColspan = (0, _clamp.default)(computedColspan, 1, Math.max(lastLockedEndIndex - computedVisibleIndex + 1, 1));
        }

        if (unlocked) {
          computedColspan = (0, _clamp.default)(computedColspan, 1, Math.max(lastUnlockedIndex - computedVisibleIndex + 1, 1));
        }

        if (computedColspan > 1) {
          cellProps.computedWidth = columns.slice(theColumnIndex, theColumnIndex + computedColspan).reduce(function (sum, col) {
            if (col.id !== column.id) {
              hiddenCells[col.id] = true;

              if (column.computedLocked === col.computedLocked) {
                belongsToColspan[col.id] = column.id;
                columnsTillColspanStart[col.id] = col.computedVisibleIndex - column.computedVisibleIndex;
              }
            }

            return sum + col.computedWidth;
          }, 0);
        }
      }

      cellProps.lastInSection = lockedStart ? computedVisibleIndex + computedColspan - 1 === firstUnlockedIndex - 1 : lockedEnd ? computedVisibleIndex + computedColspan - 1 === visibleColumnCount - 1 : computedVisibleIndex + computedColspan - 1 === firstLockedEndIndex - 1;
      cellProps.firstInSection = lockedStart ? computedVisibleIndex === 0 : lockedEnd ? computedVisibleIndex === firstLockedEndIndex : computedVisibleIndex === firstUnlockedIndex;

      if (computedGroupBy && !groupColumn && !!cellProps.depth) {
        cellProps.noBackground = computedVisibleIndex < cellProps.depth;
      }

      if (hiddenCells[column.id]) {
        cellProps.hidden = true;
      }

      if (belongsToColspan[column.id]) {
        cellProps.computedColspanedBy = belongsToColspan[column.id];
        cellProps.computedColspanToStart = columnsTillColspanStart[column.id];
      }

      if (groupProps && !groupColumn || expandColumnIndex != null) {
        (0, _adjustCellProps.default)(cellProps, props);
      }

      if (cellProps.hidden) {
        cellProps.last = false;
        cellProps.lastInSection = false;
      } else {
        cellProps.showBorderLeft = showVerticalCellBorders && computedVisibleIndex > 0;
        cellProps.showBorderBottom = showHorizontalCellBorders;

        if (!showVerticalCellBorders && computedGroupBy) {
          cellProps.showBorderLeft = computedVisibleIndex > 0 && computedVisibleIndex <= computedGroupBy.length;
        }

        if (computedGroupBy) {
          if (!cellProps.groupProps) {
            cellProps.showBorderBottom = groupColumn ? showHorizontalCellBorders : computedVisibleIndex >= computedGroupBy.length && showHorizontalCellBorders;
            var summaryBefore = indexInGroup === 0 && !groupColumn ? dataSourceArray[rowIndex - indexInGroup] : null;

            if (summaryBefore && summaryBefore.__summary && computedVisibleIndex >= computedGroupBy.length) {
              cellProps.showBorderBottom = false;
            }
          }

          if (!empty) {
            if (!groupColumn && (computedVisibleIndex < computedGroupBy.length || lastInGroup)) {
              cellProps.showBorderBottom = rowExpanded;
            }

            if (cellProps.groupProps) {
              cellProps.showBorderBottom = cellProps.groupProps.collapsed ? !!groupColumn : groupColumn ? true : computedVisibleIndex > cellProps.groupProps.depth && cellProps.groupProps.depth >= computedGroupBy.length;
              cellProps.showBorderTop = groupTitleCell || groupExpandCell || !expandGroupTitle && !groupColumn;
            } else if (indexInGroup === 0 && !groupColumn) {
              cellProps.showBorderTop = computedVisibleIndex >= computedGroupBy.length;
            }

            if (lastNonEmpty && !lastRow && showHorizontalCellBorders) {
              cellProps.showBorderBottom = computedVisibleIndex >= (cellProps.groupProps ? cellProps.groupProps.depth : computedGroupBy.length);
            }
          } else if (rowIndex > 0 && showHorizontalCellBorders) {
            if (rowIndex === totalDataCount) {
              cellProps.showBorderBottom = computedVisibleIndex >= computedGroupBy.length;
            } else {
              cellProps.showBorderBottom = computedGroupBy ? computedVisibleIndex >= computedGroupBy.length : true;
            }
          }
        }

        if (lastRow) {
          cellProps.showBorderBottom = rowIndex < maxVisibleRows - 1 || rowExpanded;
        }

        if (lockedStart && cellProps.lastInSection) {
          cellProps.showBorderRight = true;
        }

        if (lockedEnd && computedVisibleIndex === firstLockedEndIndex) {
          cellProps.showBorderLeft = true;
        }

        if (cellProps.groupProps && computedVisibleIndex >= cellProps.groupProps.depth + 1 && !groupColumn && props.expandGroupTitle) {
          cellProps.showBorderLeft = false;
        }

        if (cellProps.summaryProps) {
          cellProps.showBorderBottom = lastRow;
          cellProps.showBorderTop = computedVisibleIndex > cellProps.summaryProps.depth;

          if (cellProps.summaryProps.position == 'start') {
            cellProps.showBorderTop = computedVisibleIndex >= cellProps.summaryProps.depth;
            cellProps.showBorderBottom = false;
          }

          cellProps.showBorderLeft = showVerticalCellBorders ? true : computedVisibleIndex <= cellProps.summaryProps.depth;

          if (computedVisibleIndex > cellProps.summaryProps.depth && computedVisibleIndex <= computedGroupBy.length && !groupColumn) {
            cellProps.showBorderLeft = false;
          }

          if (computedVisibleIndex === 0) {
            cellProps.showBorderLeft = false;
          }

          cellProps.noBackground = !groupColumn;
        }

        if (firstUnlockedIndex === computedVisibleIndex && hasLockedStart) {
          cellProps.showBorderLeft = false;
        }

        if (cellProps.groupSpacerColumn && rowExpanded) {
          cellProps.showBorderBottom = false;
        }

        if (cellProps.last) {
          cellProps.showBorderRight = true;
        }

        var prevColumn = columns[theColumnIndex - 1];
        var nextColumn = columns[theColumnIndex + 1];

        if (nextColumn && nextColumn.prevBorderRight !== undefined && !(lockedStart && cellProps.lastInSection)) {
          cellProps.showBorderRight = nextColumn.prevBorderRight;
        }

        if (prevColumn && prevColumn.nextBorderLeft !== undefined) {
          cellProps.showBorderLeft = prevColumn.nextBorderLeft;
        }

        if (columnProps.showBorderRight !== undefined) {
          cellProps.showBorderRight = columnProps.showBorderRight;
        }

        if (columnProps.showBorderLeft !== undefined) {
          cellProps.showBorderLeft = columnProps.showBorderLeft;
        }
      }

      if (cellProps.computedEditable) {
        cellProps.onEditStopForRow = onCellStopEdit;
        cellProps.onEditStartForRow = onCellStartEdit;
        cellProps.onEditCancelForRow = onCellEditCancel;
        cellProps.onEditValueChangeForRow = onCellEditValueChange;
        cellProps.onEditCompleteForRow = onCellEditComplete;
      }

      hasBorderBottomVar = hasBorderBottomVar || cellProps.showBorderBottom;
      hasBorderTopVar = hasBorderTopVar || cellProps.showBorderTop;
      return cellProps;
    });
    maxRowspan.current = maxRowspanVar;

    if (props.computedEnableRowspan) {
      props.setRowSpan && props.setRowSpan(maxRowspan.current);
    }

    hasBorderTop.current = hasBorderTopVar;
    hasBorderBottom.current = hasBorderBottomVar;
    return cellPropsArray;
  };

  var onCellStopEdit = (0, _react.useCallback)(function (value, cellProps) {
    if (props.onEditStop) {
      props.onEditStop({
        value: value,
        data: cellProps.data,
        rowId: props.getItemId(cellProps.data),
        columnId: cellProps.id,
        columnIndex: cellProps.computedVisibleIndex,
        rowIndex: cellProps.rowIndex,
        cellProps: cellProps
      });
    }
  }, [props.onEditStop]);
  var onCellStartEdit = (0, _react.useCallback)(function (value, cellProps) {
    if (props.onEditStart) {
      props.onEditStart({
        data: cellProps.data,
        value: value,
        rowId: props.getItemId(cellProps.data),
        columnId: cellProps.id,
        columnIndex: cellProps.computedVisibleIndex,
        rowIndex: cellProps.rowIndex,
        cellProps: cellProps
      });
    }
  }, [props.onEditStart]);
  var onCellEditCancel = (0, _react.useCallback)(function (cellProps) {
    if (props.onEditCancel) {
      props.onEditCancel({
        data: cellProps.data,
        rowId: props.getItemId(cellProps.data),
        columnIndex: cellProps.computedVisibleIndex,
        columnId: cellProps.id,
        rowIndex: cellProps.rowIndex,
        cellProps: cellProps
      });
    }
  }, [props.onEditCancel]);
  var onCellEditValueChange = (0, _react.useCallback)(function (value, cellProps) {
    if (props.onEditValueChange) {
      props.onEditValueChange({
        value: value,
        data: cellProps.data,
        rowId: props.getItemId(cellProps.data),
        columnId: cellProps.id,
        columnIndex: cellProps.computedVisibleIndex,
        rowIndex: cellProps.rowIndex,
        cellProps: cellProps
      });
    }
  }, [props.onEditValueChange]);
  var onCellEditComplete = (0, _react.useCallback)(function (value, cellProps) {
    if (props.onEditComplete) {
      props.onEditComplete({
        value: value,
        data: cellProps.data,
        rowId: props.getItemId(cellProps.data),
        columnId: cellProps.id,
        columnIndex: cellProps.computedVisibleIndex,
        rowIndex: cellProps.rowIndex,
        cellProps: cellProps
      });
    }
  }, [props.onEditComplete]);
  var tryRowCellEdit = (0, _react.useCallback)(function (editIndex) {
    var dir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var isEnterNavigation = arguments.length > 2 ? arguments[2] : undefined;
    var cols = props.columns;
    var col;
    var colIndex;

    if (!dir) {
      dir = 1;
    }

    dir = dir == 1 ? 1 : -1;
    var currentIndex = dir == 1 ? 0 : cols.length - 1;
    var foundCols = [];

    while (cols[currentIndex]) {
      col = cols[currentIndex];

      if (col.editable || props.editable && col.editable !== false) {
        colIndex = col.computedVisibleIndex;

        if (colIndex == editIndex) {
          foundCols.push(col);
        } else {
          if (dir < 0) {
            if (colIndex < editIndex) {
              foundCols.push(col);
            }
          } else if (dir > 0) {
            if (colIndex > editIndex) {
              foundCols.push(col);
            }
          }
        }
      }

      currentIndex += dir;
    }

    if (!foundCols.length) {
      tryNextRowEdit(dir, isEnterNavigation ? editIndex : dir > 0 ? 0 : props.columns.length - 1);
      return Promise.reject(null);
    }

    foundCols.sort(function (a, b) {
      return dir > 0 ? a - b : b - a;
    });
    return new Promise(function (resolve, reject) {
      var startEdit = function startEdit(cols) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        props.currentEditCompletePromise.current.then(function () {
          var errBack = function errBack() {
            isEnterNavigation ? tryNextRowEdit(dir, editIndex, true) : startEdit(cols, index + 1);
          };

          var col = cols[index];

          if (!col) {
            tryNextRowEdit(dir, isEnterNavigation ? editIndex : dir > 0 ? 0 : props.columns.length - 1);
            return reject('column not found');
          }

          var cell = getCellById(col.id);

          if (!cell) {
            if (props.scrollToColumn) {
              props.scrollToColumn(col.id, undefined, function () {
                setTimeout(function () {
                  startEdit(cols, index);
                }, 20);
              });
            }

            return;
          }

          setTimeout(function () {
            return cell.startEdit(undefined, errBack).then(resolve).catch(errBack);
          }, 0);
        }).catch(function (error) {
          return reject(error);
        });
        return;
      };

      startEdit(foundCols, 0);
    });
  }, [props.columns, props.editable, props.currentEditCompletePromise, props.rowIndex, props.scrollToColumn]);
  var tryNextRowEdit = (0, _react.useCallback)(function (dir, columnIndex, isEnterNavigation) {
    if (props.scrollToIndexIfNeeded) {
      props.scrollToIndexIfNeeded(props.rowIndex + 2 * dir, {
        direction: dir == -1 ? 'top' : 'bottom'
      }, function () {
        if (props.tryNextRowEdit) {
          props.tryNextRowEdit(props.rowIndex + dir, dir, columnIndex, isEnterNavigation);
        }
      });
    }
  }, [props.rowIndex, props.scrollToIndexIfNeeded, props.tryNextRowEdit]);
  var onTransitionEnd = (0, _react.useCallback)(function (cellProps, columnProps, e) {
    e.stopPropagation();

    if (columnProps.onTransitionEnd) {
      columnProps.onTransitionEnd(e);
    }

    if (props.onTransitionEnd) {
      props.onTransitionEnd(e, cellProps);
    }
  }, [props.onTransitionEnd]);
  var getColumnRenderRange = (0, _react.useCallback)(function (cellProps) {
    var virtualizeColumns = getVirtualizeColumns();

    if (!virtualizeColumns) {
      return null;
    }

    var minStartIndex = props.lockedStartColumns.length ? props.lockedStartColumns.length : props.groupProps && !props.groupColumn ? props.groupProps.depth + 2 : 0;
    var maxEndIndex = props.columns.length - props.lockedEndColumns.length - 1;
    var columnStartIndex = columnRenderStartIndex.current == null ? props.columnRenderStartIndex || 0 : columnRenderStartIndex.current;
    columnStartIndex = Math.max(columnStartIndex, minStartIndex);

    var fixStartIndexForColspan = function fixStartIndexForColspan() {
      if (cellProps) {
        while (cellProps[columnStartIndex].computedColspanedBy) {
          columnStartIndex--;
        }
      }
    };

    if (props.columnRenderCount != null) {
      var columnRenderEndIndex = columnStartIndex + props.columnRenderCount;
      columnRenderEndIndex = Math.min(columnRenderEndIndex, maxEndIndex);

      if (columnRenderEndIndex - props.columnRenderCount != columnStartIndex) {
        columnStartIndex = Math.max(columnRenderEndIndex - props.columnRenderCount, minStartIndex);
      }

      if (columnRenderEndIndex < 0) {
        return {
          start: 0,
          end: 0
        };
      }

      fixStartIndexForColspan();
      return {
        start: columnStartIndex,
        end: columnRenderEndIndex
      };
    }

    return null;
  }, [props.virtualizeColumns, props.columnRenderCount, props.lockedStartColumns, props.lockedEndColumns, props.groupColumn, props.groupProps, props.columnRenderStartIndex, props.columns]);
  var expandRangeWithColspan = (0, _react.useCallback)(function (range, cellProps) {
    var extraNeededColumns = cellProps.reduce(function (total, cellProps) {
      return total + (cellProps.computedColspan > 1 ? cellProps.computedColspan - 1 : 0);
    }, 0);

    if (!extraNeededColumns) {
      return range;
    }

    if (range.start < props.firstUnlockedIndex) {
      range.start = props.firstUnlockedIndex;
    }

    if (range.start > extraNeededColumns) {
      range.start -= extraNeededColumns;
      return range;
    }

    extraNeededColumns -= range.start;
    range.start = 0;

    if (extraNeededColumns) {
      range.end += extraNeededColumns;
    }

    return range;
  }, []);

  var renderRowInstance = function renderRowInstance(_, __, style) {
    var scrollLeft = props.scrollLeft,
        hasLockedStart = props.hasLockedStart,
        hasLockedEnd = props.hasLockedEnd,
        lockedStartColumns = props.lockedStartColumns,
        lockedEndColumns = props.lockedEndColumns,
        computedHasColSpan = props.computedHasColSpan,
        groupProps = props.groupProps,
        columns = props.columns;
    var virtualizeColumns = getVirtualizeColumns();
    var cellProps;

    if (!virtualizeColumns) {
      cellProps = getPropsForCells();
    } else {
      var lockedStartCellProps = [];
      var lockedEndCellProps = [];
      var groupCellProps = [];
      var renderRange;

      if (computedHasColSpan) {
        cellProps = getPropsForCells();

        if (hasLockedStart) {
          lockedStartCellProps = cellProps.slice(0, lockedStartColumns.length);
        } else if (groupProps) {
          groupCellProps = cellProps.slice(0, groupProps.depth + 2);
        }

        if (hasLockedEnd) {
          lockedEndCellProps = cellProps.slice(columns.length - lockedEndColumns.length, columns.length);
        }

        renderRange = getColumnRenderRange(cellProps);

        if (renderRange) {
          renderRange = expandRangeWithColspan(renderRange, cellProps);
          cellProps = cellProps.slice(renderRange.start, renderRange.end + 1);
        }
      } else {
        var _renderRange4, _renderRange5;

        renderRange = getColumnRenderRange();
        cellProps = getPropsForCells((_renderRange4 = renderRange) === null || _renderRange4 === void 0 ? void 0 : _renderRange4.start, ((_renderRange5 = renderRange) === null || _renderRange5 === void 0 ? void 0 : _renderRange5.end) || 0);

        if (hasLockedStart) {
          lockedStartCellProps = getPropsForCells(0, lockedStartColumns.length - 1);
        } else if (groupProps) {
          groupCellProps = getPropsForCells(0, groupProps.depth + 2 - 1);
        }

        if (hasLockedEnd) {
          lockedEndCellProps = getPropsForCells(lockedEndColumns[0].computedVisibleIndex, columns.length - 1);
        }
      }

      if (hasLockedStart) {
        cellProps = [].concat((0, _toConsumableArray2.default)(lockedStartCellProps), (0, _toConsumableArray2.default)(cellProps));
      } else if (groupProps) {
        cellProps = [].concat((0, _toConsumableArray2.default)(groupCellProps), (0, _toConsumableArray2.default)(cellProps));
      }

      if (hasLockedEnd) {
        var _cellProps2;

        (_cellProps2 = cellProps).push.apply(_cellProps2, (0, _toConsumableArray2.default)(lockedEndCellProps));
      }
    }

    var result = cellProps.map(function (cProps, index) {
      var cell;
      var key = index;

      if (!virtualizeColumns) {
        key = cProps.id || index;
      }

      if (props.cellFactory) {
        cell = props.cellFactory(cProps);
      }

      if (cell === undefined) {
        cell = _react.default.createElement(_Cell.default, _objectSpread(_objectSpread({}, cProps), {}, {
          ref: cProps.cellRef ? cProps.cellRef : null,
          key: key
        }));
      }

      return cell;
    });
    return (0, _renderCellsMaybeLocked.default)(result, props, scrollLeft, undefined, style);
  };

  var onClick = (0, _react.useCallback)(function (event) {
    if (props.computedTreeEnabled && props.expandOnMouseDown) {
      toggleNodeExpand(props.rowIndex);
    }

    if (props.onClick) {
      props.onClick(event, props);
    }

    if (props.passedProps && props.passedProps.onClick) {
      props.passedProps.onClick(event, props);
    }
  }, [props.passedProps, props.computedTreeEnabled, props.rowIndex, props.expandOnMouseDown, props.onClick]);
  var onMouseDown = (0, _react.useCallback)(function (event) {
    if (props.onMouseDown) {
      props.onMouseDown(event, props);
    }
  }, [props.onMouseDown]);
  (0, _react.useImperativeHandle)(ref, function () {
    return {
      onCellUnmount: onCellUnmount,
      cleanupCells: cleanupCells,
      getDOMNode: getDOMNode,
      orderCells: orderCells,
      updateEditCell: updateEditCell,
      fixForColspan: fixForColspan,
      setScrolling: setScrolling,
      renderRowDetails: renderRowDetails,
      onContextMenu: onContextMenu,
      setCellIndex: setCellIndex,
      getCellIndex: getCellIndex,
      sortCells: sortCells,
      getCellAt: getCellAt,
      getCellById: getCellById,
      getCells: getCells,
      getSortedCells: getSortedCells,
      getGaps: getGaps,
      getVirtualizeColumns: getVirtualizeColumns,
      toggleRowExpand: toggleRowExpand,
      toggleNodeExpand: toggleNodeExpand,
      loadNodeAsync: loadNodeAsync,
      isRowExpandable: isRowExpandable,
      setRowExpanded: setRowExpanded,
      setColumnRenderStartIndex: setColumnRenderStartIndex,
      getPropsForCells: getPropsForCells,
      onCellStopEdit: onCellStopEdit,
      onCellStartEdit: onCellStartEdit,
      onCellEditCancel: onCellEditCancel,
      onCellEditValueChange: onCellEditValueChange,
      onCellEditComplete: onCellEditComplete,
      tryRowCellEdit: tryRowCellEdit,
      tryNextRowEdit: tryNextRowEdit,
      onTransitionEnd: onTransitionEnd,
      getColumnRenderRange: getColumnRenderRange,
      expandRangeWithColspan: expandRangeWithColspan,
      renderRow: renderRow,
      onClick: onClick,
      onMouseDown: onMouseDown,
      getCurrentGaps: getCurrentGaps,
      rowProps: rowProps,
      domRef: domRef,
      props: props
    };
  });
  var rowHeight = props.rowHeight,
      initialRowHeight = props.initialRowHeight,
      maxRowHeight = props.maxRowHeight,
      groupNestingSize = props.groupNestingSize,
      summaryProps = props.summaryProps,
      data = props.data,
      id = props.id,
      columns = props.columns,
      minWidth = props.minWidth,
      maxWidth = props.maxWidth,
      rowStyle = props.rowStyle,
      scrollbars = props.scrollbars,
      renderRow = props.renderRow,
      computedRowExpandEnabled = props.computedRowExpandEnabled,
      even = props.even,
      odd = props.odd,
      active = props.active,
      selected = props.selected,
      expanded = props.expanded,
      passedProps = props.passedProps,
      realIndex = props.realIndex,
      remoteRowIndex = props.remoteRowIndex,
      nativeScroll = props.nativeScroll,
      indexInGroup = props.indexInGroup,
      naturalRowHeight = props.naturalRowHeight,
      rowDetailsStyle = props.rowDetailsStyle,
      renderDetailsGrid = props.renderDetailsGrid,
      last = props.last,
      empty = props.empty,
      computedPivot = props.computedPivot,
      computedShowZebraRows = props.computedShowZebraRows,
      rowDetailsWidth = props.rowDetailsWidth,
      availableWidth = props.availableWidth,
      groupProps = props.groupProps,
      groupColumn = props.groupColumn,
      dataSourceArray = props.dataSourceArray,
      onRenderRow = props.onRenderRow,
      shouldRenderCollapsedRowDetails = props.shouldRenderCollapsedRowDetails,
      editing = props.editing,
      rtl = props.rtl,
      sticky = props.sticky,
      hasLockedEnd = props.hasLockedEnd,
      hasLockedStart = props.hasLockedStart,
      showHorizontalCellBorders = props.showHorizontalCellBorders;
  var rowClassName = props.rowClassName;
  var virtualizeColumns = getVirtualizeColumns();
  var lastInGroup = indexInGroup == props.groupCount - 1;
  var hasRowSpan = props.computedRowspans && Object.keys(props.computedRowspans).map(function (name) {
    var rowspan = props.computedRowspans[name];
    return rowspan > 1;
  }).find(function (rowSpan) {
    return rowSpan === true;
  });
  var className = (0, _join.default)(props.className, CLASS_NAME, scrollingInProgress.current && "".concat(CLASS_NAME, "--scrolling"), empty && "".concat(CLASS_NAME, "--empty"), editing && "".concat(CLASS_NAME, "--editing"), "".concat(CLASS_NAME, "--direction-").concat(rtl ? 'rtl' : 'ltr'), computedShowZebraRows && even && (!groupProps || computedPivot) && "".concat(CLASS_NAME, "--even"), computedShowZebraRows && odd && (!groupProps || computedPivot) && "".concat(CLASS_NAME, "--odd"), !computedShowZebraRows && !groupProps && "".concat(CLASS_NAME, "--no-zebra"), groupProps && "".concat(CLASS_NAME, "--group-row"), summaryProps && "".concat(CLASS_NAME, "--summary-row"), summaryProps && "".concat(CLASS_NAME, "--summary-position-").concat(summaryProps.position), groupProps && groupProps.collapsed && "".concat(CLASS_NAME, "--collapsed"), selected && "".concat(CLASS_NAME, "--selected"), expanded && "".concat(CLASS_NAME, "--expanded"), hasLockedStart ? "".concat(CLASS_NAME, "--has-locked-start") : "".concat(CLASS_NAME, "--no-locked-start"), hasLockedEnd ? "".concat(CLASS_NAME, "--has-locked-end") : "".concat(CLASS_NAME, "--no-locked-end"), showHorizontalCellBorders && "".concat(CLASS_NAME, "--show-horizontal-borders"), active && "".concat(CLASS_NAME, "--active"), virtualizeColumns && "".concat(CLASS_NAME, "--virtualize-columns"), rowHeight && "".concat(CLASS_NAME, "--rowheight"), naturalRowHeight && "".concat(CLASS_NAME, "--natural-rowheight"), realIndex == 0 && "".concat(CLASS_NAME, "--first"), last && "".concat(CLASS_NAME, "--last"), indexInGroup == 0 && "".concat(CLASS_NAME, "--first-in-group"), lastInGroup && "".concat(CLASS_NAME, "--last-in-group"), hasRowSpan ? "".concat(CLASS_NAME, "--has-rowspan") : '');

  if (passedProps) {
    className = (0, _join.default)(className, selected && passedProps.selectedClassName);
  }

  var style = _objectSpread(_objectSpread({}, props.style), {}, {
    height: naturalRowHeight ? null : rowHeight,
    width: props.width,
    minWidth: minWidth,
    direction: 'ltr'
  });

  if (maxWidth != null) {
    style.maxWidth = maxWidth;
  }

  if (maxRowHeight != null) {
    style.maxHeight = maxRowHeight;
  }

  if (rowStyle) {
    if (typeof rowStyle === 'function') {
      var rowStyleResult = rowStyle({
        data: data,
        props: props,
        style: style
      });

      if (rowStyleResult !== undefined) {
        style = _objectSpread(_objectSpread({}, style), rowStyleResult);
      }
    } else {
      style = _objectSpread(_objectSpread({}, style), rowStyle);
    }
  }

  if (rowClassName) {
    if (typeof rowClassName === 'function') {
      rowClassName = rowClassName({
        data: data,
        props: props,
        className: className
      });
    }

    if (rowClassName && typeof rowClassName == 'string') {
      className = (0, _join.default)(className, rowClassName);
    }
  }

  var rowProps = _objectSpread(_objectSpread(_objectSpread({}, props), {}, {
    className: className,
    style: style,
    ref: domRef
  }, passedProps), {}, {
    onClick: onClick,
    onContextMenu: onContextMenu
  });

  rowProps.children = [_react.default.createElement("div", {
    key: "cellWrap",
    className: "InovuaReactDataGrid__row-cell-wrap InovuaReactDataGrid__row-hover-target",
    style: {
      width: props.width,
      height: naturalRowHeight ? null : rowHeight,
      position: 'absolute',
      top: 0,
      left: rtl ? -(props.emptyScrollOffset || 0) : 0
    }
  }, renderRowInstance(data, columns, style))];
  var groupDepth = groupColumn ? 0 : data && data.__group ? data.depth - 1 : data && data.__summary ? rowProps.summaryProps.depth : props.depth || 0;
  var activeBordersDiv = sticky ? _react.default.createElement("div", {
    key: "active-row-borders",
    className: (0, _join.default)("".concat(CLASS_NAME, "-active-borders"), hasBorderTop.current && "".concat(CLASS_NAME, "-active-borders--has-border-top"), hasBorderBottom.current && "".concat(CLASS_NAME, "-actived-borders--has-border-bottom"))
  }) : null;
  var shouldRender = expanded || shouldRenderCollapsedRowDetails;

  if (computedRowExpandEnabled && shouldRender && !data.__group) {
    var rowDetailsInfo = {
      data: data,
      rtl: rtl,
      isRowExpandable: isRowExpandable,
      rowIndex: realIndex,
      remoteRowIndex: remoteRowIndex,
      rowId: props.getItemId(data),
      rowExpanded: expanded,
      id: id,
      rowSelected: selected,
      rowActive: active,
      toggleRowExpand: toggleRowExpand,
      setRowExpanded: setRowExpanded,
      dataSource: dataSourceArray
    };
    var detailsStyle = {
      position: 'absolute',
      height: rowHeight - initialRowHeight,
      overflow: renderDetailsGrid ? 'visible' : 'auto',
      top: initialRowHeight
    };

    if (rtl) {
      detailsStyle.direction = 'rtl';
    }

    if (rowDetailsWidth == 'max-viewport-width') {
      detailsStyle.width = Math.min(availableWidth, props.width || maxWidth);
    }

    if (rowDetailsWidth === 'min-viewport-width') {
      detailsStyle.width = Math.max(availableWidth, props.width || maxWidth);
    }

    if (rowDetailsWidth === 'viewport-width') {
      detailsStyle.width = availableWidth;
    }

    if (groupDepth) {
      detailsStyle[rtl ? 'paddingRight' : 'paddingLeft'] = (groupNestingSize || 0) * groupDepth;
    }

    detailsStyle[rtl ? 'right' : 'left'] = 0;

    if (isNaN(detailsStyle.width)) {
      delete detailsStyle.width;
    }

    if (!expanded) {
      detailsStyle.display = 'none';
    }

    if (rowDetailsStyle) {
      if (typeof rowDetailsStyle === 'function') {
        var styleResult = rowDetailsStyle(detailsStyle, rowDetailsInfo);

        if (styleResult !== undefined) {
          detailsStyle = styleResult;
        }
      } else {
        detailsStyle = _objectSpread(_objectSpread({}, detailsStyle), rowDetailsStyle);
      }
    }

    var showBorderBottom = !lastInGroup || last;

    if (nativeScroll && last && expanded) {
      showBorderBottom = false;
    }

    rowProps.children.push(_react.default.createElement("div", {
      key: "rowDetails",
      style: detailsStyle,
      onClick: skipSelect,
      className: (0, _join.default)("".concat(CLASS_NAME, "-details"), "".concat(CLASS_NAME, "-details--").concat(rowDetailsWidth), renderDetailsGrid ? "".concat(CLASS_NAME, "-details--details-grid") : null, !nativeScroll || nativeScroll && scrollbars && !scrollbars.vertical || availableWidth > minWidth ? "".concat(CLASS_NAME, "-details--show-border-right") : null, showBorderBottom ? "".concat(CLASS_NAME, "-details--show-border-bottom") : '')
    }, renderRowDetails(rowDetailsInfo)), _react.default.createElement("div", {
      className: "".concat(CLASS_NAME, "-details-special-bottom-border"),
      key: "row-details-special-bottom-border",
      style: (0, _defineProperty2.default)({}, rtl ? 'right' : 'left', (groupDepth || 0) * groupNestingSize)
    }), groupDepth ? (0, _toConsumableArray2.default)(new Array(groupDepth)).map(function (_, index) {
      var _style2;

      return _react.default.createElement("div", {
        key: index,
        className: "".concat(CLASS_NAME, "-details-border"),
        style: (_style2 = {
          height: '100%',
          position: 'absolute'
        }, (0, _defineProperty2.default)(_style2, rtl ? 'right' : 'left', (index + 1) * groupNestingSize), (0, _defineProperty2.default)(_style2, "top", 0), _style2)
      });
    }) : null, rowDetailsWidth != 'max-viewport-width' ? _react.default.createElement("div", {
      key: "rowDetailsBorder",
      style: (0, _defineProperty2.default)({
        top: initialRowHeight - 1,
        width: availableWidth
      }, rtl ? 'right' : 'left', (groupDepth || 0) * groupNestingSize),
      className: "".concat(CLASS_NAME, "-details-special-top-border")
    }) : null);
  }

  if (sticky) {
    if (activeBordersDiv) {
      var _style4;

      rowProps.children.push(_react.default.createElement("div", {
        key: "active-row-borders",
        className: "InovuaReactDataGrid__row-active-borders-wrapper",
        style: (_style4 = {
          height: '100%',
          position: 'absolute',
          top: 0
        }, (0, _defineProperty2.default)(_style4, rtl ? 'right' : 'left', (groupNestingSize || 0) * groupDepth), (0, _defineProperty2.default)(_style4, "width", availableWidth - (groupNestingSize || 0) * groupDepth), (0, _defineProperty2.default)(_style4, "pointerEvents", 'none'), _style4)
      }, activeBordersDiv));
    }
  }

  var row;

  if (renderRow) {
    row = renderRow(rowProps);
  }

  if (onRenderRow) {
    onRenderRow(rowProps);
  }

  if (row === undefined) {
    row = _react.default.createElement("div", _objectSpread(_objectSpread({}, (0, _reactCleanProps.default)(rowProps, DataGridRow.propTypes)), {}, {
      id: null,
      data: null,
      value: null
    }));
  }

  return row;
});

var emptyFn = function emptyFn() {};

DataGridRow.defaultProps = {
  onClick: emptyFn,
  onMouseEnter: emptyFn,
  onMouseLeave: emptyFn,
  onMouseDown: emptyFn,
  columnRenderStartIndex: 0,
  showAllGroupCells: false
};
DataGridRow.propTypes = {
  rowActive: _propTypes.default.bool,
  rowSelected: _propTypes.default.bool,
  availableWidth: _propTypes.default.number,
  computedGroupBy: _propTypes.default.array,
  expandGroupTitle: _propTypes.default.bool,
  expandColumn: _propTypes.default.any,
  getCellSelectionKey: _propTypes.default.func,
  depth: _propTypes.default.number,
  columns: _propTypes.default.array,
  columnsMap: _propTypes.default.shape({}),
  active: _propTypes.default.bool,
  computedActiveCell: _propTypes.default.any,
  cellFactory: _propTypes.default.func,
  computedCellMultiSelectionEnabled: _propTypes.default.bool,
  computedCellSelection: _propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.array]),
  columnRenderCount: _propTypes.default.number,
  columnRenderStartIndex: _propTypes.default.number,
  columnUserSelect: _propTypes.default.bool,
  deselectAll: _propTypes.default.func,
  empty: _propTypes.default.bool,
  even: _propTypes.default.bool,
  firstLockedEndIndex: _propTypes.default.number,
  firstLockedStartIndex: _propTypes.default.number,
  firstUnlockedIndex: _propTypes.default.number,
  flex: _propTypes.default.number,
  groupCount: _propTypes.default.number,
  groupNestingSize: _propTypes.default.number,
  treeNestingSize: _propTypes.default.number,
  groupProps: _propTypes.default.object,
  summaryProps: _propTypes.default.object,
  hasLockedEnd: _propTypes.default.bool,
  hasLockedStart: _propTypes.default.bool,
  indexInGroup: _propTypes.default.number,
  last: _propTypes.default.bool,
  lastCellInRange: _propTypes.default.any,
  lastNonEmpty: _propTypes.default.bool,
  lastRowInGroup: _propTypes.default.bool,
  lockedEndColumns: _propTypes.default.array,
  lockedStartColumns: _propTypes.default.array,
  maxRowHeight: _propTypes.default.number,
  minRowHeight: _propTypes.default.number,
  maxVisibleRows: _propTypes.default.number,
  minWidth: _propTypes.default.number,
  multiSelect: _propTypes.default.bool,
  odd: _propTypes.default.bool,
  onArrowDown: _propTypes.default.func,
  onArrowUp: _propTypes.default.func,
  onCellClick: _propTypes.default.func,
  onCellEnter: _propTypes.default.func,
  onCellMouseDown: _propTypes.default.func,
  onCellSelectionDraggerMouseDown: _propTypes.default.func,
  onRowContextMenu: _propTypes.default.func,
  passedProps: _propTypes.default.object,
  realIndex: _propTypes.default.number,
  renderIndex: _propTypes.default.number,
  renderRow: _propTypes.default.func,
  onRenderRow: _propTypes.default.func,
  rowHeight: _propTypes.default.number,
  rowExpandHeight: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.func]),
  initialRowHeight: _propTypes.default.number,
  defaultRowHeight: _propTypes.default.number,
  emptyScrollOffset: _propTypes.default.number,
  rowIndex: _propTypes.default.number,
  remoteRowIndex: _propTypes.default.number,
  rowIndexInGroup: _propTypes.default.bool,
  rowStyle: _propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.func]),
  rowClassName: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]),
  scrollLeft: _propTypes.default.number,
  selectAll: _propTypes.default.func,
  selected: _propTypes.default.bool,
  expanded: _propTypes.default.bool,
  selection: _propTypes.default.any,
  computedRowExpandEnabled: _propTypes.default.bool,
  computedTreeEnabled: _propTypes.default.bool,
  computedRenderRowDetails: _propTypes.default.func,
  isRowExpandableAt: _propTypes.default.func,
  setRowSelected: _propTypes.default.func,
  setRowExpanded: _propTypes.default.func,
  toggleRowExpand: _propTypes.default.func,
  toggleNodeExpand: _propTypes.default.func,
  expandOnMouseDown: _propTypes.default.bool,
  loadNodeAsync: _propTypes.default.func,
  showAllGroupCells: _propTypes.default.bool,
  computedShowCellBorders: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.bool]),
  showHorizontalCellBorders: _propTypes.default.bool,
  showVerticalCellBorders: _propTypes.default.bool,
  totalColumnCount: _propTypes.default.number,
  totalComputedWidth: _propTypes.default.number,
  totalDataCount: _propTypes.default.number,
  totalLockedEndWidth: _propTypes.default.number,
  totalLockedStartWidth: _propTypes.default.number,
  totalUnlockedWidth: _propTypes.default.number,
  unlockedColumns: _propTypes.default.array,
  virtualizeColumns: _propTypes.default.bool,
  nativeScroll: _propTypes.default.bool,
  shouldRenderCollapsedRowDetails: _propTypes.default.bool,
  rowDetailsStyle: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object]),
  dataSourceArray: _propTypes.default.array,
  getItemId: _propTypes.default.func.isRequired,
  editable: _propTypes.default.bool,
  editing: _propTypes.default.bool,
  editValue: _propTypes.default.any,
  editRowIndex: _propTypes.default.number,
  editColumnIndex: _propTypes.default.number,
  editColumnId: _propTypes.default.any,
  naturalRowHeight: _propTypes.default.bool,
  renderDetailsGrid: _propTypes.default.func,
  scrollToColumn: _propTypes.default.func,
  scrollToIndexIfNeeded: _propTypes.default.func,
  renderNodeTool: _propTypes.default.func,
  computedEnableRowspan: _propTypes.default.bool,
  setRowSpan: _propTypes.default.func,
  treeColumn: _propTypes.default.string,
  scrollbars: _propTypes.default.shape({
    horizontal: _propTypes.default.bool,
    vertical: _propTypes.default.bool
  }),
  rtl: _propTypes.default.bool,
  computedPivot: _propTypes.default.array,
  groupColumnSummaries: _propTypes.default.any,
  groupSummary: _propTypes.default.any,
  groupColumn: _propTypes.default.any,
  lastUnlockedIndex: _propTypes.default.number,
  lastLockedEndIndex: _propTypes.default.number,
  lastLockedStartIndex: _propTypes.default.number,
  computedShowZebraRows: _propTypes.default.bool,
  computedRowspans: _propTypes.default.any,
  editStartEvent: _propTypes.default.string,
  onGroupToggle: _propTypes.default.func,
  onEditStop: _propTypes.default.func,
  onEditStart: _propTypes.default.func,
  onEditCancel: _propTypes.default.func,
  onEditValueChange: _propTypes.default.func,
  onEditComplete: _propTypes.default.func,
  onFilterValueChange: _propTypes.default.func,
  tryNextRowEdit: _propTypes.default.func,
  getScrollLeftMax: _propTypes.default.func,
  activeRowRef: _propTypes.default.any,
  sticky: _propTypes.default.bool,
  edition: _propTypes.default.string,
  computedLicenseValid: _propTypes.default.bool,
  parentGroupDataArray: _propTypes.default.any,
  rowDetailsWidth: _propTypes.default.oneOf(['max-viewport-width', 'min-viewport-width', 'viewport-width']),
  computedHasColSpan: _propTypes.default.bool,
  onRowReorder: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.bool]),
  onDragRowMouseDown: _propTypes.default.func,
  renderLockedStartCells: _propTypes.default.func,
  renderLockedEndCells: _propTypes.default.func,
  setActiveIndex: _propTypes.default.func,
  renderTreeCollapseTool: _propTypes.default.func,
  renderTreeExpandTool: _propTypes.default.func,
  renderTreeLoadingTool: _propTypes.default.func,
  currentEditCompletePromise: _propTypes.default.any,
  enableColumnAutosize: _propTypes.default.bool,
  columnHoverClassName: _propTypes.default.string,
  computedEnableColumnHover: _propTypes.default.bool,
  onColumnMouseEnter: _propTypes.default.func,
  onColumnMouseLeave: _propTypes.default.func,
  columnIndexHovered: _propTypes.default.number,
  renderRowDetailsExpandIcon: _propTypes.default.func,
  renderRowDetailsCollapsedIcon: _propTypes.default.func
};

var _default = _react.default.memo(DataGridRow, function (prevProps, nextProps) {
  var areEqual = (0, _shallowequal.equalReturnKey)(prevProps, nextProps, {
    computedActiveCell: 1,
    computedActiveIndex: 1,
    columnRenderStartIndex: 1,
    activeRowRef: 1,
    active: 1,
    onKeyDown: 1,
    onFocus: 1,
    setRowSpan: 1,
    passedProps: 1,
    computedRowspans: 1,
    lockedStartColumns: 1,
    selection: 1,
    lockedEndColumns: 1,
    unlockedColumns: 1,
    maxVisibleRows: 1,
    onClick: 1,
    style: 1,
    loadNodeAsync: 1,
    scrollToIndexIfNeeded: 1,
    onColumnMouseEnter: 1,
    onColumnMouseLeave: 1,
    computedCellSelection: 1,
    getCellSelectionKey: 1
  });

  if (areEqual.result) {
    if (prevProps.computedActiveCell != nextProps.computedActiveCell) {
      var _ref2 = prevProps.computedActiveCell || [],
          _ref3 = (0, _slicedToArray2.default)(_ref2, 1),
          oldRowIndex = _ref3[0];

      var _ref4 = nextProps.computedActiveCell || [],
          _ref5 = (0, _slicedToArray2.default)(_ref4, 1),
          newRowIndex = _ref5[0];

      if (oldRowIndex === nextProps.rowIndex || newRowIndex === nextProps.rowIndex) {
        return false;
      }
    }
  }

  if (!areEqual.result) {
    return false;
  }

  if (prevProps.active !== nextProps.active) {
    return false;
  }

  if (JSON.stringify(prevProps.style) !== JSON.stringify(nextProps.style)) {
    return false;
  }

  var prevActiveCellRow, prevActiveColumn;
  var activeCellRow, activeColumn;

  if (prevProps.computedActiveCell) {
    var _prevProps$computedAc = (0, _slicedToArray2.default)(prevProps.computedActiveCell, 2);

    prevActiveCellRow = _prevProps$computedAc[0];
    prevActiveColumn = _prevProps$computedAc[1];
  }

  if (nextProps.computedActiveCell) {
    var _nextProps$computedAc = (0, _slicedToArray2.default)(nextProps.computedActiveCell, 2);

    activeCellRow = _nextProps$computedAc[0];
    activeColumn = _nextProps$computedAc[1];
  }

  if (activeCellRow !== prevActiveCellRow) {
    if (nextProps.rowIndex === activeCellRow || nextProps.rowIndex === prevActiveCellRow) {
      return false;
    }
  } else {
    if (nextProps.rowIndex === activeCellRow && activeColumn !== prevActiveColumn) {
      return false;
    }
  }

  return true;
});

exports.default = _default;